#![cfg_attr(feature = "rt", feature(global_asm))]
#![cfg_attr(feature = "rt", feature(use_extern_macros))]
#![cfg_attr(feature = "rt", feature(used))]
#![doc = "Peripheral access API for LPC13XX microcontrollers (generated using svd2rust v0.12.1)\n\nYou can find an overview of the API [here].\n\n[here]: https://docs.rs/svd2rust/0.12.1/svd2rust/#peripheral-api"]
#![allow(private_no_mangle_statics)]
#![deny(missing_docs)]
#![deny(warnings)]
#![allow(non_camel_case_types)]
#![feature(const_fn)]
#![feature(try_from)]
#![no_std]
extern crate cortex_m;
#[cfg(feature = "rt")]
extern crate cortex_m_rt;
#[cfg(feature = "rt")]
pub use cortex_m_rt::{default_handler, exception};
extern crate bare_metal;
extern crate vcell;
use core::marker::PhantomData;
use core::ops::Deref;
pub use interrupt::Interrupt;
#[doc(hidden)]
pub mod interrupt {
    use bare_metal::Nr;
    #[cfg(feature = "rt")]
    extern "C" {
        fn DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    #[allow(non_snake_case)]
    #[no_mangle]
    pub unsafe extern "C" fn DH_TRAMPOLINE() {
        DEFAULT_HANDLER();
    }
    #[cfg(feature = "rt")]
    global_asm ! ( "\n.weak PIO0_0\nPIO0_0 = DH_TRAMPOLINE\n.weak PIO0_1\nPIO0_1 = DH_TRAMPOLINE\n.weak PIO0_2\nPIO0_2 = DH_TRAMPOLINE\n.weak PIO0_3\nPIO0_3 = DH_TRAMPOLINE\n.weak PIO0_4\nPIO0_4 = DH_TRAMPOLINE\n.weak PIO0_5\nPIO0_5 = DH_TRAMPOLINE\n.weak PIO0_6\nPIO0_6 = DH_TRAMPOLINE\n.weak PIO0_7\nPIO0_7 = DH_TRAMPOLINE\n.weak PIO0_8\nPIO0_8 = DH_TRAMPOLINE\n.weak PIO0_9\nPIO0_9 = DH_TRAMPOLINE\n.weak PIO0_10\nPIO0_10 = DH_TRAMPOLINE\n.weak PIO0_11\nPIO0_11 = DH_TRAMPOLINE\n.weak PIO1_0\nPIO1_0 = DH_TRAMPOLINE\n.weak PIO1_1\nPIO1_1 = DH_TRAMPOLINE\n.weak PIO1_2\nPIO1_2 = DH_TRAMPOLINE\n.weak PIO1_3\nPIO1_3 = DH_TRAMPOLINE\n.weak PIO1_4\nPIO1_4 = DH_TRAMPOLINE\n.weak PIO1_5\nPIO1_5 = DH_TRAMPOLINE\n.weak PIO1_6\nPIO1_6 = DH_TRAMPOLINE\n.weak PIO1_7\nPIO1_7 = DH_TRAMPOLINE\n.weak PIO1_8\nPIO1_8 = DH_TRAMPOLINE\n.weak PIO1_9\nPIO1_9 = DH_TRAMPOLINE\n.weak PIO1_10\nPIO1_10 = DH_TRAMPOLINE\n.weak PIO1_11\nPIO1_11 = DH_TRAMPOLINE\n.weak PIO2_0\nPIO2_0 = DH_TRAMPOLINE\n.weak PIO2_1\nPIO2_1 = DH_TRAMPOLINE\n.weak PIO2_2\nPIO2_2 = DH_TRAMPOLINE\n.weak PIO2_3\nPIO2_3 = DH_TRAMPOLINE\n.weak PIO2_4\nPIO2_4 = DH_TRAMPOLINE\n.weak PIO2_5\nPIO2_5 = DH_TRAMPOLINE\n.weak PIO2_6\nPIO2_6 = DH_TRAMPOLINE\n.weak PIO2_7\nPIO2_7 = DH_TRAMPOLINE\n.weak PIO2_8\nPIO2_8 = DH_TRAMPOLINE\n.weak PIO2_9\nPIO2_9 = DH_TRAMPOLINE\n.weak PIO2_10\nPIO2_10 = DH_TRAMPOLINE\n.weak PIO2_11\nPIO2_11 = DH_TRAMPOLINE\n.weak PIO3_0\nPIO3_0 = DH_TRAMPOLINE\n.weak PIO3_1\nPIO3_1 = DH_TRAMPOLINE\n.weak PIO3_2\nPIO3_2 = DH_TRAMPOLINE\n.weak PIO3_3\nPIO3_3 = DH_TRAMPOLINE\n.weak I2C0\nI2C0 = DH_TRAMPOLINE\n.weak CT16B0\nCT16B0 = DH_TRAMPOLINE\n.weak CT16B1\nCT16B1 = DH_TRAMPOLINE\n.weak CT32B0\nCT32B0 = DH_TRAMPOLINE\n.weak CT32B1\nCT32B1 = DH_TRAMPOLINE\n.weak SSP0\nSSP0 = DH_TRAMPOLINE\n.weak UART\nUART = DH_TRAMPOLINE\n.weak USBIRQ\nUSBIRQ = DH_TRAMPOLINE\n.weak USBFIQ\nUSBFIQ = DH_TRAMPOLINE\n.weak ADC\nADC = DH_TRAMPOLINE\n.weak WDT\nWDT = DH_TRAMPOLINE\n.weak BOD\nBOD = DH_TRAMPOLINE\n.weak PIO_3\nPIO_3 = DH_TRAMPOLINE\n.weak PIO_2\nPIO_2 = DH_TRAMPOLINE\n.weak PIO_1\nPIO_1 = DH_TRAMPOLINE\n.weak PIO_0\nPIO_0 = DH_TRAMPOLINE\n.weak SSP1\nSSP1 = DH_TRAMPOLINE" ) ;
    #[cfg(feature = "rt")]
    extern "C" {
        fn PIO0_0();
        fn PIO0_1();
        fn PIO0_2();
        fn PIO0_3();
        fn PIO0_4();
        fn PIO0_5();
        fn PIO0_6();
        fn PIO0_7();
        fn PIO0_8();
        fn PIO0_9();
        fn PIO0_10();
        fn PIO0_11();
        fn PIO1_0();
        fn PIO1_1();
        fn PIO1_2();
        fn PIO1_3();
        fn PIO1_4();
        fn PIO1_5();
        fn PIO1_6();
        fn PIO1_7();
        fn PIO1_8();
        fn PIO1_9();
        fn PIO1_10();
        fn PIO1_11();
        fn PIO2_0();
        fn PIO2_1();
        fn PIO2_2();
        fn PIO2_3();
        fn PIO2_4();
        fn PIO2_5();
        fn PIO2_6();
        fn PIO2_7();
        fn PIO2_8();
        fn PIO2_9();
        fn PIO2_10();
        fn PIO2_11();
        fn PIO3_0();
        fn PIO3_1();
        fn PIO3_2();
        fn PIO3_3();
        fn I2C0();
        fn CT16B0();
        fn CT16B1();
        fn CT32B0();
        fn CT32B1();
        fn SSP0();
        fn UART();
        fn USBIRQ();
        fn USBFIQ();
        fn ADC();
        fn WDT();
        fn BOD();
        fn PIO_3();
        fn PIO_2();
        fn PIO_1();
        fn PIO_0();
        fn SSP1();
    }
    #[allow(private_no_mangle_statics)]
    #[cfg(feature = "rt")]
    #[doc(hidden)]
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    #[used]
    pub static INTERRUPTS: [Option<unsafe extern "C" fn()>; 58] = [
        Some(PIO0_0),
        Some(PIO0_1),
        Some(PIO0_2),
        Some(PIO0_3),
        Some(PIO0_4),
        Some(PIO0_5),
        Some(PIO0_6),
        Some(PIO0_7),
        Some(PIO0_8),
        Some(PIO0_9),
        Some(PIO0_10),
        Some(PIO0_11),
        Some(PIO1_0),
        Some(PIO1_1),
        Some(PIO1_2),
        Some(PIO1_3),
        Some(PIO1_4),
        Some(PIO1_5),
        Some(PIO1_6),
        Some(PIO1_7),
        Some(PIO1_8),
        Some(PIO1_9),
        Some(PIO1_10),
        Some(PIO1_11),
        Some(PIO2_0),
        Some(PIO2_1),
        Some(PIO2_2),
        Some(PIO2_3),
        Some(PIO2_4),
        Some(PIO2_5),
        Some(PIO2_6),
        Some(PIO2_7),
        Some(PIO2_8),
        Some(PIO2_9),
        Some(PIO2_10),
        Some(PIO2_11),
        Some(PIO3_0),
        Some(PIO3_1),
        Some(PIO3_2),
        Some(PIO3_3),
        Some(I2C0),
        Some(CT16B0),
        Some(CT16B1),
        Some(CT32B0),
        Some(CT32B1),
        Some(SSP0),
        Some(UART),
        Some(USBIRQ),
        Some(USBFIQ),
        Some(ADC),
        Some(WDT),
        Some(BOD),
        None,
        Some(PIO_3),
        Some(PIO_2),
        Some(PIO_1),
        Some(PIO_0),
        Some(SSP1),
    ];
    #[doc = r" Enumeration of all the interrupts"]
    pub enum Interrupt {
        #[doc = "0 - PIO0_0"]
        PIO0_0,
        #[doc = "1 - PIO0_1"]
        PIO0_1,
        #[doc = "2 - PIO0_2"]
        PIO0_2,
        #[doc = "3 - PIO0_3"]
        PIO0_3,
        #[doc = "4 - PIO0_4"]
        PIO0_4,
        #[doc = "5 - PIO0_5"]
        PIO0_5,
        #[doc = "6 - PIO0_6"]
        PIO0_6,
        #[doc = "7 - PIO0_7"]
        PIO0_7,
        #[doc = "8 - PIO0_8"]
        PIO0_8,
        #[doc = "9 - PIO0_9"]
        PIO0_9,
        #[doc = "10 - PIO0_10"]
        PIO0_10,
        #[doc = "11 - PIO0_11"]
        PIO0_11,
        #[doc = "12 - PIO1_0"]
        PIO1_0,
        #[doc = "13 - PIO1_1"]
        PIO1_1,
        #[doc = "14 - PIO1_2"]
        PIO1_2,
        #[doc = "15 - PIO1_3"]
        PIO1_3,
        #[doc = "16 - PIO1_4"]
        PIO1_4,
        #[doc = "17 - PIO1_5"]
        PIO1_5,
        #[doc = "18 - PIO1_6"]
        PIO1_6,
        #[doc = "19 - PIO1_7"]
        PIO1_7,
        #[doc = "20 - PIO1_8"]
        PIO1_8,
        #[doc = "21 - PIO1_9"]
        PIO1_9,
        #[doc = "22 - PIO1_10"]
        PIO1_10,
        #[doc = "23 - PIO1_11"]
        PIO1_11,
        #[doc = "24 - PIO2_0"]
        PIO2_0,
        #[doc = "25 - PIO2_1"]
        PIO2_1,
        #[doc = "26 - PIO2_2"]
        PIO2_2,
        #[doc = "27 - PIO2_3"]
        PIO2_3,
        #[doc = "28 - PIO2_4"]
        PIO2_4,
        #[doc = "29 - PIO2_5"]
        PIO2_5,
        #[doc = "30 - PIO2_6"]
        PIO2_6,
        #[doc = "31 - PIO2_7"]
        PIO2_7,
        #[doc = "32 - PIO2_8"]
        PIO2_8,
        #[doc = "33 - PIO2_9"]
        PIO2_9,
        #[doc = "34 - PIO2_10"]
        PIO2_10,
        #[doc = "35 - PIO2_11"]
        PIO2_11,
        #[doc = "36 - PIO3_0"]
        PIO3_0,
        #[doc = "37 - PIO3_1"]
        PIO3_1,
        #[doc = "38 - PIO3_2"]
        PIO3_2,
        #[doc = "39 - PIO3_3"]
        PIO3_3,
        #[doc = "40 - I2C0"]
        I2C0,
        #[doc = "41 - CT16B0"]
        CT16B0,
        #[doc = "42 - CT16B1"]
        CT16B1,
        #[doc = "43 - CT32B0"]
        CT32B0,
        #[doc = "44 - CT32B1"]
        CT32B1,
        #[doc = "45 - SSP0"]
        SSP0,
        #[doc = "46 - UART"]
        UART,
        #[doc = "47 - USBIRQ"]
        USBIRQ,
        #[doc = "48 - USBFIQ"]
        USBFIQ,
        #[doc = "49 - ADC"]
        ADC,
        #[doc = "50 - WDT"]
        WDT,
        #[doc = "51 - BOD"]
        BOD,
        #[doc = "53 - PIO_3"]
        PIO_3,
        #[doc = "54 - PIO_2"]
        PIO_2,
        #[doc = "55 - PIO_1"]
        PIO_1,
        #[doc = "56 - PIO_0"]
        PIO_0,
        #[doc = "57 - SSP1"]
        SSP1,
    }
    unsafe impl Nr for Interrupt {
        #[inline]
        fn nr(&self) -> u8 {
            match *self {
                Interrupt::PIO0_0 => 0,
                Interrupt::PIO0_1 => 1,
                Interrupt::PIO0_2 => 2,
                Interrupt::PIO0_3 => 3,
                Interrupt::PIO0_4 => 4,
                Interrupt::PIO0_5 => 5,
                Interrupt::PIO0_6 => 6,
                Interrupt::PIO0_7 => 7,
                Interrupt::PIO0_8 => 8,
                Interrupt::PIO0_9 => 9,
                Interrupt::PIO0_10 => 10,
                Interrupt::PIO0_11 => 11,
                Interrupt::PIO1_0 => 12,
                Interrupt::PIO1_1 => 13,
                Interrupt::PIO1_2 => 14,
                Interrupt::PIO1_3 => 15,
                Interrupt::PIO1_4 => 16,
                Interrupt::PIO1_5 => 17,
                Interrupt::PIO1_6 => 18,
                Interrupt::PIO1_7 => 19,
                Interrupt::PIO1_8 => 20,
                Interrupt::PIO1_9 => 21,
                Interrupt::PIO1_10 => 22,
                Interrupt::PIO1_11 => 23,
                Interrupt::PIO2_0 => 24,
                Interrupt::PIO2_1 => 25,
                Interrupt::PIO2_2 => 26,
                Interrupt::PIO2_3 => 27,
                Interrupt::PIO2_4 => 28,
                Interrupt::PIO2_5 => 29,
                Interrupt::PIO2_6 => 30,
                Interrupt::PIO2_7 => 31,
                Interrupt::PIO2_8 => 32,
                Interrupt::PIO2_9 => 33,
                Interrupt::PIO2_10 => 34,
                Interrupt::PIO2_11 => 35,
                Interrupt::PIO3_0 => 36,
                Interrupt::PIO3_1 => 37,
                Interrupt::PIO3_2 => 38,
                Interrupt::PIO3_3 => 39,
                Interrupt::I2C0 => 40,
                Interrupt::CT16B0 => 41,
                Interrupt::CT16B1 => 42,
                Interrupt::CT32B0 => 43,
                Interrupt::CT32B1 => 44,
                Interrupt::SSP0 => 45,
                Interrupt::UART => 46,
                Interrupt::USBIRQ => 47,
                Interrupt::USBFIQ => 48,
                Interrupt::ADC => 49,
                Interrupt::WDT => 50,
                Interrupt::BOD => 51,
                Interrupt::PIO_3 => 53,
                Interrupt::PIO_2 => 54,
                Interrupt::PIO_1 => 55,
                Interrupt::PIO_0 => 56,
                Interrupt::SSP1 => 57,
            }
        }
    }
    use core::convert::TryFrom;
    #[derive(Debug, Copy, Clone)]
    pub struct TryFromInterruptError(());
    impl TryFrom<u8> for Interrupt {
        type Error = TryFromInterruptError;
        #[inline]
        fn try_from(value: u8) -> Result<Self, Self::Error> {
            match value {
                0 => Ok(Interrupt::PIO0_0),
                1 => Ok(Interrupt::PIO0_1),
                2 => Ok(Interrupt::PIO0_2),
                3 => Ok(Interrupt::PIO0_3),
                4 => Ok(Interrupt::PIO0_4),
                5 => Ok(Interrupt::PIO0_5),
                6 => Ok(Interrupt::PIO0_6),
                7 => Ok(Interrupt::PIO0_7),
                8 => Ok(Interrupt::PIO0_8),
                9 => Ok(Interrupt::PIO0_9),
                10 => Ok(Interrupt::PIO0_10),
                11 => Ok(Interrupt::PIO0_11),
                12 => Ok(Interrupt::PIO1_0),
                13 => Ok(Interrupt::PIO1_1),
                14 => Ok(Interrupt::PIO1_2),
                15 => Ok(Interrupt::PIO1_3),
                16 => Ok(Interrupt::PIO1_4),
                17 => Ok(Interrupt::PIO1_5),
                18 => Ok(Interrupt::PIO1_6),
                19 => Ok(Interrupt::PIO1_7),
                20 => Ok(Interrupt::PIO1_8),
                21 => Ok(Interrupt::PIO1_9),
                22 => Ok(Interrupt::PIO1_10),
                23 => Ok(Interrupt::PIO1_11),
                24 => Ok(Interrupt::PIO2_0),
                25 => Ok(Interrupt::PIO2_1),
                26 => Ok(Interrupt::PIO2_2),
                27 => Ok(Interrupt::PIO2_3),
                28 => Ok(Interrupt::PIO2_4),
                29 => Ok(Interrupt::PIO2_5),
                30 => Ok(Interrupt::PIO2_6),
                31 => Ok(Interrupt::PIO2_7),
                32 => Ok(Interrupt::PIO2_8),
                33 => Ok(Interrupt::PIO2_9),
                34 => Ok(Interrupt::PIO2_10),
                35 => Ok(Interrupt::PIO2_11),
                36 => Ok(Interrupt::PIO3_0),
                37 => Ok(Interrupt::PIO3_1),
                38 => Ok(Interrupt::PIO3_2),
                39 => Ok(Interrupt::PIO3_3),
                40 => Ok(Interrupt::I2C0),
                41 => Ok(Interrupt::CT16B0),
                42 => Ok(Interrupt::CT16B1),
                43 => Ok(Interrupt::CT32B0),
                44 => Ok(Interrupt::CT32B1),
                45 => Ok(Interrupt::SSP0),
                46 => Ok(Interrupt::UART),
                47 => Ok(Interrupt::USBIRQ),
                48 => Ok(Interrupt::USBFIQ),
                49 => Ok(Interrupt::ADC),
                50 => Ok(Interrupt::WDT),
                51 => Ok(Interrupt::BOD),
                53 => Ok(Interrupt::PIO_3),
                54 => Ok(Interrupt::PIO_2),
                55 => Ok(Interrupt::PIO_1),
                56 => Ok(Interrupt::PIO_0),
                57 => Ok(Interrupt::SSP1),
                _ => Err(TryFromInterruptError(())),
            }
        }
    }
    #[cfg(feature = "rt")]
    #[macro_export]
    macro_rules ! interrupt { ( $ NAME : ident , $ path : path , locals : { $ ( $ lvar : ident : $ lty : ty = $ lval : expr ; ) * } ) => { # [ allow ( non_snake_case ) ] mod $ NAME { pub struct Locals { $ ( pub $ lvar : $ lty , ) * } } # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; static mut LOCALS : self :: $ NAME :: Locals = self :: $ NAME :: Locals { $ ( $ lvar : $ lval , ) * } ; let f : fn ( & mut self :: $ NAME :: Locals ) = $ path ; f ( unsafe { & mut LOCALS } ) ; } } ; ( $ NAME : ident , $ path : path ) => { # [ allow ( non_snake_case ) ] # [ no_mangle ] pub extern "C" fn $ NAME ( ) { let _ = $ crate :: interrupt :: Interrupt :: $ NAME ; let f : fn ( ) = $ path ; f ( ) ; } } }
}
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::CPUID;
pub use cortex_m::peripheral::DCB;
pub use cortex_m::peripheral::DWT;
pub use cortex_m::peripheral::MPU;
pub use cortex_m::peripheral::NVIC;
pub use cortex_m::peripheral::SCB;
pub use cortex_m::peripheral::SYST;
#[doc = "Product name title=UM10375 Chapter title=LPC13xx I2C-bus controller Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct I2C {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C {}
impl I2C {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const i2c::RegisterBlock {
        0x4000_0000 as *const _
    }
}
impl Deref for I2C {
    type Target = i2c::RegisterBlock;
    fn deref(&self) -> &i2c::RegisterBlock {
        unsafe { &*I2C::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx I2C-bus controller Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod i2c {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register."]
        pub conset: CONSET,
        #[doc = "0x04 - I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed."]
        pub stat: STAT,
        #[doc = "0x08 - I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register."]
        pub dat: DAT,
        #[doc = "0x0c - I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
        pub adr0: ADR0,
        #[doc = "0x10 - SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock."]
        pub sclh: SCLH,
        #[doc = "0x14 - SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode."]
        pub scll: SCLL,
        #[doc = "0x18 - I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register."]
        pub conclr: CONCLR,
        #[doc = "0x1c - Monitor mode control register."]
        pub mmctrl: MMCTRL,
        #[doc = "0x20 - I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
        pub adr1: ADR,
        #[doc = "0x24 - I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
        pub adr2: ADR,
        #[doc = "0x28 - I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
        pub adr3: ADR,
        #[doc = "0x2c - Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus."]
        pub data_buffer: DATA_BUFFER,
        #[doc = "0x30 - I2C Slave address mask register n. This mask register is associated with I2ADRn to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)."]
        pub mask: [MASK; 4],
    }
    #[doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register."]
    pub struct CONSET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Control Set Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is set. Writing a zero has no effect on the corresponding bit in the I2C control register."]
    pub mod conset {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONSET {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct AAR {
            bits: bool,
        }
        impl AAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIR {
            bits: bool,
        }
        impl SIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOR {
            bits: bool,
        }
        impl STOR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct STAR {
            bits: bool,
        }
        impl STAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct I2ENR {
            bits: bool,
        }
        impl I2ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _AAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SIW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SIW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STAW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - Assert acknowledge flag."]
            #[inline]
            pub fn aa(&self) -> AAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                AAR { bits }
            }
            #[doc = "Bit 3 - I2C interrupt flag."]
            #[inline]
            pub fn si(&self) -> SIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIR { bits }
            }
            #[doc = "Bit 4 - STOP flag."]
            #[inline]
            pub fn sto(&self) -> STOR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STOR { bits }
            }
            #[doc = "Bit 5 - START flag."]
            #[inline]
            pub fn sta(&self) -> STAR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                STAR { bits }
            }
            #[doc = "Bit 6 - I2C interface enable."]
            #[inline]
            pub fn i2en(&self) -> I2ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                I2ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Assert acknowledge flag."]
            #[inline]
            pub fn aa(&mut self) -> _AAW {
                _AAW { w: self }
            }
            #[doc = "Bit 3 - I2C interrupt flag."]
            #[inline]
            pub fn si(&mut self) -> _SIW {
                _SIW { w: self }
            }
            #[doc = "Bit 4 - STOP flag."]
            #[inline]
            pub fn sto(&mut self) -> _STOW {
                _STOW { w: self }
            }
            #[doc = "Bit 5 - START flag."]
            #[inline]
            pub fn sta(&mut self) -> _STAW {
                _STAW { w: self }
            }
            #[doc = "Bit 6 - I2C interface enable."]
            #[inline]
            pub fn i2en(&mut self) -> _I2ENW {
                _I2ENW { w: self }
            }
        }
    }
    #[doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed."]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Status Register. During I2C operation, this register provides detailed status codes that allow software to determine the next action needed."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct STATUSR {
            bits: u8,
        }
        impl STATUSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 3:7 - These bits give the actual status information about the I 2C interface."]
            #[inline]
            pub fn status(&self) -> STATUSR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                STATUSR { bits }
            }
        }
    }
    #[doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register."]
    pub struct DAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Data Register. During master or slave transmit mode, data to be transmitted is written to this register. During master or slave receive mode, data that has been received may be read from this register."]
    pub mod dat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DAT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - This register holds data values that have been received or are to be transmitted."]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
    pub struct ADR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Slave Address Register 0. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
    pub mod adr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCR {
            bits: bool,
        }
        impl GCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u8,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - General Call enable bit."]
            #[inline]
            pub fn gc(&self) -> GCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCR { bits }
            }
            #[doc = "Bits 1:7 - The I2C device address for slave mode."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - General Call enable bit."]
            #[inline]
            pub fn gc(&mut self) -> _GCW {
                _GCW { w: self }
            }
            #[doc = "Bits 1:7 - The I2C device address for slave mode."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
        }
    }
    #[doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock."]
    pub struct SCLH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCH Duty Cycle Register High Half Word. Determines the high time of the I2C clock."]
    pub mod sclh {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCLH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCLHR {
            bits: u16,
        }
        impl SCLHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Count for SCL HIGH time period selection."]
            #[inline]
            pub fn sclh(&self) -> SCLHR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                SCLHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x04 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Count for SCL HIGH time period selection."]
            #[inline]
            pub fn sclh(&mut self) -> _SCLHW {
                _SCLHW { w: self }
            }
        }
    }
    #[doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode."]
    pub struct SCLL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCL Duty Cycle Register Low Half Word. Determines the low time of the I2C clock. I2nSCLL and I2nSCLH together determine the clock frequency generated by an I2C master and certain times used in slave mode."]
    pub mod scll {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCLL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCLLR {
            bits: u16,
        }
        impl SCLLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCLLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCLLW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Count for SCL low time period selection."]
            #[inline]
            pub fn scll(&self) -> SCLLR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                SCLLR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x04 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Count for SCL low time period selection."]
            #[inline]
            pub fn scll(&mut self) -> _SCLLW {
                _SCLLW { w: self }
            }
        }
    }
    #[doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register."]
    pub struct CONCLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Control Clear Register. When a one is written to a bit of this register, the corresponding bit in the I2C control register is cleared. Writing a zero has no effect on the corresponding bit in the I2C control register."]
    pub mod conclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CONCLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _AACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SICW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SICW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _STACW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STACW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2ENCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2ENCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Assert acknowledge Clear bit."]
            #[inline]
            pub fn aac(&mut self) -> _AACW {
                _AACW { w: self }
            }
            #[doc = "Bit 3 - I2C interrupt Clear bit."]
            #[inline]
            pub fn sic(&mut self) -> _SICW {
                _SICW { w: self }
            }
            #[doc = "Bit 5 - START flag Clear bit."]
            #[inline]
            pub fn stac(&mut self) -> _STACW {
                _STACW { w: self }
            }
            #[doc = "Bit 6 - I2C interface Disable bit."]
            #[inline]
            pub fn i2enc(&mut self) -> _I2ENCW {
                _I2ENCW { w: self }
            }
        }
    }
    #[doc = "Monitor mode control register."]
    pub struct MMCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Monitor mode control register."]
    pub mod mmctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MMCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MM_ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MM_ENAR {
            #[doc = "Monitor mode disabled."]
            DISABLED,
            #[doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line."]
            ENABLED,
        }
        impl MM_ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MM_ENAR::DISABLED => false,
                    MM_ENAR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MM_ENAR {
                match value {
                    false => MM_ENAR::DISABLED,
                    true => MM_ENAR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MM_ENAR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MM_ENAR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ENA_SCL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENA_SCLR {
            #[doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line."]
            HIGH,
            #[doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]"]
            NORMAL,
        }
        impl ENA_SCLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENA_SCLR::HIGH => false,
                    ENA_SCLR::NORMAL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENA_SCLR {
                match value {
                    false => ENA_SCLR::HIGH,
                    true => ENA_SCLR::NORMAL,
                }
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == ENA_SCLR::HIGH
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline]
            pub fn is_normal(&self) -> bool {
                *self == ENA_SCLR::NORMAL
            }
        }
        #[doc = "Possible values of the field `MATCH_ALL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MATCH_ALLR {
            #[doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned."]
            MATCH,
            #[doc = "When this bit is set to 1 and the I 2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus."]
            ANYINT,
        }
        impl MATCH_ALLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MATCH_ALLR::MATCH => false,
                    MATCH_ALLR::ANYINT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MATCH_ALLR {
                match value {
                    false => MATCH_ALLR::MATCH,
                    true => MATCH_ALLR::ANYINT,
                }
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline]
            pub fn is_match_(&self) -> bool {
                *self == MATCH_ALLR::MATCH
            }
            #[doc = "Checks if the value of the field is `ANYINT`"]
            #[inline]
            pub fn is_anyint(&self) -> bool {
                *self == MATCH_ALLR::ANYINT
            }
        }
        #[doc = "Values that can be written to the field `MM_ENA`"]
        pub enum MM_ENAW {
            #[doc = "Monitor mode disabled."]
            DISABLED,
            #[doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line."]
            ENABLED,
        }
        impl MM_ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MM_ENAW::DISABLED => false,
                    MM_ENAW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MM_ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MM_ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MM_ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Monitor mode disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MM_ENAW::DISABLED)
            }
            #[doc = "The I 2C module will enter monitor mode. In this mode the SDA output will be forced high. This will prevent the I2C module from outputting data of any kind (including ACK) onto the I2C data bus. Depending on the state of the ENA_SCL bit, the output may be also forced high, preventing the module from having control over the I2C clock line."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MM_ENAW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ENA_SCL`"]
        pub enum ENA_SCLW {
            #[doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line."]
            HIGH,
            #[doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]"]
            NORMAL,
        }
        impl ENA_SCLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENA_SCLW::HIGH => false,
                    ENA_SCLW::NORMAL => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENA_SCLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENA_SCLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENA_SCLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "When this bit is cleared to 0, the SCL output will be forced high when the module is in monitor mode. As described above, this will prevent the module from having any control over the I2C clock line."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(ENA_SCLW::HIGH)
            }
            #[doc = "When this bit is set, the I2C module may exercise the same control over the clock line that it would in normal operation. This means that, acting as a slave peripheral, the I2C module can stretch the clock line (hold it low) until it has had time to respond to an I2C interrupt.[1]"]
            #[inline]
            pub fn normal(self) -> &'a mut W {
                self.variant(ENA_SCLW::NORMAL)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MATCH_ALL`"]
        pub enum MATCH_ALLW {
            #[doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above.   That is, the module will respond as a normal slave as far as address-recognition is concerned."]
            MATCH,
            #[doc = "When this bit is set to 1 and the I 2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus."]
            ANYINT,
        }
        impl MATCH_ALLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MATCH_ALLW::MATCH => false,
                    MATCH_ALLW::ANYINT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCH_ALLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCH_ALLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MATCH_ALLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "When this bit is cleared, an interrupt will only be generated when a match occurs to one of the (up-to) four address registers described above. That is, the module will respond as a normal slave as far as address-recognition is concerned."]
            #[inline]
            pub fn match_(self) -> &'a mut W {
                self.variant(MATCH_ALLW::MATCH)
            }
            #[doc = "When this bit is set to 1 and the I 2C is in monitor mode, an interrupt will be generated on ANY address received. This will enable the part to monitor all traffic on the bus."]
            #[inline]
            pub fn anyint(self) -> &'a mut W {
                self.variant(MATCH_ALLW::ANYINT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Monitor mode enable."]
            #[inline]
            pub fn mm_ena(&self) -> MM_ENAR {
                MM_ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SCL output enable."]
            #[inline]
            pub fn ena_scl(&self) -> ENA_SCLR {
                ENA_SCLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Select interrupt register match."]
            #[inline]
            pub fn match_all(&self) -> MATCH_ALLR {
                MATCH_ALLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Monitor mode enable."]
            #[inline]
            pub fn mm_ena(&mut self) -> _MM_ENAW {
                _MM_ENAW { w: self }
            }
            #[doc = "Bit 1 - SCL output enable."]
            #[inline]
            pub fn ena_scl(&mut self) -> _ENA_SCLW {
                _ENA_SCLW { w: self }
            }
            #[doc = "Bit 2 - Select interrupt register match."]
            #[inline]
            pub fn match_all(&mut self) -> _MATCH_ALLW {
                _MATCH_ALLW { w: self }
            }
        }
    }
    #[doc = "I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
    pub struct ADR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Slave Address Register 1. Contains the 7-bit slave address for operation of the I2C interface in slave mode, and is not used in master mode. The least significant bit determines whether a slave responds to the General Call address."]
    pub mod adr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ADR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GCR {
            bits: bool,
        }
        impl GCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADDRESSR {
            bits: u8,
        }
        impl ADDRESSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GCW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADDRESSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADDRESSW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - General Call enable bit."]
            #[inline]
            pub fn gc(&self) -> GCR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                GCR { bits }
            }
            #[doc = "Bits 1:7 - The I2C device address for slave mode."]
            #[inline]
            pub fn address(&self) -> ADDRESSR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADDRESSR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - General Call enable bit."]
            #[inline]
            pub fn gc(&mut self) -> _GCW {
                _GCW { w: self }
            }
            #[doc = "Bits 1:7 - The I2C device address for slave mode."]
            #[inline]
            pub fn address(&mut self) -> _ADDRESSW {
                _ADDRESSW { w: self }
            }
        }
    }
    #[doc = "Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus."]
    pub struct DATA_BUFFER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data buffer register. The contents of the 8 MSBs of the I2DAT shift register will be transferred to the DATA_BUFFER automatically after every nine bits (8 bits of data plus ACK or NACK) has been received on the bus."]
    pub mod data_buffer {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DATA_BUFFER {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u8,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - This register holds contents of the 8 MSBs of the I2DAT shift register."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DATAR { bits }
            }
        }
    }
    #[doc = "I2C Slave address mask register n. This mask register is associated with I2ADRn to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)."]
    pub struct MASK {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I2C Slave address mask register n. This mask register is associated with I2ADRn to determine an address match. The mask register has no effect when comparing to the General Call address (0000000)."]
    pub mod mask {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MASK {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASKR {
            bits: u8,
        }
        impl MASKR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASKW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASKW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x7f;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 1:7 - Mask bits."]
            #[inline]
            pub fn mask(&self) -> MASKR {
                let bits = {
                    const MASK: u8 = 0x7f;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MASKR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 1:7 - Mask bits."]
            #[inline]
            pub fn mask(&mut self) -> _MASKW {
                _MASKW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Windowed WatchDog Timer (WWDT) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct WWDT {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDT {}
impl WWDT {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const wwdt::RegisterBlock {
        0x4000_4000 as *const _
    }
}
impl Deref for WWDT {
    type Target = wwdt::RegisterBlock;
    fn deref(&self) -> &wwdt::RegisterBlock {
        unsafe { &*WWDT::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Windowed WatchDog Timer (WWDT) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod wwdt {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
        pub mod_: MOD,
        #[doc = "0x04 - Watchdog timer constant register. This register determines the time-out value."]
        pub tc: TC,
        #[doc = "0x08 - Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
        pub feed: FEED,
        #[doc = "0x0c - Watchdog timer value register. This register reads out the current value of the Watchdog timer."]
        pub tv: TV,
        _reserved0: [u8; 4usize],
        #[doc = "0x14 - Watchdog Warning Interrupt compare value."]
        pub warnint: WARNINT,
        #[doc = "0x18 - Watchdog Window compare value."]
        pub window: WINDOW,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub struct MOD {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog mode register. This register contains the basic mode and status of the Watchdog Timer."]
    pub mod mod_ {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MOD {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDENR {
            #[doc = "The watchdog timer is stopped."]
            STOP,
            #[doc = "The watchdog timer is running."]
            RUN,
        }
        impl WDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDENR::STOP => false,
                    WDENR::RUN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDENR {
                match value {
                    false => WDENR::STOP,
                    true => WDENR::RUN,
                }
            }
            #[doc = "Checks if the value of the field is `STOP`"]
            #[inline]
            pub fn is_stop(&self) -> bool {
                *self == WDENR::STOP
            }
            #[doc = "Checks if the value of the field is `RUN`"]
            #[inline]
            pub fn is_run(&self) -> bool {
                *self == WDENR::RUN
            }
        }
        #[doc = "Possible values of the field `WDRESET`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDRESETR {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            RESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            INTERRUPT,
        }
        impl WDRESETR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDRESETR::RESET => false,
                    WDRESETR::INTERRUPT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDRESETR {
                match value {
                    false => WDRESETR::RESET,
                    true => WDRESETR::INTERRUPT,
                }
            }
            #[doc = "Checks if the value of the field is `RESET`"]
            #[inline]
            pub fn is_reset(&self) -> bool {
                *self == WDRESETR::RESET
            }
            #[doc = "Checks if the value of the field is `INTERRUPT`"]
            #[inline]
            pub fn is_interrupt(&self) -> bool {
                *self == WDRESETR::INTERRUPT
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDTOFR {
            bits: bool,
        }
        impl WDTOFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct WDINTR {
            bits: bool,
        }
        impl WDINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `WDPROTECT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDPROTECTR {
            #[doc = "The watchdog reload value (WDTC) can be changed at any time."]
            ANYTIME,
            #[doc = "The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1."]
            MATCH,
        }
        impl WDPROTECTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDPROTECTR::ANYTIME => false,
                    WDPROTECTR::MATCH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDPROTECTR {
                match value {
                    false => WDPROTECTR::ANYTIME,
                    true => WDPROTECTR::MATCH,
                }
            }
            #[doc = "Checks if the value of the field is `ANYTIME`"]
            #[inline]
            pub fn is_anytime(&self) -> bool {
                *self == WDPROTECTR::ANYTIME
            }
            #[doc = "Checks if the value of the field is `MATCH`"]
            #[inline]
            pub fn is_match_(&self) -> bool {
                *self == WDPROTECTR::MATCH
            }
        }
        #[doc = "Values that can be written to the field `WDEN`"]
        pub enum WDENW {
            #[doc = "The watchdog timer is stopped."]
            STOP,
            #[doc = "The watchdog timer is running."]
            RUN,
        }
        impl WDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDENW::STOP => false,
                    WDENW::RUN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog timer is stopped."]
            #[inline]
            pub fn stop(self) -> &'a mut W {
                self.variant(WDENW::STOP)
            }
            #[doc = "The watchdog timer is running."]
            #[inline]
            pub fn run(self) -> &'a mut W {
                self.variant(WDENW::RUN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDRESET`"]
        pub enum WDRESETW {
            #[doc = "A watchdog timeout will not cause a chip reset."]
            RESET,
            #[doc = "A watchdog timeout will cause a chip reset."]
            INTERRUPT,
        }
        impl WDRESETW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDRESETW::RESET => false,
                    WDRESETW::INTERRUPT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDRESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDRESETW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDRESETW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "A watchdog timeout will not cause a chip reset."]
            #[inline]
            pub fn reset(self) -> &'a mut W {
                self.variant(WDRESETW::RESET)
            }
            #[doc = "A watchdog timeout will cause a chip reset."]
            #[inline]
            pub fn interrupt(self) -> &'a mut W {
                self.variant(WDRESETW::INTERRUPT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOFW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDINTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDPROTECT`"]
        pub enum WDPROTECTW {
            #[doc = "The watchdog reload value (WDTC) can be changed at any time."]
            ANYTIME,
            #[doc = "The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1."]
            MATCH,
        }
        impl WDPROTECTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDPROTECTW::ANYTIME => false,
                    WDPROTECTW::MATCH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDPROTECTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDPROTECTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDPROTECTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The watchdog reload value (WDTC) can be changed at any time."]
            #[inline]
            pub fn anytime(self) -> &'a mut W {
                self.variant(WDPROTECTW::ANYTIME)
            }
            #[doc = "The watchdog reload value (WDTC) can be changed only after the counter is below the value of WDWARNINT and WDWINDOW. Note: this mode is intended for use only when WDRESET =1."]
            #[inline]
            pub fn match_(self) -> &'a mut W {
                self.variant(WDPROTECTW::MATCH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Watchdog enable bit. This bit is Set Only. Remark: Setting this bit to one also locks the watchdog clock source. Once the watchdog timer is enabled, the watchdog timer clock source cannot be changed. If the watchdog timer is needed in Deep-sleep mode, the watchdog clock source must be changed to watchdog oscillator before setting this bit to one."]
            #[inline]
            pub fn wden(&self) -> WDENR {
                WDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. This bit is Set Only."]
            #[inline]
            pub fn wdreset(&self) -> WDRESETR {
                WDRESETR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT, cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline]
            pub fn wdtof(&self) -> WDTOFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDTOFR { bits }
            }
            #[doc = "Bit 3 - Watchdog interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline]
            pub fn wdint(&self) -> WDINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                WDINTR { bits }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit is Set Only."]
            #[inline]
            pub fn wdprotect(&self) -> WDPROTECTR {
                WDPROTECTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Watchdog enable bit. This bit is Set Only. Remark: Setting this bit to one also locks the watchdog clock source. Once the watchdog timer is enabled, the watchdog timer clock source cannot be changed. If the watchdog timer is needed in Deep-sleep mode, the watchdog clock source must be changed to watchdog oscillator before setting this bit to one."]
            #[inline]
            pub fn wden(&mut self) -> _WDENW {
                _WDENW { w: self }
            }
            #[doc = "Bit 1 - Watchdog reset enable bit. This bit is Set Only."]
            #[inline]
            pub fn wdreset(&mut self) -> _WDRESETW {
                _WDRESETW { w: self }
            }
            #[doc = "Bit 2 - Watchdog time-out flag. Set when the watchdog timer times out, by a feed error, or by events associated with WDPROTECT, cleared by software. Causes a chip reset if WDRESET = 1."]
            #[inline]
            pub fn wdtof(&mut self) -> _WDTOFW {
                _WDTOFW { w: self }
            }
            #[doc = "Bit 3 - Watchdog interrupt flag. Set when the timer reaches the value in WDWARNINT. Cleared by software."]
            #[inline]
            pub fn wdint(&mut self) -> _WDINTW {
                _WDINTW { w: self }
            }
            #[doc = "Bit 4 - Watchdog update mode. This bit is Set Only."]
            #[inline]
            pub fn wdprotect(&mut self) -> _WDPROTECTW {
                _WDPROTECTW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer constant register. This register determines the time-out value."]
    pub struct TC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog timer constant register. This register determines the time-out value."]
    pub mod tc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _COUNTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _COUNTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog time-out interval."]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog time-out interval."]
            #[inline]
            pub fn count(&mut self) -> _COUNTW {
                _COUNTW { w: self }
            }
        }
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub struct FEED {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog feed sequence register. Writing 0xAA followed by 0x55 to this register reloads the Watchdog timer with the value contained in WDTC."]
    pub mod feed {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FEED {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FEEDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FEEDW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Feed value should be 0xAA followed by 0x55."]
            #[inline]
            pub fn feed(&mut self) -> _FEEDW {
                _FEEDW { w: self }
            }
        }
    }
    #[doc = "Watchdog timer value register. This register reads out the current value of the Watchdog timer."]
    pub struct TV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog timer value register. This register reads out the current value of the Watchdog timer."]
    pub mod tv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::TV {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct COUNTR {
            bits: u32,
        }
        impl COUNTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Counter timer value."]
            #[inline]
            pub fn count(&self) -> COUNTR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                COUNTR { bits }
            }
        }
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub struct WARNINT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog Warning Interrupt compare value."]
    pub mod warnint {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WARNINT {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WARNINTR {
            bits: u16,
        }
        impl WARNINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WARNINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WARNINTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline]
            pub fn warnint(&self) -> WARNINTR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                WARNINTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - Watchdog warning interrupt compare value."]
            #[inline]
            pub fn warnint(&mut self) -> _WARNINTW {
                _WARNINTW { w: self }
            }
        }
    }
    #[doc = "Watchdog Window compare value."]
    pub struct WINDOW {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog Window compare value."]
    pub mod window {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WINDOW {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct WINDOWR {
            bits: u32,
        }
        impl WINDOWR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _WINDOWW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WINDOWW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x00ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline]
            pub fn window(&self) -> WINDOWR {
                let bits = {
                    const MASK: u32 = 0x00ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                WINDOWR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x00ff_ffff }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:23 - Watchdog window value."]
            #[inline]
            pub fn window(&mut self) -> _WINDOWW {
                _WINDOWW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx UART Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct UART {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART {}
impl UART {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const uart::RegisterBlock {
        0x4000_8000 as *const _
    }
}
impl Deref for UART {
    type Target = uart::RegisterBlock;
    fn deref(&self) -> &uart::RegisterBlock {
        unsafe { &*UART::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx UART Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod uart {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Receiver Buffer Register. Contains the next received character to be read. When DLAB=0."]
        pub rbr: RBR,
        #[doc = "0x04 - Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. When DLAB=1."]
        pub dlm: DLM,
        #[doc = "0x08 - Interrupt ID Register. Identifies which interrupt(s) are pending."]
        pub iir: IIR,
        #[doc = "0x0c - Line Control Register. Contains controls for frame formatting and break generation."]
        pub lcr: LCR,
        #[doc = "0x10 - Modem control register"]
        pub mcr: MCR,
        #[doc = "0x14 - Line Status Register. Contains flags for transmit and receive status, including line errors."]
        pub lsr: LSR,
        #[doc = "0x18 - Modem status register"]
        pub msr: MSR,
        #[doc = "0x1c - Scratch Pad Register. Eight-bit temporary storage for software."]
        pub scr: SCR,
        #[doc = "0x20 - Auto-baud Control Register. Contains controls for the auto-baud feature."]
        pub acr: ACR,
        _reserved0: [u8; 4usize],
        #[doc = "0x28 - Fractional Divider Register. Generates a clock input for the baud rate divider."]
        pub fdr: FDR,
        _reserved1: [u8; 4usize],
        #[doc = "0x30 - Transmit Enable Register. Turns off UART transmitter for use with software flow control."]
        pub ter: TER,
        _reserved2: [u8; 24usize],
        #[doc = "0x4c - RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes."]
        pub rs485ctrl: RS485CTRL,
        #[doc = "0x50 - RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode."]
        pub rs485adrmatch: RS485ADRMATCH,
        #[doc = "0x54 - RS-485/EIA-485 direction control delay."]
        pub rs485dly: RS485DLY,
    }
    #[doc = "Receiver Buffer Register. Contains the next received character to be read. When DLAB=0."]
    pub struct RBR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Receiver Buffer Register. Contains the next received character to be read. When DLAB=0."]
    pub mod rbr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RBR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RBRR {
            bits: u8,
        }
        impl RBRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - The UART Receiver Buffer Register contains the oldest received byte in the UART RX FIFO."]
            #[inline]
            pub fn rbr(&self) -> RBRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                RBRR { bits }
            }
        }
    }
    #[doc = "Transmit Holding Register. The next character to be transmitted is written here. When DLAB=0."]
    pub struct THR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Holding Register. The next character to be transmitted is written here. When DLAB=0."]
    pub mod thr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::THR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _THRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Writing to the UART Transmit Holding Register causes the data to be stored in the UART transmit FIFO. The byte will be sent when it reaches the bottom of the FIFO and the transmitter is available."]
            #[inline]
            pub fn thr(&mut self) -> _THRW {
                _THRW { w: self }
            }
        }
    }
    #[doc = "Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. When DLAB=1."]
    pub struct DLL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Divisor Latch LSB. Least significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. When DLAB=1."]
    pub mod dll {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DLLSBR {
            bits: u8,
        }
        impl DLLSBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DLLSBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DLLSBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - The UART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the UART."]
            #[inline]
            pub fn dllsb(&self) -> DLLSBR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DLLSBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - The UART Divisor Latch LSB Register, along with the DLM register, determines the baud rate of the UART."]
            #[inline]
            pub fn dllsb(&mut self) -> _DLLSBW {
                _DLLSBW { w: self }
            }
        }
    }
    #[doc = "Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. When DLAB=1."]
    pub struct DLM {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Divisor Latch MSB. Most significant byte of the baud rate divisor value. The full divisor is used to generate a baud rate from the fractional rate divider. When DLAB=1."]
    pub mod dlm {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DLM {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DLMSBR {
            bits: u8,
        }
        impl DLMSBR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DLMSBW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DLMSBW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - The UART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the UART."]
            #[inline]
            pub fn dlmsb(&self) -> DLMSBR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DLMSBR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - The UART Divisor Latch MSB Register, along with the DLL register, determines the baud rate of the UART."]
            #[inline]
            pub fn dlmsb(&mut self) -> _DLMSBW {
                _DLMSBW { w: self }
            }
        }
    }
    #[doc = "Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. When DLAB=0."]
    pub struct IER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Enable Register. Contains individual interrupt enable bits for the 7 potential UART interrupts. When DLAB=0."]
    pub mod ier {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RBRIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RBRIER {
            #[doc = "Disable the RDA interrupt."]
            DISABLE,
            #[doc = "Enable the RDA interrupt."]
            ENABLE,
        }
        impl RBRIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RBRIER::DISABLE => false,
                    RBRIER::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RBRIER {
                match value {
                    false => RBRIER::DISABLE,
                    true => RBRIER::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == RBRIER::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == RBRIER::ENABLE
            }
        }
        #[doc = "Possible values of the field `THREIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum THREIER {
            #[doc = "Disable the THRE interrupt."]
            DISABLE,
            #[doc = "Enable the THRE interrupt."]
            ENABLE,
        }
        impl THREIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    THREIER::DISABLE => false,
                    THREIER::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> THREIER {
                match value {
                    false => THREIER::DISABLE,
                    true => THREIER::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == THREIER::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == THREIER::ENABLE
            }
        }
        #[doc = "Possible values of the field `RXLIE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXLIER {
            #[doc = "Disable the RX line status\r\ninterrupts."]
            DISABLE,
            #[doc = "Enable\r\nthe RX line status interrupts."]
            ENABLE,
        }
        impl RXLIER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXLIER::DISABLE => false,
                    RXLIER::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXLIER {
                match value {
                    false => RXLIER::DISABLE,
                    true => RXLIER::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == RXLIER::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == RXLIER::ENABLE
            }
        }
        #[doc = "Possible values of the field `ABEOINTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABEOINTENR {
            #[doc = "Disable end of auto-baud\r\nInterrupt."]
            DISABLE,
            #[doc = "Enable\r\nend of auto-baud Interrupt."]
            ENABLE,
        }
        impl ABEOINTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ABEOINTENR::DISABLE => false,
                    ABEOINTENR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ABEOINTENR {
                match value {
                    false => ABEOINTENR::DISABLE,
                    true => ABEOINTENR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ABEOINTENR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ABEOINTENR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ABTOINTEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABTOINTENR {
            #[doc = "Disable auto-baud time-out\r\nInterrupt."]
            DISABLE,
            #[doc = "Enable\r\nauto-baud time-out Interrupt."]
            ENABLE,
        }
        impl ABTOINTENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ABTOINTENR::DISABLE => false,
                    ABTOINTENR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ABTOINTENR {
                match value {
                    false => ABTOINTENR::DISABLE,
                    true => ABTOINTENR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == ABTOINTENR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == ABTOINTENR::ENABLE
            }
        }
        #[doc = "Values that can be written to the field `RBRIE`"]
        pub enum RBRIEW {
            #[doc = "Disable the RDA interrupt."]
            DISABLE,
            #[doc = "Enable the RDA interrupt."]
            ENABLE,
        }
        impl RBRIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RBRIEW::DISABLE => false,
                    RBRIEW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RBRIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RBRIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RBRIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable the RDA interrupt."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(RBRIEW::DISABLE)
            }
            #[doc = "Enable the RDA interrupt."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(RBRIEW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `THREIE`"]
        pub enum THREIEW {
            #[doc = "Disable the THRE interrupt."]
            DISABLE,
            #[doc = "Enable the THRE interrupt."]
            ENABLE,
        }
        impl THREIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    THREIEW::DISABLE => false,
                    THREIEW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _THREIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _THREIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: THREIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable the THRE interrupt."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(THREIEW::DISABLE)
            }
            #[doc = "Enable the THRE interrupt."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(THREIEW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXLIE`"]
        pub enum RXLIEW {
            #[doc = "Disable the RX line status\r\ninterrupts."]
            DISABLE,
            #[doc = "Enable\r\nthe RX line status interrupts."]
            ENABLE,
        }
        impl RXLIEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXLIEW::DISABLE => false,
                    RXLIEW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXLIEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXLIEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXLIEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable the RX line status interrupts."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(RXLIEW::DISABLE)
            }
            #[doc = "Enable the RX line status interrupts."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(RXLIEW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ABEOINTEN`"]
        pub enum ABEOINTENW {
            #[doc = "Disable end of auto-baud\r\nInterrupt."]
            DISABLE,
            #[doc = "Enable\r\nend of auto-baud Interrupt."]
            ENABLE,
        }
        impl ABEOINTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ABEOINTENW::DISABLE => false,
                    ABEOINTENW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABEOINTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABEOINTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ABEOINTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable end of auto-baud Interrupt."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ABEOINTENW::DISABLE)
            }
            #[doc = "Enable end of auto-baud Interrupt."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ABEOINTENW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ABTOINTEN`"]
        pub enum ABTOINTENW {
            #[doc = "Disable auto-baud time-out\r\nInterrupt."]
            DISABLE,
            #[doc = "Enable\r\nauto-baud time-out Interrupt."]
            ENABLE,
        }
        impl ABTOINTENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ABTOINTENW::DISABLE => false,
                    ABTOINTENW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABTOINTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABTOINTENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ABTOINTENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable auto-baud time-out Interrupt."]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(ABTOINTENW::DISABLE)
            }
            #[doc = "Enable auto-baud time-out Interrupt."]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(ABTOINTENW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt Enable. Enables the Receive Data Available interrupt for UART. It also controls the Character Receive Time-out interrupt."]
            #[inline]
            pub fn rbrie(&self) -> RBRIER {
                RBRIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Interrupt Enable. Enables the THRE interrupt for UART. The status of this interrupt can be read from LSR[5]."]
            #[inline]
            pub fn threie(&self) -> THREIER {
                THREIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Line Interrupt Enable. Enables the UART RX line status interrupts. The status of this interrupt can be read from LSR[4:1]."]
            #[inline]
            pub fn rxlie(&self) -> RXLIER {
                RXLIER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enables the end of auto-baud interrupt."]
            #[inline]
            pub fn abeointen(&self) -> ABEOINTENR {
                ABEOINTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enables the auto-baud time-out interrupt."]
            #[inline]
            pub fn abtointen(&self) -> ABTOINTENR {
                ABTOINTENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt Enable. Enables the Receive Data Available interrupt for UART. It also controls the Character Receive Time-out interrupt."]
            #[inline]
            pub fn rbrie(&mut self) -> _RBRIEW {
                _RBRIEW { w: self }
            }
            #[doc = "Bit 1 - Interrupt Enable. Enables the THRE interrupt for UART. The status of this interrupt can be read from LSR[5]."]
            #[inline]
            pub fn threie(&mut self) -> _THREIEW {
                _THREIEW { w: self }
            }
            #[doc = "Bit 2 - Line Interrupt Enable. Enables the UART RX line status interrupts. The status of this interrupt can be read from LSR[4:1]."]
            #[inline]
            pub fn rxlie(&mut self) -> _RXLIEW {
                _RXLIEW { w: self }
            }
            #[doc = "Bit 8 - Enables the end of auto-baud interrupt."]
            #[inline]
            pub fn abeointen(&mut self) -> _ABEOINTENW {
                _ABEOINTENW { w: self }
            }
            #[doc = "Bit 9 - Enables the auto-baud time-out interrupt."]
            #[inline]
            pub fn abtointen(&mut self) -> _ABTOINTENW {
                _ABTOINTENW { w: self }
            }
        }
    }
    #[doc = "Interrupt ID Register. Identifies which interrupt(s) are pending."]
    pub struct IIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt ID Register. Identifies which interrupt(s) are pending."]
    pub mod iir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::IIR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `INTSTATUS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTSTATUSR {
            #[doc = "At least one interrupt\r\nis pending."]
            INT,
            #[doc = "No\r\ninterrupt is pending."]
            NOINT,
        }
        impl INTSTATUSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    INTSTATUSR::INT => false,
                    INTSTATUSR::NOINT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> INTSTATUSR {
                match value {
                    false => INTSTATUSR::INT,
                    true => INTSTATUSR::NOINT,
                }
            }
            #[doc = "Checks if the value of the field is `INT`"]
            #[inline]
            pub fn is_int(&self) -> bool {
                *self == INTSTATUSR::INT
            }
            #[doc = "Checks if the value of the field is `NOINT`"]
            #[inline]
            pub fn is_noint(&self) -> bool {
                *self == INTSTATUSR::NOINT
            }
        }
        #[doc = "Possible values of the field `INTID`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum INTIDR {
            #[doc = "1   - Receive Line Status\r\n(RLS)."]
            RECEIVE,
            #[doc = "2a\r\n- Receive Data Available (RDA)."]
            RDA,
            #[doc = "2b - Character Time-out Indicator\r\n(CTI)."]
            CTIMEOUT,
            #[doc = "3\r\n  - THRE Interrupt."]
            THRE,
            #[doc = "4   - Modem interrupt."]
            MODEM,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl INTIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    INTIDR::RECEIVE => 0x03,
                    INTIDR::RDA => 0x02,
                    INTIDR::CTIMEOUT => 0x06,
                    INTIDR::THRE => 0x01,
                    INTIDR::MODEM => 0,
                    INTIDR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> INTIDR {
                match value {
                    3 => INTIDR::RECEIVE,
                    2 => INTIDR::RDA,
                    6 => INTIDR::CTIMEOUT,
                    1 => INTIDR::THRE,
                    0 => INTIDR::MODEM,
                    i => INTIDR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RECEIVE`"]
            #[inline]
            pub fn is_receive(&self) -> bool {
                *self == INTIDR::RECEIVE
            }
            #[doc = "Checks if the value of the field is `RDA`"]
            #[inline]
            pub fn is_rda(&self) -> bool {
                *self == INTIDR::RDA
            }
            #[doc = "Checks if the value of the field is `CTIMEOUT`"]
            #[inline]
            pub fn is_ctimeout(&self) -> bool {
                *self == INTIDR::CTIMEOUT
            }
            #[doc = "Checks if the value of the field is `THRE`"]
            #[inline]
            pub fn is_thre(&self) -> bool {
                *self == INTIDR::THRE
            }
            #[doc = "Checks if the value of the field is `MODEM`"]
            #[inline]
            pub fn is_modem(&self) -> bool {
                *self == INTIDR::MODEM
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIFOENR {
            bits: u8,
        }
        impl FIFOENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABEOINTR {
            bits: bool,
        }
        impl ABEOINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ABTOINTR {
            bits: bool,
        }
        impl ABTOINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt status. Note that IIR[0] is active low. The pending interrupt can be determined by evaluating IIR[3:1]."]
            #[inline]
            pub fn intstatus(&self) -> INTSTATUSR {
                INTSTATUSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 1:3 - Interrupt identification. IER[3:1] identifies an interrupt corresponding to the UART Rx FIFO. All other combinations of IER[3:1] not listed below are reserved (100,101,111)."]
            #[inline]
            pub fn intid(&self) -> INTIDR {
                INTIDR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - These bits are equivalent to FCR[0]."]
            #[inline]
            pub fn fifoen(&self) -> FIFOENR {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FIFOENR { bits }
            }
            #[doc = "Bit 8 - End of auto-baud interrupt. True if auto-baud has finished successfully and interrupt is enabled."]
            #[inline]
            pub fn abeoint(&self) -> ABEOINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABEOINTR { bits }
            }
            #[doc = "Bit 9 - Auto-baud time-out interrupt. True if auto-baud has timed out and interrupt is enabled."]
            #[inline]
            pub fn abtoint(&self) -> ABTOINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ABTOINTR { bits }
            }
        }
    }
    #[doc = "FIFO Control Register. Controls UART FIFO usage and modes."]
    pub struct FCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "FIFO Control Register. Controls UART FIFO usage and modes."]
    pub mod fcr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FCR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `FIFOEN`"]
        pub enum FIFOENW {
            #[doc = "UART FIFOs are disabled. Must not be used in the application."]
            DISABLED,
            #[doc = "Active high enable for both UART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the UART FIFOs."]
            ENABLED,
        }
        impl FIFOENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FIFOENW::DISABLED => false,
                    FIFOENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIFOENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIFOENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FIFOENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "UART FIFOs are disabled. Must not be used in the application."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FIFOENW::DISABLED)
            }
            #[doc = "Active high enable for both UART Rx and TX FIFOs and FCR[7:1] access. This bit must be set for proper UART operation. Any transition on this bit will automatically clear the UART FIFOs."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FIFOENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXFIFOR`"]
        pub enum RXFIFORW {
            #[doc = "No impact on either of UART FIFOs."]
            NOACTION,
            #[doc = "Writing a logic 1 to FCR[1] will clear all bytes in UART Rx FIFO, reset the pointer logic. This bit is self-clearing."]
            CLEAR,
        }
        impl RXFIFORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXFIFORW::NOACTION => false,
                    RXFIFORW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXFIFORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXFIFORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXFIFORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No impact on either of UART FIFOs."]
            #[inline]
            pub fn noaction(self) -> &'a mut W {
                self.variant(RXFIFORW::NOACTION)
            }
            #[doc = "Writing a logic 1 to FCR[1] will clear all bytes in UART Rx FIFO, reset the pointer logic. This bit is self-clearing."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(RXFIFORW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `TXFIFOR`"]
        pub enum TXFIFORW {
            #[doc = "No impact on either of UART FIFOs."]
            NOACTION,
            #[doc = "Writing a logic 1 to FCR[2] will clear all bytes in UART TX FIFO, reset the pointer logic. This bit is self-clearing."]
            CLEAR,
        }
        impl TXFIFORW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    TXFIFORW::NOACTION => false,
                    TXFIFORW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXFIFORW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXFIFORW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: TXFIFORW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No impact on either of UART FIFOs."]
            #[inline]
            pub fn noaction(self) -> &'a mut W {
                self.variant(TXFIFORW::NOACTION)
            }
            #[doc = "Writing a logic 1 to FCR[2] will clear all bytes in UART TX FIFO, reset the pointer logic. This bit is self-clearing."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(TXFIFORW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXTLVL`"]
        pub enum RXTLVLW {
            #[doc = "Trigger level 0 (1 character or 0x01)."]
            TRIGGER_LEVEL_0_1_C,
            #[doc = "Trigger level 1 (4 characters or 0x04)."]
            TRIGGER_LEVEL_1_4_C,
            #[doc = "Trigger level 2 (8 characters or 0x08)."]
            TRIGGER_LEVEL_2_8_C,
            #[doc = "Trigger level 3 (14 characters or 0x0E)."]
            TRIGGER_LEVEL_3_14,
        }
        impl RXTLVLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RXTLVLW::TRIGGER_LEVEL_0_1_C => 0,
                    RXTLVLW::TRIGGER_LEVEL_1_4_C => 1,
                    RXTLVLW::TRIGGER_LEVEL_2_8_C => 2,
                    RXTLVLW::TRIGGER_LEVEL_3_14 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXTLVLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXTLVLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXTLVLW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Trigger level 0 (1 character or 0x01)."]
            #[inline]
            pub fn trigger_level_0_1_c(self) -> &'a mut W {
                self.variant(RXTLVLW::TRIGGER_LEVEL_0_1_C)
            }
            #[doc = "Trigger level 1 (4 characters or 0x04)."]
            #[inline]
            pub fn trigger_level_1_4_c(self) -> &'a mut W {
                self.variant(RXTLVLW::TRIGGER_LEVEL_1_4_C)
            }
            #[doc = "Trigger level 2 (8 characters or 0x08)."]
            #[inline]
            pub fn trigger_level_2_8_c(self) -> &'a mut W {
                self.variant(RXTLVLW::TRIGGER_LEVEL_2_8_C)
            }
            #[doc = "Trigger level 3 (14 characters or 0x0E)."]
            #[inline]
            pub fn trigger_level_3_14(self) -> &'a mut W {
                self.variant(RXTLVLW::TRIGGER_LEVEL_3_14)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - FIFO Enable"]
            #[inline]
            pub fn fifoen(&mut self) -> _FIFOENW {
                _FIFOENW { w: self }
            }
            #[doc = "Bit 1 - RX FIFO Reset"]
            #[inline]
            pub fn rxfifor(&mut self) -> _RXFIFORW {
                _RXFIFORW { w: self }
            }
            #[doc = "Bit 2 - TX FIFO Reset"]
            #[inline]
            pub fn txfifor(&mut self) -> _TXFIFORW {
                _TXFIFORW { w: self }
            }
            #[doc = "Bits 6:7 - RX Trigger Level. These two bits determine how many receiver UART FIFO characters must be written before an interrupt is activated."]
            #[inline]
            pub fn rxtlvl(&mut self) -> _RXTLVLW {
                _RXTLVLW { w: self }
            }
        }
    }
    #[doc = "Line Control Register. Contains controls for frame formatting and break generation."]
    pub struct LCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Line Control Register. Contains controls for frame formatting and break generation."]
    pub mod lcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::LCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WLS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WLSR {
            #[doc = "5-bit character length."]
            _5_BIT_CHARACTER_LENG,
            #[doc = "6-bit character length."]
            _6_BIT_CHARACTER_LENG,
            #[doc = "7-bit character length."]
            _7_BIT_CHARACTER_LENG,
            #[doc = "8-bit character length."]
            _8_BIT_CHARACTER_LENG,
        }
        impl WLSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    WLSR::_5_BIT_CHARACTER_LENG => 0,
                    WLSR::_6_BIT_CHARACTER_LENG => 0x01,
                    WLSR::_7_BIT_CHARACTER_LENG => 0x02,
                    WLSR::_8_BIT_CHARACTER_LENG => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> WLSR {
                match value {
                    0 => WLSR::_5_BIT_CHARACTER_LENG,
                    1 => WLSR::_6_BIT_CHARACTER_LENG,
                    2 => WLSR::_7_BIT_CHARACTER_LENG,
                    3 => WLSR::_8_BIT_CHARACTER_LENG,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_5_BIT_CHARACTER_LENG`"]
            #[inline]
            pub fn is_5_bit_character_leng(&self) -> bool {
                *self == WLSR::_5_BIT_CHARACTER_LENG
            }
            #[doc = "Checks if the value of the field is `_6_BIT_CHARACTER_LENG`"]
            #[inline]
            pub fn is_6_bit_character_leng(&self) -> bool {
                *self == WLSR::_6_BIT_CHARACTER_LENG
            }
            #[doc = "Checks if the value of the field is `_7_BIT_CHARACTER_LENG`"]
            #[inline]
            pub fn is_7_bit_character_leng(&self) -> bool {
                *self == WLSR::_7_BIT_CHARACTER_LENG
            }
            #[doc = "Checks if the value of the field is `_8_BIT_CHARACTER_LENG`"]
            #[inline]
            pub fn is_8_bit_character_leng(&self) -> bool {
                *self == WLSR::_8_BIT_CHARACTER_LENG
            }
        }
        #[doc = "Possible values of the field `SBS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBSR {
            #[doc = "1 stop bit."]
            _1_STOP_BIT,
            #[doc = "2 stop bits (1.5 if LCR[1:0]=00)."]
            _2_STOP_BITS_1_5_IF,
        }
        impl SBSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SBSR::_1_STOP_BIT => false,
                    SBSR::_2_STOP_BITS_1_5_IF => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SBSR {
                match value {
                    false => SBSR::_1_STOP_BIT,
                    true => SBSR::_2_STOP_BITS_1_5_IF,
                }
            }
            #[doc = "Checks if the value of the field is `_1_STOP_BIT`"]
            #[inline]
            pub fn is_1_stop_bit(&self) -> bool {
                *self == SBSR::_1_STOP_BIT
            }
            #[doc = "Checks if the value of the field is `_2_STOP_BITS_1_5_IF`"]
            #[inline]
            pub fn is_2_stop_bits_1_5_if(&self) -> bool {
                *self == SBSR::_2_STOP_BITS_1_5_IF
            }
        }
        #[doc = "Possible values of the field `PE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PER {
            #[doc = "Disable parity generation and checking."]
            DISABLE_PARITY_GENER,
            #[doc = "Enable parity generation and checking."]
            ENABLE_PARITY_GENERA,
        }
        impl PER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PER::DISABLE_PARITY_GENER => false,
                    PER::ENABLE_PARITY_GENERA => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PER {
                match value {
                    false => PER::DISABLE_PARITY_GENER,
                    true => PER::ENABLE_PARITY_GENERA,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_PARITY_GENER`"]
            #[inline]
            pub fn is_disable_parity_gener(&self) -> bool {
                *self == PER::DISABLE_PARITY_GENER
            }
            #[doc = "Checks if the value of the field is `ENABLE_PARITY_GENERA`"]
            #[inline]
            pub fn is_enable_parity_genera(&self) -> bool {
                *self == PER::ENABLE_PARITY_GENERA
            }
        }
        #[doc = "Possible values of the field `PS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSR {
            #[doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd."]
            ODD_PARITY_NUMBER_O,
            #[doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even."]
            EVEN_PARITY_NUMBER,
            #[doc = "Forced 1 stick parity."]
            FORCED_1_STICK_PARIT,
            #[doc = "Forced 0 stick parity."]
            FORCED_0_STICK_PARIT,
        }
        impl PSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSR::ODD_PARITY_NUMBER_O => 0,
                    PSR::EVEN_PARITY_NUMBER => 0x01,
                    PSR::FORCED_1_STICK_PARIT => 0x02,
                    PSR::FORCED_0_STICK_PARIT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSR {
                match value {
                    0 => PSR::ODD_PARITY_NUMBER_O,
                    1 => PSR::EVEN_PARITY_NUMBER,
                    2 => PSR::FORCED_1_STICK_PARIT,
                    3 => PSR::FORCED_0_STICK_PARIT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ODD_PARITY_NUMBER_O`"]
            #[inline]
            pub fn is_odd_parity_number_o(&self) -> bool {
                *self == PSR::ODD_PARITY_NUMBER_O
            }
            #[doc = "Checks if the value of the field is `EVEN_PARITY_NUMBER`"]
            #[inline]
            pub fn is_even_parity_number(&self) -> bool {
                *self == PSR::EVEN_PARITY_NUMBER
            }
            #[doc = "Checks if the value of the field is `FORCED_1_STICK_PARIT`"]
            #[inline]
            pub fn is_forced_1_stick_parit(&self) -> bool {
                *self == PSR::FORCED_1_STICK_PARIT
            }
            #[doc = "Checks if the value of the field is `FORCED_0_STICK_PARIT`"]
            #[inline]
            pub fn is_forced_0_stick_parit(&self) -> bool {
                *self == PSR::FORCED_0_STICK_PARIT
            }
        }
        #[doc = "Possible values of the field `BC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BCR {
            #[doc = "Disable break transmission."]
            DISABLE_BREAK_TRANSM,
            #[doc = "Enable break transmission. Output pin UART TXD is forced to logic 0 when LCR[6] is active high."]
            ENABLE_BREAK_TRANSMI,
        }
        impl BCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BCR::DISABLE_BREAK_TRANSM => false,
                    BCR::ENABLE_BREAK_TRANSMI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BCR {
                match value {
                    false => BCR::DISABLE_BREAK_TRANSM,
                    true => BCR::ENABLE_BREAK_TRANSMI,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_BREAK_TRANSM`"]
            #[inline]
            pub fn is_disable_break_transm(&self) -> bool {
                *self == BCR::DISABLE_BREAK_TRANSM
            }
            #[doc = "Checks if the value of the field is `ENABLE_BREAK_TRANSMI`"]
            #[inline]
            pub fn is_enable_break_transmi(&self) -> bool {
                *self == BCR::ENABLE_BREAK_TRANSMI
            }
        }
        #[doc = "Possible values of the field `DLAB`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DLABR {
            #[doc = "Disable access to Divisor Latches."]
            DISABLE_ACCESS_TO_DI,
            #[doc = "Enable access to Divisor Latches."]
            ENABLE_ACCESS_TO_DIV,
        }
        impl DLABR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DLABR::DISABLE_ACCESS_TO_DI => false,
                    DLABR::ENABLE_ACCESS_TO_DIV => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DLABR {
                match value {
                    false => DLABR::DISABLE_ACCESS_TO_DI,
                    true => DLABR::ENABLE_ACCESS_TO_DIV,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_ACCESS_TO_DI`"]
            #[inline]
            pub fn is_disable_access_to_di(&self) -> bool {
                *self == DLABR::DISABLE_ACCESS_TO_DI
            }
            #[doc = "Checks if the value of the field is `ENABLE_ACCESS_TO_DIV`"]
            #[inline]
            pub fn is_enable_access_to_div(&self) -> bool {
                *self == DLABR::ENABLE_ACCESS_TO_DIV
            }
        }
        #[doc = "Values that can be written to the field `WLS`"]
        pub enum WLSW {
            #[doc = "5-bit character length."]
            _5_BIT_CHARACTER_LENG,
            #[doc = "6-bit character length."]
            _6_BIT_CHARACTER_LENG,
            #[doc = "7-bit character length."]
            _7_BIT_CHARACTER_LENG,
            #[doc = "8-bit character length."]
            _8_BIT_CHARACTER_LENG,
        }
        impl WLSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    WLSW::_5_BIT_CHARACTER_LENG => 0,
                    WLSW::_6_BIT_CHARACTER_LENG => 1,
                    WLSW::_7_BIT_CHARACTER_LENG => 2,
                    WLSW::_8_BIT_CHARACTER_LENG => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WLSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WLSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WLSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "5-bit character length."]
            #[inline]
            pub fn _5_bit_character_leng(self) -> &'a mut W {
                self.variant(WLSW::_5_BIT_CHARACTER_LENG)
            }
            #[doc = "6-bit character length."]
            #[inline]
            pub fn _6_bit_character_leng(self) -> &'a mut W {
                self.variant(WLSW::_6_BIT_CHARACTER_LENG)
            }
            #[doc = "7-bit character length."]
            #[inline]
            pub fn _7_bit_character_leng(self) -> &'a mut W {
                self.variant(WLSW::_7_BIT_CHARACTER_LENG)
            }
            #[doc = "8-bit character length."]
            #[inline]
            pub fn _8_bit_character_leng(self) -> &'a mut W {
                self.variant(WLSW::_8_BIT_CHARACTER_LENG)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SBS`"]
        pub enum SBSW {
            #[doc = "1 stop bit."]
            _1_STOP_BIT,
            #[doc = "2 stop bits (1.5 if LCR[1:0]=00)."]
            _2_STOP_BITS_1_5_IF,
        }
        impl SBSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SBSW::_1_STOP_BIT => false,
                    SBSW::_2_STOP_BITS_1_5_IF => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SBSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SBSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SBSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 stop bit."]
            #[inline]
            pub fn _1_stop_bit(self) -> &'a mut W {
                self.variant(SBSW::_1_STOP_BIT)
            }
            #[doc = "2 stop bits (1.5 if LCR[1:0]=00)."]
            #[inline]
            pub fn _2_stop_bits_1_5_if(self) -> &'a mut W {
                self.variant(SBSW::_2_STOP_BITS_1_5_IF)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PE`"]
        pub enum PEW {
            #[doc = "Disable parity generation and checking."]
            DISABLE_PARITY_GENER,
            #[doc = "Enable parity generation and checking."]
            ENABLE_PARITY_GENERA,
        }
        impl PEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PEW::DISABLE_PARITY_GENER => false,
                    PEW::ENABLE_PARITY_GENERA => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable parity generation and checking."]
            #[inline]
            pub fn disable_parity_gener(self) -> &'a mut W {
                self.variant(PEW::DISABLE_PARITY_GENER)
            }
            #[doc = "Enable parity generation and checking."]
            #[inline]
            pub fn enable_parity_genera(self) -> &'a mut W {
                self.variant(PEW::ENABLE_PARITY_GENERA)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PS`"]
        pub enum PSW {
            #[doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd."]
            ODD_PARITY_NUMBER_O,
            #[doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even."]
            EVEN_PARITY_NUMBER,
            #[doc = "Forced 1 stick parity."]
            FORCED_1_STICK_PARIT,
            #[doc = "Forced 0 stick parity."]
            FORCED_0_STICK_PARIT,
        }
        impl PSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSW::ODD_PARITY_NUMBER_O => 0,
                    PSW::EVEN_PARITY_NUMBER => 1,
                    PSW::FORCED_1_STICK_PARIT => 2,
                    PSW::FORCED_0_STICK_PARIT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Odd parity. Number of 1s in the transmitted character and the attached parity bit will be odd."]
            #[inline]
            pub fn odd_parity_number_o(self) -> &'a mut W {
                self.variant(PSW::ODD_PARITY_NUMBER_O)
            }
            #[doc = "Even Parity. Number of 1s in the transmitted character and the attached parity bit will be even."]
            #[inline]
            pub fn even_parity_number(self) -> &'a mut W {
                self.variant(PSW::EVEN_PARITY_NUMBER)
            }
            #[doc = "Forced 1 stick parity."]
            #[inline]
            pub fn forced_1_stick_parit(self) -> &'a mut W {
                self.variant(PSW::FORCED_1_STICK_PARIT)
            }
            #[doc = "Forced 0 stick parity."]
            #[inline]
            pub fn forced_0_stick_parit(self) -> &'a mut W {
                self.variant(PSW::FORCED_0_STICK_PARIT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BC`"]
        pub enum BCW {
            #[doc = "Disable break transmission."]
            DISABLE_BREAK_TRANSM,
            #[doc = "Enable break transmission. Output pin UART TXD is forced to logic 0 when LCR[6] is active high."]
            ENABLE_BREAK_TRANSMI,
        }
        impl BCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BCW::DISABLE_BREAK_TRANSM => false,
                    BCW::ENABLE_BREAK_TRANSMI => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable break transmission."]
            #[inline]
            pub fn disable_break_transm(self) -> &'a mut W {
                self.variant(BCW::DISABLE_BREAK_TRANSM)
            }
            #[doc = "Enable break transmission. Output pin UART TXD is forced to logic 0 when LCR[6] is active high."]
            #[inline]
            pub fn enable_break_transmi(self) -> &'a mut W {
                self.variant(BCW::ENABLE_BREAK_TRANSMI)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DLAB`"]
        pub enum DLABW {
            #[doc = "Disable access to Divisor Latches."]
            DISABLE_ACCESS_TO_DI,
            #[doc = "Enable access to Divisor Latches."]
            ENABLE_ACCESS_TO_DIV,
        }
        impl DLABW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DLABW::DISABLE_ACCESS_TO_DI => false,
                    DLABW::ENABLE_ACCESS_TO_DIV => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DLABW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DLABW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DLABW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable access to Divisor Latches."]
            #[inline]
            pub fn disable_access_to_di(self) -> &'a mut W {
                self.variant(DLABW::DISABLE_ACCESS_TO_DI)
            }
            #[doc = "Enable access to Divisor Latches."]
            #[inline]
            pub fn enable_access_to_div(self) -> &'a mut W {
                self.variant(DLABW::ENABLE_ACCESS_TO_DIV)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline]
            pub fn wls(&self) -> WLSR {
                WLSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 2 - Stop Bit Select"]
            #[inline]
            pub fn sbs(&self) -> SBSR {
                SBSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline]
            pub fn pe(&self) -> PER {
                PER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 4:5 - Parity Select"]
            #[inline]
            pub fn ps(&self) -> PSR {
                PSR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Break Control"]
            #[inline]
            pub fn bc(&self) -> BCR {
                BCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit (DLAB)"]
            #[inline]
            pub fn dlab(&self) -> DLABR {
                DLABR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Word Length Select"]
            #[inline]
            pub fn wls(&mut self) -> _WLSW {
                _WLSW { w: self }
            }
            #[doc = "Bit 2 - Stop Bit Select"]
            #[inline]
            pub fn sbs(&mut self) -> _SBSW {
                _SBSW { w: self }
            }
            #[doc = "Bit 3 - Parity Enable"]
            #[inline]
            pub fn pe(&mut self) -> _PEW {
                _PEW { w: self }
            }
            #[doc = "Bits 4:5 - Parity Select"]
            #[inline]
            pub fn ps(&mut self) -> _PSW {
                _PSW { w: self }
            }
            #[doc = "Bit 6 - Break Control"]
            #[inline]
            pub fn bc(&mut self) -> _BCW {
                _BCW { w: self }
            }
            #[doc = "Bit 7 - Divisor Latch Access Bit (DLAB)"]
            #[inline]
            pub fn dlab(&mut self) -> _DLABW {
                _DLABW { w: self }
            }
        }
    }
    #[doc = "Modem control register"]
    pub struct MCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Modem control register"]
    pub mod mcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DTRCTRLR {
            bits: bool,
        }
        impl DTRCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTSCTRLR {
            bits: bool,
        }
        impl RTSCTRLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct LMSR {
            bits: bool,
        }
        impl LMSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `RTSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTSENR {
            #[doc = "Disable auto-rts flow control."]
            DISABLE_AUTO_RTS_FLO,
            #[doc = "Enable auto-rts flow control."]
            ENABLE_AUTO_RTS_FLOW,
        }
        impl RTSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RTSENR::DISABLE_AUTO_RTS_FLO => false,
                    RTSENR::ENABLE_AUTO_RTS_FLOW => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RTSENR {
                match value {
                    false => RTSENR::DISABLE_AUTO_RTS_FLO,
                    true => RTSENR::ENABLE_AUTO_RTS_FLOW,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_AUTO_RTS_FLO`"]
            #[inline]
            pub fn is_disable_auto_rts_flo(&self) -> bool {
                *self == RTSENR::DISABLE_AUTO_RTS_FLO
            }
            #[doc = "Checks if the value of the field is `ENABLE_AUTO_RTS_FLOW`"]
            #[inline]
            pub fn is_enable_auto_rts_flow(&self) -> bool {
                *self == RTSENR::ENABLE_AUTO_RTS_FLOW
            }
        }
        #[doc = "Possible values of the field `CTSEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSENR {
            #[doc = "Disable auto-cts flow control."]
            DISABLE_AUTO_CTS_FLO,
            #[doc = "Enable auto-cts flow control."]
            ENABLE_AUTO_CTS_FLOW,
        }
        impl CTSENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CTSENR::DISABLE_AUTO_CTS_FLO => false,
                    CTSENR::ENABLE_AUTO_CTS_FLOW => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CTSENR {
                match value {
                    false => CTSENR::DISABLE_AUTO_CTS_FLO,
                    true => CTSENR::ENABLE_AUTO_CTS_FLOW,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_AUTO_CTS_FLO`"]
            #[inline]
            pub fn is_disable_auto_cts_flo(&self) -> bool {
                *self == CTSENR::DISABLE_AUTO_CTS_FLO
            }
            #[doc = "Checks if the value of the field is `ENABLE_AUTO_CTS_FLOW`"]
            #[inline]
            pub fn is_enable_auto_cts_flow(&self) -> bool {
                *self == CTSENR::ENABLE_AUTO_CTS_FLOW
            }
        }
        #[doc = r" Proxy"]
        pub struct _DTRCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DTRCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTSCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTSCTRLW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LMSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LMSW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RTSEN`"]
        pub enum RTSENW {
            #[doc = "Disable auto-rts flow control."]
            DISABLE_AUTO_RTS_FLO,
            #[doc = "Enable auto-rts flow control."]
            ENABLE_AUTO_RTS_FLOW,
        }
        impl RTSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RTSENW::DISABLE_AUTO_RTS_FLO => false,
                    RTSENW::ENABLE_AUTO_RTS_FLOW => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RTSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable auto-rts flow control."]
            #[inline]
            pub fn disable_auto_rts_flo(self) -> &'a mut W {
                self.variant(RTSENW::DISABLE_AUTO_RTS_FLO)
            }
            #[doc = "Enable auto-rts flow control."]
            #[inline]
            pub fn enable_auto_rts_flow(self) -> &'a mut W {
                self.variant(RTSENW::ENABLE_AUTO_RTS_FLOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CTSEN`"]
        pub enum CTSENW {
            #[doc = "Disable auto-cts flow control."]
            DISABLE_AUTO_CTS_FLO,
            #[doc = "Enable auto-cts flow control."]
            ENABLE_AUTO_CTS_FLOW,
        }
        impl CTSENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CTSENW::DISABLE_AUTO_CTS_FLO => false,
                    CTSENW::ENABLE_AUTO_CTS_FLOW => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTSENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTSENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTSENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable auto-cts flow control."]
            #[inline]
            pub fn disable_auto_cts_flo(self) -> &'a mut W {
                self.variant(CTSENW::DISABLE_AUTO_CTS_FLO)
            }
            #[doc = "Enable auto-cts flow control."]
            #[inline]
            pub fn enable_auto_cts_flow(self) -> &'a mut W {
                self.variant(CTSENW::ENABLE_AUTO_CTS_FLOW)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Source for modem output pin, DTR. This bit reads as 0 when modem loopback mode is active."]
            #[inline]
            pub fn dtrctrl(&self) -> DTRCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DTRCTRLR { bits }
            }
            #[doc = "Bit 1 - Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active."]
            #[inline]
            pub fn rtsctrl(&self) -> RTSCTRLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTSCTRLR { bits }
            }
            #[doc = "Bit 4 - Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The four modem inputs (CTS, DSR, RI and DCD) are disconnected externally. Externally, the modem outputs (RTS, DTR) are set inactive. Internally, the four modem outputs are connected to the four modem inputs. As a result of these connections, the upper four bits of the MSR will be driven by the lower four bits of the MCR rather than the four modem inputs in normal mode. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR."]
            #[inline]
            pub fn lms(&self) -> LMSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                LMSR { bits }
            }
            #[doc = "Bit 6 - RTS enable"]
            #[inline]
            pub fn rtsen(&self) -> RTSENR {
                RTSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - CTS enable"]
            #[inline]
            pub fn ctsen(&self) -> CTSENR {
                CTSENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Source for modem output pin, DTR. This bit reads as 0 when modem loopback mode is active."]
            #[inline]
            pub fn dtrctrl(&mut self) -> _DTRCTRLW {
                _DTRCTRLW { w: self }
            }
            #[doc = "Bit 1 - Source for modem output pin RTS. This bit reads as 0 when modem loopback mode is active."]
            #[inline]
            pub fn rtsctrl(&mut self) -> _RTSCTRLW {
                _RTSCTRLW { w: self }
            }
            #[doc = "Bit 4 - Loopback Mode Select. The modem loopback mode provides a mechanism to perform diagnostic loopback testing. Serial data from the transmitter is connected internally to serial input of the receiver. Input pin, RXD, has no effect on loopback and output pin, TXD is held in marking state. The four modem inputs (CTS, DSR, RI and DCD) are disconnected externally. Externally, the modem outputs (RTS, DTR) are set inactive. Internally, the four modem outputs are connected to the four modem inputs. As a result of these connections, the upper four bits of the MSR will be driven by the lower four bits of the MCR rather than the four modem inputs in normal mode. This permits modem status interrupts to be generated in loopback mode by writing the lower four bits of MCR."]
            #[inline]
            pub fn lms(&mut self) -> _LMSW {
                _LMSW { w: self }
            }
            #[doc = "Bit 6 - RTS enable"]
            #[inline]
            pub fn rtsen(&mut self) -> _RTSENW {
                _RTSENW { w: self }
            }
            #[doc = "Bit 7 - CTS enable"]
            #[inline]
            pub fn ctsen(&mut self) -> _CTSENW {
                _CTSENW { w: self }
            }
        }
    }
    #[doc = "Line Status Register. Contains flags for transmit and receive status, including line errors."]
    pub struct LSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Line Status Register. Contains flags for transmit and receive status, including line errors."]
    pub mod lsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::LSR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `RDR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RDRR {
            #[doc = "RBR is empty."]
            RBR_IS_EMPTY,
            #[doc = "RBR contains valid data."]
            RBR_CONTAINS_VALID,
        }
        impl RDRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RDRR::RBR_IS_EMPTY => false,
                    RDRR::RBR_CONTAINS_VALID => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RDRR {
                match value {
                    false => RDRR::RBR_IS_EMPTY,
                    true => RDRR::RBR_CONTAINS_VALID,
                }
            }
            #[doc = "Checks if the value of the field is `RBR_IS_EMPTY`"]
            #[inline]
            pub fn is_rbr_is_empty(&self) -> bool {
                *self == RDRR::RBR_IS_EMPTY
            }
            #[doc = "Checks if the value of the field is `RBR_CONTAINS_VALID`"]
            #[inline]
            pub fn is_rbr_contains_valid(&self) -> bool {
                *self == RDRR::RBR_CONTAINS_VALID
            }
        }
        #[doc = "Possible values of the field `OE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OER {
            #[doc = "Overrun error status is inactive."]
            INACTIVE,
            #[doc = "Overrun error status is active."]
            ACTIVE,
        }
        impl OER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OER::INACTIVE => false,
                    OER::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OER {
                match value {
                    false => OER::INACTIVE,
                    true => OER::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline]
            pub fn is_inactive(&self) -> bool {
                *self == OER::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == OER::ACTIVE
            }
        }
        #[doc = "Possible values of the field `PE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PER {
            #[doc = "Parity error status is inactive."]
            INACTIVE,
            #[doc = "Parity error status is active."]
            ACTIVE,
        }
        impl PER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PER::INACTIVE => false,
                    PER::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PER {
                match value {
                    false => PER::INACTIVE,
                    true => PER::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline]
            pub fn is_inactive(&self) -> bool {
                *self == PER::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == PER::ACTIVE
            }
        }
        #[doc = "Possible values of the field `FE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FER {
            #[doc = "Framing error status is inactive."]
            INACTIVE,
            #[doc = "Framing error status is active."]
            ACTIVE,
        }
        impl FER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FER::INACTIVE => false,
                    FER::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FER {
                match value {
                    false => FER::INACTIVE,
                    true => FER::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline]
            pub fn is_inactive(&self) -> bool {
                *self == FER::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == FER::ACTIVE
            }
        }
        #[doc = "Possible values of the field `BI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIR {
            #[doc = "Break interrupt status is inactive."]
            INACTIVE,
            #[doc = "Break interrupt status is active."]
            ACTIVE,
        }
        impl BIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BIR::INACTIVE => false,
                    BIR::ACTIVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BIR {
                match value {
                    false => BIR::INACTIVE,
                    true => BIR::ACTIVE,
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE`"]
            #[inline]
            pub fn is_inactive(&self) -> bool {
                *self == BIR::INACTIVE
            }
            #[doc = "Checks if the value of the field is `ACTIVE`"]
            #[inline]
            pub fn is_active(&self) -> bool {
                *self == BIR::ACTIVE
            }
        }
        #[doc = "Possible values of the field `THRE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum THRER {
            #[doc = "THR contains valid data."]
            VALID,
            #[doc = "THR is empty."]
            EMPTY,
        }
        impl THRER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    THRER::VALID => false,
                    THRER::EMPTY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> THRER {
                match value {
                    false => THRER::VALID,
                    true => THRER::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `VALID`"]
            #[inline]
            pub fn is_valid(&self) -> bool {
                *self == THRER::VALID
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline]
            pub fn is_empty(&self) -> bool {
                *self == THRER::EMPTY
            }
        }
        #[doc = "Possible values of the field `TEMT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEMTR {
            #[doc = "THR and/or the TSR contains valid data."]
            VALID,
            #[doc = "THR and the TSR are empty."]
            EMPTY,
        }
        impl TEMTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TEMTR::VALID => false,
                    TEMTR::EMPTY => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TEMTR {
                match value {
                    false => TEMTR::VALID,
                    true => TEMTR::EMPTY,
                }
            }
            #[doc = "Checks if the value of the field is `VALID`"]
            #[inline]
            pub fn is_valid(&self) -> bool {
                *self == TEMTR::VALID
            }
            #[doc = "Checks if the value of the field is `EMPTY`"]
            #[inline]
            pub fn is_empty(&self) -> bool {
                *self == TEMTR::EMPTY
            }
        }
        #[doc = "Possible values of the field `RXFE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXFER {
            #[doc = "RBR contains no UART RX errors or FCR[0]=0."]
            NOERROR,
            #[doc = "UART RBR contains at least one UART RX error."]
            ERRORS,
        }
        impl RXFER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXFER::NOERROR => false,
                    RXFER::ERRORS => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXFER {
                match value {
                    false => RXFER::NOERROR,
                    true => RXFER::ERRORS,
                }
            }
            #[doc = "Checks if the value of the field is `NOERROR`"]
            #[inline]
            pub fn is_noerror(&self) -> bool {
                *self == RXFER::NOERROR
            }
            #[doc = "Checks if the value of the field is `ERRORS`"]
            #[inline]
            pub fn is_errors(&self) -> bool {
                *self == RXFER::ERRORS
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Receiver Data Ready. LSR[0] is set when the RBR holds an unread character and is cleared when the UART RBR FIFO is empty."]
            #[inline]
            pub fn rdr(&self) -> RDRR {
                RDRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Overrun Error. The overrun error condition is set as soon as it occurs. A LSR read clears LSR[1]. LSR[1] is set when UART RSR has a new character assembled and the UART RBR FIFO is full. In this case, the UART RBR FIFO will not be overwritten and the character in the UART RSR will be lost."]
            #[inline]
            pub fn oe(&self) -> OER {
                OER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Parity Error. When the parity bit of a received character is in the wrong state, a parity error occurs. A LSR read clears LSR[2]. Time of parity error detection is dependent on FCR[0]. Note: A parity error is associated with the character at the top of the UART RBR FIFO."]
            #[inline]
            pub fn pe(&self) -> PER {
                PER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Framing Error. When the stop bit of a received character is a logic 0, a framing error occurs. A LSR read clears LSR[3]. The time of the framing error detection is dependent on FCR0. Upon detection of a framing error, the RX will attempt to re-synchronize to the data and assume that the bad stop bit is actually an early start bit. However, it cannot be assumed that the next received byte will be correct even if there is no Framing Error. Note: A framing error is associated with the character at the top of the UART RBR FIFO."]
            #[inline]
            pub fn fe(&self) -> FER {
                FER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Break Interrupt. When RXD1 is held in the spacing state (all zeros) for one full character transmission (start, data, parity, stop), a break interrupt occurs. Once the break condition has been detected, the receiver goes idle until RXD1 goes to marking state (all ones). A LSR read clears this status bit. The time of break detection is dependent on FCR[0]. Note: The break interrupt is associated with the character at the top of the UART RBR FIFO."]
            #[inline]
            pub fn bi(&self) -> BIR {
                BIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Transmitter Holding Register Empty. THRE is set immediately upon detection of an empty UART THR and is cleared on a THR write."]
            #[inline]
            pub fn thre(&self) -> THRER {
                THRER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Transmitter Empty. TEMT is set when both THR and TSR are empty; TEMT is cleared when either the TSR or the THR contain valid data."]
            #[inline]
            pub fn temt(&self) -> TEMTR {
                TEMTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Error in RX FIFO. LSR[7] is set when a character with a RX error such as framing error, parity error or break interrupt, is loaded into the RBR. This bit is cleared when the LSR register is read and there are no subsequent errors in the UART FIFO."]
            #[inline]
            pub fn rxfe(&self) -> RXFER {
                RXFER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "Modem status register"]
    pub struct MSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Modem status register"]
    pub mod msr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MSR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `DELTACTS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DELTACTSR {
            #[doc = "No change detected on modem input CTS."]
            NO_STATE_CHANGE,
            #[doc = "State change detected on modem input CTS."]
            STATE_CHANGE_DETECTE,
        }
        impl DELTACTSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DELTACTSR::NO_STATE_CHANGE => false,
                    DELTACTSR::STATE_CHANGE_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DELTACTSR {
                match value {
                    false => DELTACTSR::NO_STATE_CHANGE,
                    true => DELTACTSR::STATE_CHANGE_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_STATE_CHANGE`"]
            #[inline]
            pub fn is_no_state_change(&self) -> bool {
                *self == DELTACTSR::NO_STATE_CHANGE
            }
            #[doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`"]
            #[inline]
            pub fn is_state_change_detecte(&self) -> bool {
                *self == DELTACTSR::STATE_CHANGE_DETECTE
            }
        }
        #[doc = "Possible values of the field `DELTADSR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DELTADSRR {
            #[doc = "No change detected on modem input DSR."]
            NO_STATE_CHANGE,
            #[doc = "State change detected on modem input DSR."]
            STATE_CHANGE_DETECTE,
        }
        impl DELTADSRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DELTADSRR::NO_STATE_CHANGE => false,
                    DELTADSRR::STATE_CHANGE_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DELTADSRR {
                match value {
                    false => DELTADSRR::NO_STATE_CHANGE,
                    true => DELTADSRR::STATE_CHANGE_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_STATE_CHANGE`"]
            #[inline]
            pub fn is_no_state_change(&self) -> bool {
                *self == DELTADSRR::NO_STATE_CHANGE
            }
            #[doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`"]
            #[inline]
            pub fn is_state_change_detecte(&self) -> bool {
                *self == DELTADSRR::STATE_CHANGE_DETECTE
            }
        }
        #[doc = "Possible values of the field `TERI`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TERIR {
            #[doc = "No change detected on modem input, RI."]
            NO_STATE_CHANGE,
            #[doc = "Low-to-high transition detected on RI."]
            LOW_TO_HIGH_TRANSITI,
        }
        impl TERIR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    TERIR::NO_STATE_CHANGE => false,
                    TERIR::LOW_TO_HIGH_TRANSITI => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> TERIR {
                match value {
                    false => TERIR::NO_STATE_CHANGE,
                    true => TERIR::LOW_TO_HIGH_TRANSITI,
                }
            }
            #[doc = "Checks if the value of the field is `NO_STATE_CHANGE`"]
            #[inline]
            pub fn is_no_state_change(&self) -> bool {
                *self == TERIR::NO_STATE_CHANGE
            }
            #[doc = "Checks if the value of the field is `LOW_TO_HIGH_TRANSITI`"]
            #[inline]
            pub fn is_low_to_high_transiti(&self) -> bool {
                *self == TERIR::LOW_TO_HIGH_TRANSITI
            }
        }
        #[doc = "Possible values of the field `DELTADCD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DELTADCDR {
            #[doc = "No change detected on modem input DCD."]
            NO_STATE_CHANGE,
            #[doc = "State change detected on modem input DCD."]
            STATE_CHANGE_DETECTE,
        }
        impl DELTADCDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DELTADCDR::NO_STATE_CHANGE => false,
                    DELTADCDR::STATE_CHANGE_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DELTADCDR {
                match value {
                    false => DELTADCDR::NO_STATE_CHANGE,
                    true => DELTADCDR::STATE_CHANGE_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_STATE_CHANGE`"]
            #[inline]
            pub fn is_no_state_change(&self) -> bool {
                *self == DELTADCDR::NO_STATE_CHANGE
            }
            #[doc = "Checks if the value of the field is `STATE_CHANGE_DETECTE`"]
            #[inline]
            pub fn is_state_change_detecte(&self) -> bool {
                *self == DELTADCDR::STATE_CHANGE_DETECTE
            }
        }
        #[doc = r" Value of the field"]
        pub struct CTSR {
            bits: bool,
        }
        impl CTSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DSRR {
            bits: bool,
        }
        impl DSRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RIR {
            bits: bool,
        }
        impl RIR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DCDR {
            bits: bool,
        }
        impl DCDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Set upon state change of input CTS. Cleared on a MSR read."]
            #[inline]
            pub fn deltacts(&self) -> DELTACTSR {
                DELTACTSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Set upon state change of input DSR. Cleared on a MSR read."]
            #[inline]
            pub fn deltadsr(&self) -> DELTADSRR {
                DELTADSRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Trailing Edge RI. Set upon low to high transition of input RI. Cleared on a MSR read."]
            #[inline]
            pub fn teri(&self) -> TERIR {
                TERIR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Set upon state change of input DCD. Cleared on a MSR read."]
            #[inline]
            pub fn deltadcd(&self) -> DELTADCDR {
                DELTADCDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Clear To Send State. Complement of input signal CTS. This bit is connected to MCR[1] in modem loopback mode."]
            #[inline]
            pub fn cts(&self) -> CTSR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CTSR { bits }
            }
            #[doc = "Bit 5 - Data Set Ready State. Complement of input signal DSR. This bit is connected to MCR[0] in modem loopback mode."]
            #[inline]
            pub fn dsr(&self) -> DSRR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DSRR { bits }
            }
            #[doc = "Bit 6 - Ring Indicator State. Complement of input RI. This bit is connected to MCR[2] in modem loopback mode."]
            #[inline]
            pub fn ri(&self) -> RIR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RIR { bits }
            }
            #[doc = "Bit 7 - Data Carrier Detect State. Complement of input DCD. This bit is connected to MCR[3] in modem loopback mode."]
            #[inline]
            pub fn dcd(&self) -> DCDR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DCDR { bits }
            }
        }
    }
    #[doc = "Scratch Pad Register. Eight-bit temporary storage for software."]
    pub struct SCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Scratch Pad Register. Eight-bit temporary storage for software."]
    pub mod scr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PADR {
            bits: u8,
        }
        impl PADR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PADW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PADW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - A readable, writable byte."]
            #[inline]
            pub fn pad(&self) -> PADR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                PADR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - A readable, writable byte."]
            #[inline]
            pub fn pad(&mut self) -> _PADW {
                _PADW { w: self }
            }
        }
    }
    #[doc = "Auto-baud Control Register. Contains controls for the auto-baud feature."]
    pub struct ACR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Auto-baud Control Register. Contains controls for the auto-baud feature."]
    pub mod acr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ACR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STARTR {
            #[doc = "Auto-baud stop (auto-baud is not running)."]
            AUTO_BAUD_STOP_AUTO,
            #[doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."]
            AUTO_BAUD_START_AUT,
        }
        impl STARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    STARTR::AUTO_BAUD_STOP_AUTO => false,
                    STARTR::AUTO_BAUD_START_AUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> STARTR {
                match value {
                    false => STARTR::AUTO_BAUD_STOP_AUTO,
                    true => STARTR::AUTO_BAUD_START_AUT,
                }
            }
            #[doc = "Checks if the value of the field is `AUTO_BAUD_STOP_AUTO`"]
            #[inline]
            pub fn is_auto_baud_stop_auto(&self) -> bool {
                *self == STARTR::AUTO_BAUD_STOP_AUTO
            }
            #[doc = "Checks if the value of the field is `AUTO_BAUD_START_AUT`"]
            #[inline]
            pub fn is_auto_baud_start_aut(&self) -> bool {
                *self == STARTR::AUTO_BAUD_START_AUT
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Mode 0."]
            MODE_0,
            #[doc = "Mode 1."]
            MODE_1,
        }
        impl MODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MODER::MODE_0 => false,
                    MODER::MODE_1 => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MODER {
                match value {
                    false => MODER::MODE_0,
                    true => MODER::MODE_1,
                }
            }
            #[doc = "Checks if the value of the field is `MODE_0`"]
            #[inline]
            pub fn is_mode_0(&self) -> bool {
                *self == MODER::MODE_0
            }
            #[doc = "Checks if the value of the field is `MODE_1`"]
            #[inline]
            pub fn is_mode_1(&self) -> bool {
                *self == MODER::MODE_1
            }
        }
        #[doc = "Possible values of the field `AUTORESTART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AUTORESTARTR {
            #[doc = "No restart"]
            NO_RESTART,
            #[doc = "Restart in case of time-out (counter restarts at next UART Rx falling edge)"]
            RESTART_IN_CASE_OF_T,
        }
        impl AUTORESTARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AUTORESTARTR::NO_RESTART => false,
                    AUTORESTARTR::RESTART_IN_CASE_OF_T => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AUTORESTARTR {
                match value {
                    false => AUTORESTARTR::NO_RESTART,
                    true => AUTORESTARTR::RESTART_IN_CASE_OF_T,
                }
            }
            #[doc = "Checks if the value of the field is `NO_RESTART`"]
            #[inline]
            pub fn is_no_restart(&self) -> bool {
                *self == AUTORESTARTR::NO_RESTART
            }
            #[doc = "Checks if the value of the field is `RESTART_IN_CASE_OF_T`"]
            #[inline]
            pub fn is_restart_in_case_of_t(&self) -> bool {
                *self == AUTORESTARTR::RESTART_IN_CASE_OF_T
            }
        }
        #[doc = "Possible values of the field `ABEOINTCLR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABEOINTCLRR {
            #[doc = "Writing a 0 has no impact."]
            NOACTION,
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            CLEAR,
        }
        impl ABEOINTCLRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ABEOINTCLRR::NOACTION => false,
                    ABEOINTCLRR::CLEAR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ABEOINTCLRR {
                match value {
                    false => ABEOINTCLRR::NOACTION,
                    true => ABEOINTCLRR::CLEAR,
                }
            }
            #[doc = "Checks if the value of the field is `NOACTION`"]
            #[inline]
            pub fn is_noaction(&self) -> bool {
                *self == ABEOINTCLRR::NOACTION
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == ABEOINTCLRR::CLEAR
            }
        }
        #[doc = "Possible values of the field `ABTOINTCLR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ABTOINTCLRR {
            #[doc = "Writing a 0 has no impact."]
            NOACTION,
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            CLEAR,
        }
        impl ABTOINTCLRR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ABTOINTCLRR::NOACTION => false,
                    ABTOINTCLRR::CLEAR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ABTOINTCLRR {
                match value {
                    false => ABTOINTCLRR::NOACTION,
                    true => ABTOINTCLRR::CLEAR,
                }
            }
            #[doc = "Checks if the value of the field is `NOACTION`"]
            #[inline]
            pub fn is_noaction(&self) -> bool {
                *self == ABTOINTCLRR::NOACTION
            }
            #[doc = "Checks if the value of the field is `CLEAR`"]
            #[inline]
            pub fn is_clear(&self) -> bool {
                *self == ABTOINTCLRR::CLEAR
            }
        }
        #[doc = "Values that can be written to the field `START`"]
        pub enum STARTW {
            #[doc = "Auto-baud stop (auto-baud is not running)."]
            AUTO_BAUD_STOP_AUTO,
            #[doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."]
            AUTO_BAUD_START_AUT,
        }
        impl STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    STARTW::AUTO_BAUD_STOP_AUTO => false,
                    STARTW::AUTO_BAUD_START_AUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Auto-baud stop (auto-baud is not running)."]
            #[inline]
            pub fn auto_baud_stop_auto(self) -> &'a mut W {
                self.variant(STARTW::AUTO_BAUD_STOP_AUTO)
            }
            #[doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."]
            #[inline]
            pub fn auto_baud_start_aut(self) -> &'a mut W {
                self.variant(STARTW::AUTO_BAUD_START_AUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Mode 0."]
            MODE_0,
            #[doc = "Mode 1."]
            MODE_1,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MODEW::MODE_0 => false,
                    MODEW::MODE_1 => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Mode 0."]
            #[inline]
            pub fn mode_0(self) -> &'a mut W {
                self.variant(MODEW::MODE_0)
            }
            #[doc = "Mode 1."]
            #[inline]
            pub fn mode_1(self) -> &'a mut W {
                self.variant(MODEW::MODE_1)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AUTORESTART`"]
        pub enum AUTORESTARTW {
            #[doc = "No restart"]
            NO_RESTART,
            #[doc = "Restart in case of time-out (counter restarts at next UART Rx falling edge)"]
            RESTART_IN_CASE_OF_T,
        }
        impl AUTORESTARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AUTORESTARTW::NO_RESTART => false,
                    AUTORESTARTW::RESTART_IN_CASE_OF_T => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AUTORESTARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AUTORESTARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AUTORESTARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No restart"]
            #[inline]
            pub fn no_restart(self) -> &'a mut W {
                self.variant(AUTORESTARTW::NO_RESTART)
            }
            #[doc = "Restart in case of time-out (counter restarts at next UART Rx falling edge)"]
            #[inline]
            pub fn restart_in_case_of_t(self) -> &'a mut W {
                self.variant(AUTORESTARTW::RESTART_IN_CASE_OF_T)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ABEOINTCLR`"]
        pub enum ABEOINTCLRW {
            #[doc = "Writing a 0 has no impact."]
            NOACTION,
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            CLEAR,
        }
        impl ABEOINTCLRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ABEOINTCLRW::NOACTION => false,
                    ABEOINTCLRW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABEOINTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABEOINTCLRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ABEOINTCLRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Writing a 0 has no impact."]
            #[inline]
            pub fn noaction(self) -> &'a mut W {
                self.variant(ABEOINTCLRW::NOACTION)
            }
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ABEOINTCLRW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ABTOINTCLR`"]
        pub enum ABTOINTCLRW {
            #[doc = "Writing a 0 has no impact."]
            NOACTION,
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            CLEAR,
        }
        impl ABTOINTCLRW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ABTOINTCLRW::NOACTION => false,
                    ABTOINTCLRW::CLEAR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ABTOINTCLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ABTOINTCLRW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ABTOINTCLRW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Writing a 0 has no impact."]
            #[inline]
            pub fn noaction(self) -> &'a mut W {
                self.variant(ABTOINTCLRW::NOACTION)
            }
            #[doc = "Writing a 1 will clear the corresponding interrupt in the IIR."]
            #[inline]
            pub fn clear(self) -> &'a mut W {
                self.variant(ABTOINTCLRW::CLEAR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - This bit is automatically cleared after auto-baud completion."]
            #[inline]
            pub fn start(&self) -> STARTR {
                STARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Auto-baud mode select bit."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Auto restart"]
            #[inline]
            pub fn autorestart(&self) -> AUTORESTARTR {
                AUTORESTARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - End of auto-baud interrupt clear bit (write only accessible)."]
            #[inline]
            pub fn abeointclr(&self) -> ABEOINTCLRR {
                ABEOINTCLRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write only accessible)."]
            #[inline]
            pub fn abtointclr(&self) -> ABTOINTCLRR {
                ABTOINTCLRR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - This bit is automatically cleared after auto-baud completion."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 1 - Auto-baud mode select bit."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 2 - Auto restart"]
            #[inline]
            pub fn autorestart(&mut self) -> _AUTORESTARTW {
                _AUTORESTARTW { w: self }
            }
            #[doc = "Bit 8 - End of auto-baud interrupt clear bit (write only accessible)."]
            #[inline]
            pub fn abeointclr(&mut self) -> _ABEOINTCLRW {
                _ABEOINTCLRW { w: self }
            }
            #[doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write only accessible)."]
            #[inline]
            pub fn abtointclr(&mut self) -> _ABTOINTCLRW {
                _ABTOINTCLRW { w: self }
            }
        }
    }
    #[doc = "Fractional Divider Register. Generates a clock input for the baud rate divider."]
    pub struct FDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Fractional Divider Register. Generates a clock input for the baud rate divider."]
    pub mod fdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVADDVALR {
            bits: u8,
        }
        impl DIVADDVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct MULVALR {
            bits: u8,
        }
        impl MULVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVADDVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVADDVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MULVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MULVALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the UART baud rate."]
            #[inline]
            pub fn divaddval(&self) -> DIVADDVALR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVADDVALR { bits }
            }
            #[doc = "Bits 4:7 - Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for UART to operate properly, regardless of whether the fractional baud rate generator is used or not."]
            #[inline]
            pub fn mulval(&self) -> MULVALR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MULVALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x10 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Baud rate generation pre-scaler divisor value. If this field is 0, fractional baud rate generator will not impact the UART baud rate."]
            #[inline]
            pub fn divaddval(&mut self) -> _DIVADDVALW {
                _DIVADDVALW { w: self }
            }
            #[doc = "Bits 4:7 - Baud rate pre-scaler multiplier value. This field must be greater or equal 1 for UART to operate properly, regardless of whether the fractional baud rate generator is used or not."]
            #[inline]
            pub fn mulval(&mut self) -> _MULVALW {
                _MULVALW { w: self }
            }
        }
    }
    #[doc = "Transmit Enable Register. Turns off UART transmitter for use with software flow control."]
    pub struct TER {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Transmit Enable Register. Turns off UART transmitter for use with software flow control."]
    pub mod ter {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TER {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENR {
            bits: bool,
        }
        impl TXENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 7 - When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character."]
            #[inline]
            pub fn txen(&self) -> TXENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 7 - When this bit is 1, as it is after a Reset, data written to the THR is output on the TXD pin as soon as any preceding data has been sent. If this bit cleared to 0 while a character is being sent, the transmission of that character is completed, but no further characters are sent until this bit is set again. In other words, a 0 in this bit blocks the transfer of characters from the THR or TX FIFO into the transmit shift register. Software can clear this bit when it detects that the a hardware-handshaking TX-permit signal (CTS) has gone false, or with software handshaking, when it receives an XOFF character (DC3). Software can set this bit again when it detects that the TX-permit signal has gone true, or when it receives an XON (DC1) character."]
            #[inline]
            pub fn txen(&mut self) -> _TXENW {
                _TXENW { w: self }
            }
        }
    }
    #[doc = "RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes."]
    pub struct RS485CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RS-485/EIA-485 Control. Contains controls to configure various aspects of RS-485/EIA-485 modes."]
    pub mod rs485ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RS485CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `NMMEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NMMENR {
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled."]
            DISABLED,
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt."]
            ENABLED,
        }
        impl NMMENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    NMMENR::DISABLED => false,
                    NMMENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> NMMENR {
                match value {
                    false => NMMENR::DISABLED,
                    true => NMMENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == NMMENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == NMMENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RXDIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDISR {
            #[doc = "The receiver is enabled."]
            ENABLED,
            #[doc = "The receiver is disabled."]
            DISABLED,
        }
        impl RXDISR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RXDISR::ENABLED => false,
                    RXDISR::DISABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RXDISR {
                match value {
                    false => RXDISR::ENABLED,
                    true => RXDISR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RXDISR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RXDISR::DISABLED
            }
        }
        #[doc = "Possible values of the field `AADEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AADENR {
            #[doc = "Auto Address Detect (AAD) is disabled."]
            DISABLED,
            #[doc = "Auto Address Detect (AAD) is enabled."]
            ENABLED,
        }
        impl AADENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    AADENR::DISABLED => false,
                    AADENR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> AADENR {
                match value {
                    false => AADENR::DISABLED,
                    true => AADENR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == AADENR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == AADENR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control."]
            RTS,
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control."]
            DTR,
        }
        impl SELR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SELR::RTS => false,
                    SELR::DTR => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SELR {
                match value {
                    false => SELR::RTS,
                    true => SELR::DTR,
                }
            }
            #[doc = "Checks if the value of the field is `RTS`"]
            #[inline]
            pub fn is_rts(&self) -> bool {
                *self == SELR::RTS
            }
            #[doc = "Checks if the value of the field is `DTR`"]
            #[inline]
            pub fn is_dtr(&self) -> bool {
                *self == SELR::DTR
            }
        }
        #[doc = "Possible values of the field `DCTRL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCTRLR {
            #[doc = "Disable Auto Direction Control."]
            DISABLE_AUTO_DIRECTI,
            #[doc = "Enable Auto Direction Control."]
            ENABLE_AUTO_DIRECTIO,
        }
        impl DCTRLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DCTRLR::DISABLE_AUTO_DIRECTI => false,
                    DCTRLR::ENABLE_AUTO_DIRECTIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DCTRLR {
                match value {
                    false => DCTRLR::DISABLE_AUTO_DIRECTI,
                    true => DCTRLR::ENABLE_AUTO_DIRECTIO,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_AUTO_DIRECTI`"]
            #[inline]
            pub fn is_disable_auto_directi(&self) -> bool {
                *self == DCTRLR::DISABLE_AUTO_DIRECTI
            }
            #[doc = "Checks if the value of the field is `ENABLE_AUTO_DIRECTIO`"]
            #[inline]
            pub fn is_enable_auto_directio(&self) -> bool {
                *self == DCTRLR::ENABLE_AUTO_DIRECTIO
            }
        }
        #[doc = "Possible values of the field `OINV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OINVR {
            #[doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted."]
            LOW,
            #[doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted."]
            HIGH,
        }
        impl OINVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    OINVR::LOW => false,
                    OINVR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> OINVR {
                match value {
                    false => OINVR::LOW,
                    true => OINVR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == OINVR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == OINVR::HIGH
            }
        }
        #[doc = "Values that can be written to the field `NMMEN`"]
        pub enum NMMENW {
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled."]
            DISABLED,
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt."]
            ENABLED,
        }
        impl NMMENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    NMMENW::DISABLED => false,
                    NMMENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _NMMENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _NMMENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: NMMENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NMMENW::DISABLED)
            }
            #[doc = "RS-485/EIA-485 Normal Multidrop Mode (NMM) is enabled. In this mode, an address is detected when a received byte causes the UART to set the parity error and generate an interrupt."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NMMENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RXDIS`"]
        pub enum RXDISW {
            #[doc = "The receiver is enabled."]
            ENABLED,
            #[doc = "The receiver is disabled."]
            DISABLED,
        }
        impl RXDISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RXDISW::ENABLED => false,
                    RXDISW::DISABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXDISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXDISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RXDISW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The receiver is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDISW::ENABLED)
            }
            #[doc = "The receiver is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDISW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `AADEN`"]
        pub enum AADENW {
            #[doc = "Auto Address Detect (AAD) is disabled."]
            DISABLED,
            #[doc = "Auto Address Detect (AAD) is enabled."]
            ENABLED,
        }
        impl AADENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    AADENW::DISABLED => false,
                    AADENW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _AADENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _AADENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: AADENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Auto Address Detect (AAD) is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AADENW::DISABLED)
            }
            #[doc = "Auto Address Detect (AAD) is enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AADENW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control."]
            RTS,
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control."]
            DTR,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SELW::RTS => false,
                    SELW::DTR => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin RTS is used for direction control."]
            #[inline]
            pub fn rts(self) -> &'a mut W {
                self.variant(SELW::RTS)
            }
            #[doc = "If direction control is enabled (bit DCTRL = 1), pin DTR is used for direction control."]
            #[inline]
            pub fn dtr(self) -> &'a mut W {
                self.variant(SELW::DTR)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DCTRL`"]
        pub enum DCTRLW {
            #[doc = "Disable Auto Direction Control."]
            DISABLE_AUTO_DIRECTI,
            #[doc = "Enable Auto Direction Control."]
            ENABLE_AUTO_DIRECTIO,
        }
        impl DCTRLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DCTRLW::DISABLE_AUTO_DIRECTI => false,
                    DCTRLW::ENABLE_AUTO_DIRECTIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCTRLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCTRLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DCTRLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable Auto Direction Control."]
            #[inline]
            pub fn disable_auto_directi(self) -> &'a mut W {
                self.variant(DCTRLW::DISABLE_AUTO_DIRECTI)
            }
            #[doc = "Enable Auto Direction Control."]
            #[inline]
            pub fn enable_auto_directio(self) -> &'a mut W {
                self.variant(DCTRLW::ENABLE_AUTO_DIRECTIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OINV`"]
        pub enum OINVW {
            #[doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted."]
            LOW,
            #[doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted."]
            HIGH,
        }
        impl OINVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    OINVW::LOW => false,
                    OINVW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _OINVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OINVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: OINVW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The direction control pin will be driven to logic 0 when the transmitter has data to be sent. It will be driven to logic 1 after the last bit of data has been transmitted."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(OINVW::LOW)
            }
            #[doc = "The direction control pin will be driven to logic 1 when the transmitter has data to be sent. It will be driven to logic 0 after the last bit of data has been transmitted."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(OINVW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - NMM enable"]
            #[inline]
            pub fn nmmen(&self) -> NMMENR {
                NMMENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Receiver enable"]
            #[inline]
            pub fn rxdis(&self) -> RXDISR {
                RXDISR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - AAD enable"]
            #[inline]
            pub fn aaden(&self) -> AADENR {
                AADENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Direction control pins select"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Direction control enable"]
            #[inline]
            pub fn dctrl(&self) -> DCTRLR {
                DCTRLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin."]
            #[inline]
            pub fn oinv(&self) -> OINVR {
                OINVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - NMM enable"]
            #[inline]
            pub fn nmmen(&mut self) -> _NMMENW {
                _NMMENW { w: self }
            }
            #[doc = "Bit 1 - Receiver enable"]
            #[inline]
            pub fn rxdis(&mut self) -> _RXDISW {
                _RXDISW { w: self }
            }
            #[doc = "Bit 2 - AAD enable"]
            #[inline]
            pub fn aaden(&mut self) -> _AADENW {
                _AADENW { w: self }
            }
            #[doc = "Bit 3 - Direction control pins select"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
            #[doc = "Bit 4 - Direction control enable"]
            #[inline]
            pub fn dctrl(&mut self) -> _DCTRLW {
                _DCTRLW { w: self }
            }
            #[doc = "Bit 5 - This bit reverses the polarity of the direction control signal on the RTS (or DTR) pin."]
            #[inline]
            pub fn oinv(&mut self) -> _OINVW {
                _OINVW { w: self }
            }
        }
    }
    #[doc = "RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode."]
    pub struct RS485ADRMATCH {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RS-485/EIA-485 address match. Contains the address match value for RS-485/EIA-485 mode."]
    pub mod rs485adrmatch {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RS485ADRMATCH {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADRMATCHR {
            bits: u8,
        }
        impl ADRMATCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADRMATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADRMATCHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Contains the address match value."]
            #[inline]
            pub fn adrmatch(&self) -> ADRMATCHR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                ADRMATCHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Contains the address match value."]
            #[inline]
            pub fn adrmatch(&mut self) -> _ADRMATCHW {
                _ADRMATCHW { w: self }
            }
        }
    }
    #[doc = "RS-485/EIA-485 direction control delay."]
    pub struct RS485DLY {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RS-485/EIA-485 direction control delay."]
    pub mod rs485dly {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RS485DLY {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DLYR {
            bits: u8,
        }
        impl DLYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DLYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DLYW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter."]
            #[inline]
            pub fn dly(&self) -> DLYR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DLYR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Contains the direction control (RTS or DTR) delay value. This register works in conjunction with an 8-bit counter."]
            #[inline]
            pub fn dly(&mut self) -> _DLYW {
                _DLYW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx 16-bit timer/counters (CT16B0/1) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct CT16B0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT16B0 {}
impl CT16B0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ct16b0::RegisterBlock {
        0x4000_c000 as *const _
    }
}
impl Deref for CT16B0 {
    type Target = ct16b0::RegisterBlock;
    fn deref(&self) -> &ct16b0::RegisterBlock {
        unsafe { &*CT16B0::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx 16-bit timer/counters (CT16B0/1) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod ct16b0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
        pub bir: BIR,
        #[doc = "0x04 - Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
        pub btcr: BTCR,
        #[doc = "0x08 - Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
        pub btc: BTC,
        #[doc = "0x0c - Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
        pub bpr: BPR,
        #[doc = "0x10 - Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
        pub bpc: BPC,
        #[doc = "0x14 - Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
        pub bmcr: BMCR,
        #[doc = "0x18 - Match Register 0 (MR0). MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
        pub bmr: [BMR; 4],
        #[doc = "0x28 - Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
        pub bccr: BCCR,
        #[doc = "0x2c - Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input."]
        pub bcr0: BCR0,
        _reserved0: [u8; 12usize],
        #[doc = "0x3c - External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0]."]
        pub bemr: BEMR,
        _reserved1: [u8; 48usize],
        #[doc = "0x70 - Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
        pub bctcr: BCTCR,
        #[doc = "0x74 - PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0]."]
        pub bpwmc: BPWMC,
    }
    #[doc = "Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
    pub struct BIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
    pub mod bir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR0INTR {
            bits: bool,
        }
        impl MR0INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR1INTR {
            bits: bool,
        }
        impl MR1INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR2INTR {
            bits: bool,
        }
        impl MR2INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR3INTR {
            bits: bool,
        }
        impl MR3INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CR0INTR {
            bits: bool,
        }
        impl CR0INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CR0INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CR0INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt flag for match channel 0."]
            #[inline]
            pub fn mr0int(&self) -> MR0INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR0INTR { bits }
            }
            #[doc = "Bit 1 - Interrupt flag for match channel 1."]
            #[inline]
            pub fn mr1int(&self) -> MR1INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR1INTR { bits }
            }
            #[doc = "Bit 2 - Interrupt flag for match channel 2."]
            #[inline]
            pub fn mr2int(&self) -> MR2INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR2INTR { bits }
            }
            #[doc = "Bit 3 - Interrupt flag for match channel 3."]
            #[inline]
            pub fn mr3int(&self) -> MR3INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR3INTR { bits }
            }
            #[doc = "Bit 4 - Interrupt flag for capture channel 0 event."]
            #[inline]
            pub fn cr0int(&self) -> CR0INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CR0INTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt flag for match channel 0."]
            #[inline]
            pub fn mr0int(&mut self) -> _MR0INTW {
                _MR0INTW { w: self }
            }
            #[doc = "Bit 1 - Interrupt flag for match channel 1."]
            #[inline]
            pub fn mr1int(&mut self) -> _MR1INTW {
                _MR1INTW { w: self }
            }
            #[doc = "Bit 2 - Interrupt flag for match channel 2."]
            #[inline]
            pub fn mr2int(&mut self) -> _MR2INTW {
                _MR2INTW { w: self }
            }
            #[doc = "Bit 3 - Interrupt flag for match channel 3."]
            #[inline]
            pub fn mr3int(&mut self) -> _MR3INTW {
                _MR3INTW { w: self }
            }
            #[doc = "Bit 4 - Interrupt flag for capture channel 0 event."]
            #[inline]
            pub fn cr0int(&mut self) -> _CR0INTW {
                _CR0INTW { w: self }
            }
        }
    }
    #[doc = "Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
    pub struct BTCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
    pub mod btcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BTCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CENR {
            bits: bool,
        }
        impl CENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRESETR {
            bits: bool,
        }
        impl CRESETR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRESETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRESETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled."]
            #[inline]
            pub fn cen(&self) -> CENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CENR { bits }
            }
            #[doc = "Bit 1 - When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero."]
            #[inline]
            pub fn creset(&self) -> CRESETR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CRESETR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled."]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
            #[doc = "Bit 1 - When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero."]
            #[inline]
            pub fn creset(&mut self) -> _CRESETW {
                _CRESETW { w: self }
            }
        }
    }
    #[doc = "Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
    pub struct BTC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer Counter (TC). The 16-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
    pub mod btc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BTC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCR {
            bits: u16,
        }
        impl TCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Timer counter value."]
            #[inline]
            pub fn tc(&self) -> TCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                TCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Timer counter value."]
            #[inline]
            pub fn tc(&mut self) -> _TCW {
                _TCW { w: self }
            }
        }
    }
    #[doc = "Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
    pub struct BPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
    pub mod bpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRR {
            bits: u16,
        }
        impl PRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescale max value."]
            #[inline]
            pub fn pr(&self) -> PRR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescale max value."]
            #[inline]
            pub fn pr(&mut self) -> _PRW {
                _PRW { w: self }
            }
        }
    }
    #[doc = "Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
    pub struct BPC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Prescale Counter (PC). The 16-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
    pub mod bpc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PCR {
            bits: u16,
        }
        impl PCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Prescale counter value."]
            #[inline]
            pub fn pc(&self) -> PCR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Prescale counter value."]
            #[inline]
            pub fn pc(&mut self) -> _PCW {
                _PCW { w: self }
            }
        }
    }
    #[doc = "Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
    pub struct BMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
    pub mod bmcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MR0I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0IR::ENABLED => true,
                    MR0IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0IR {
                match value {
                    true => MR0IR::ENABLED,
                    false => MR0IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR0R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0RR::ENABLED => true,
                    MR0RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0RR {
                match value {
                    true => MR0RR::ENABLED,
                    false => MR0RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR0S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0SR::ENABLED => true,
                    MR0SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0SR {
                match value {
                    true => MR0SR::ENABLED,
                    false => MR0SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1IR::ENABLED => true,
                    MR1IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1IR {
                match value {
                    true => MR1IR::ENABLED,
                    false => MR1IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1RR::ENABLED => true,
                    MR1RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1RR {
                match value {
                    true => MR1RR::ENABLED,
                    false => MR1RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1SR::ENABLED => true,
                    MR1SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1SR {
                match value {
                    true => MR1SR::ENABLED,
                    false => MR1SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2IR::ENABLED => true,
                    MR2IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2IR {
                match value {
                    true => MR2IR::ENABLED,
                    false => MR2IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2RR::ENABLED => true,
                    MR2RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2RR {
                match value {
                    true => MR2RR::ENABLED,
                    false => MR2RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2SR::ENABLED => true,
                    MR2SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2SR {
                match value {
                    true => MR2SR::ENABLED,
                    false => MR2SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3IR::ENABLED => true,
                    MR3IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3IR {
                match value {
                    true => MR3IR::ENABLED,
                    false => MR3IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3RR::ENABLED => true,
                    MR3RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3RR {
                match value {
                    true => MR3RR::ENABLED,
                    false => MR3RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3SR::ENABLED => true,
                    MR3SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3SR {
                match value {
                    true => MR3SR::ENABLED,
                    false => MR3SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3SR::DISABLED
            }
        }
        #[doc = "Values that can be written to the field `MR0I`"]
        pub enum MR0IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0IW::ENABLED => true,
                    MR0IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR0R`"]
        pub enum MR0RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0RW::ENABLED => true,
                    MR0RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR0S`"]
        pub enum MR0SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0SW::ENABLED => true,
                    MR0SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1I`"]
        pub enum MR1IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1IW::ENABLED => true,
                    MR1IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1R`"]
        pub enum MR1RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1RW::ENABLED => true,
                    MR1RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1S`"]
        pub enum MR1SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1SW::ENABLED => true,
                    MR1SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2I`"]
        pub enum MR2IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2IW::ENABLED => true,
                    MR2IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2R`"]
        pub enum MR2RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2RW::ENABLED => true,
                    MR2RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2S`"]
        pub enum MR2SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2SW::ENABLED => true,
                    MR2SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3I`"]
        pub enum MR3IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3IW::ENABLED => true,
                    MR3IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3R`"]
        pub enum MR3RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3RW::ENABLED => true,
                    MR3RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3S`"]
        pub enum MR3SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3SW::ENABLED => true,
                    MR3SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC."]
            #[inline]
            pub fn mr0i(&self) -> MR0IR {
                MR0IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it."]
            #[inline]
            pub fn mr0r(&self) -> MR0RR {
                MR0RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC."]
            #[inline]
            pub fn mr0s(&self) -> MR0SR {
                MR0SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC."]
            #[inline]
            pub fn mr1i(&self) -> MR1IR {
                MR1IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it."]
            #[inline]
            pub fn mr1r(&self) -> MR1RR {
                MR1RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC."]
            #[inline]
            pub fn mr1s(&self) -> MR1SR {
                MR1SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC."]
            #[inline]
            pub fn mr2i(&self) -> MR2IR {
                MR2IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it."]
            #[inline]
            pub fn mr2r(&self) -> MR2RR {
                MR2RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC."]
            #[inline]
            pub fn mr2s(&self) -> MR2SR {
                MR2SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC."]
            #[inline]
            pub fn mr3i(&self) -> MR3IR {
                MR3IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it."]
            #[inline]
            pub fn mr3r(&self) -> MR3RR {
                MR3RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC."]
            #[inline]
            pub fn mr3s(&self) -> MR3SR {
                MR3SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC."]
            #[inline]
            pub fn mr0i(&mut self) -> _MR0IW {
                _MR0IW { w: self }
            }
            #[doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it."]
            #[inline]
            pub fn mr0r(&mut self) -> _MR0RW {
                _MR0RW { w: self }
            }
            #[doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC."]
            #[inline]
            pub fn mr0s(&mut self) -> _MR0SW {
                _MR0SW { w: self }
            }
            #[doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC."]
            #[inline]
            pub fn mr1i(&mut self) -> _MR1IW {
                _MR1IW { w: self }
            }
            #[doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it."]
            #[inline]
            pub fn mr1r(&mut self) -> _MR1RW {
                _MR1RW { w: self }
            }
            #[doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC."]
            #[inline]
            pub fn mr1s(&mut self) -> _MR1SW {
                _MR1SW { w: self }
            }
            #[doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC."]
            #[inline]
            pub fn mr2i(&mut self) -> _MR2IW {
                _MR2IW { w: self }
            }
            #[doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it."]
            #[inline]
            pub fn mr2r(&mut self) -> _MR2RW {
                _MR2RW { w: self }
            }
            #[doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC."]
            #[inline]
            pub fn mr2s(&mut self) -> _MR2SW {
                _MR2SW { w: self }
            }
            #[doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC."]
            #[inline]
            pub fn mr3i(&mut self) -> _MR3IW {
                _MR3IW { w: self }
            }
            #[doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it."]
            #[inline]
            pub fn mr3r(&mut self) -> _MR3RW {
                _MR3RW { w: self }
            }
            #[doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC."]
            #[inline]
            pub fn mr3s(&mut self) -> _MR3SW {
                _MR3SW { w: self }
            }
        }
    }
    #[doc = "Match Register 0 (MR0). MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
    pub struct BMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Match Register 0 (MR0). MR0 can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
    pub mod bmr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHR {
            bits: u16,
        }
        impl MATCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Timer counter match value."]
            #[inline]
            pub fn match_(&self) -> MATCHR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                MATCHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Timer counter match value."]
            #[inline]
            pub fn match_(&mut self) -> _MATCHW {
                _MATCHW { w: self }
            }
        }
    }
    #[doc = "Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
    pub struct BCCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
    pub mod bccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CAP0RE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0RER {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0RER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0RER::ENABLED => true,
                    CAP0RER::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0RER {
                match value {
                    true => CAP0RER::ENABLED,
                    false => CAP0RER::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0RER::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0RER::DISABLED
            }
        }
        #[doc = "Possible values of the field `CAP0FE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0FER {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0FER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0FER::ENABLED => true,
                    CAP0FER::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0FER {
                match value {
                    true => CAP0FER::ENABLED,
                    false => CAP0FER::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0FER::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0FER::DISABLED
            }
        }
        #[doc = "Possible values of the field `CAP0I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0IR::ENABLED => true,
                    CAP0IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0IR {
                match value {
                    true => CAP0IR::ENABLED,
                    false => CAP0IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0IR::DISABLED
            }
        }
        #[doc = "Values that can be written to the field `CAP0RE`"]
        pub enum CAP0REW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0REW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0REW::ENABLED => true,
                    CAP0REW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0REW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0REW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0REW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0REW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0REW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP0FE`"]
        pub enum CAP0FEW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0FEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0FEW::ENABLED => true,
                    CAP0FEW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0FEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0FEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0FEW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0FEW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP0I`"]
        pub enum CAP0IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0IW::ENABLED => true,
                    CAP0IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Capture on CT16Bn_CAP0 rising edge: a sequence of 0 then 1 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0re(&self) -> CAP0RER {
                CAP0RER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture on CT16Bn_CAP0 falling edge: a sequence of 1 then 0 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0fe(&self) -> CAP0FER {
                CAP0FER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Interrupt on CT16Bn_CAP0 event: a CR0 load due to a CT16Bn_CAP0 event will generate an interrupt."]
            #[inline]
            pub fn cap0i(&self) -> CAP0IR {
                CAP0IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture on CT16Bn_CAP0 rising edge: a sequence of 0 then 1 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0re(&mut self) -> _CAP0REW {
                _CAP0REW { w: self }
            }
            #[doc = "Bit 1 - Capture on CT16Bn_CAP0 falling edge: a sequence of 1 then 0 on CT16Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0fe(&mut self) -> _CAP0FEW {
                _CAP0FEW { w: self }
            }
            #[doc = "Bit 2 - Interrupt on CT16Bn_CAP0 event: a CR0 load due to a CT16Bn_CAP0 event will generate an interrupt."]
            #[inline]
            pub fn cap0i(&mut self) -> _CAP0IW {
                _CAP0IW { w: self }
            }
        }
    }
    #[doc = "Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input."]
    pub struct BCR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT16B0_CAP0 input."]
    pub mod bcr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BCR0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPR {
            bits: u16,
        }
        impl CAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Timer counter capture value."]
            #[inline]
            pub fn cap(&self) -> CAPR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                CAPR { bits }
            }
        }
    }
    #[doc = "External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0]."]
    pub struct BEMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External Match Register (EMR). The EMR controls the match function and the external match pins CT16B0_MAT[2:0]."]
    pub mod bemr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BEMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM0R {
            bits: bool,
        }
        impl EM0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM1R {
            bits: bool,
        }
        impl EM1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM2R {
            bits: bool,
        }
        impl EM2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM3R {
            bits: bool,
        }
        impl EM3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `EMC0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC0R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC0R::DO_NOTHING => 0,
                    EMC0R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC0R::SET_THE_CORRESPONDIN => 0x02,
                    EMC0R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC0R {
                match value {
                    0 => EMC0R::DO_NOTHING,
                    1 => EMC0R::CLEAR_THE_CORRESPOND,
                    2 => EMC0R::SET_THE_CORRESPONDIN,
                    3 => EMC0R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC0R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC0R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC0R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC0R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC1R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC1R::DO_NOTHING => 0,
                    EMC1R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC1R::SET_THE_CORRESPONDIN => 0x02,
                    EMC1R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC1R {
                match value {
                    0 => EMC1R::DO_NOTHING,
                    1 => EMC1R::CLEAR_THE_CORRESPOND,
                    2 => EMC1R::SET_THE_CORRESPONDIN,
                    3 => EMC1R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC1R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC1R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC1R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC1R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC2R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC2R::DO_NOTHING => 0,
                    EMC2R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC2R::SET_THE_CORRESPONDIN => 0x02,
                    EMC2R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC2R {
                match value {
                    0 => EMC2R::DO_NOTHING,
                    1 => EMC2R::CLEAR_THE_CORRESPOND,
                    2 => EMC2R::SET_THE_CORRESPONDIN,
                    3 => EMC2R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC2R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC2R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC2R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC2R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC3R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC3R::DO_NOTHING => 0,
                    EMC3R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC3R::SET_THE_CORRESPONDIN => 0x02,
                    EMC3R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC3R {
                match value {
                    0 => EMC3R::DO_NOTHING,
                    1 => EMC3R::CLEAR_THE_CORRESPOND,
                    2 => EMC3R::SET_THE_CORRESPONDIN,
                    3 => EMC3R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC3R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC3R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC3R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC3R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC0`"]
        pub enum EMC0W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC0W::DO_NOTHING => 0,
                    EMC0W::CLEAR_THE_CORRESPOND => 1,
                    EMC0W::SET_THE_CORRESPONDIN => 2,
                    EMC0W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC0W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC0W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC0W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC0W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC1`"]
        pub enum EMC1W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC1W::DO_NOTHING => 0,
                    EMC1W::CLEAR_THE_CORRESPOND => 1,
                    EMC1W::SET_THE_CORRESPONDIN => 2,
                    EMC1W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC1W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC1W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC1W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC1W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC2`"]
        pub enum EMC2W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC2W::DO_NOTHING => 0,
                    EMC2W::CLEAR_THE_CORRESPOND => 1,
                    EMC2W::SET_THE_CORRESPONDIN => 2,
                    EMC2W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC2W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC2W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC2W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC2W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC3`"]
        pub enum EMC3W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC3W::DO_NOTHING => 0,
                    EMC3W::CLEAR_THE_CORRESPOND => 1,
                    EMC3W::SET_THE_CORRESPONDIN => 2,
                    EMC3W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC3W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT16Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC3W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT16Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC3W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC3W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em0(&self) -> EM0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM0R { bits }
            }
            #[doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT16B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em1(&self) -> EM1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM1R { bits }
            }
            #[doc = "Bit 2 - External Match 2. This bit reflects the state of output match channel 2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. Note that on counter/timer 0 this match channel is not pinned out. This bit is driven to the CT16B1_MAT2 pin if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em2(&self) -> EM2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM2R { bits }
            }
            #[doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. There is no output pin available for this channel on either of the 16-bit timers."]
            #[inline]
            pub fn em3(&self) -> EM3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM3R { bits }
            }
            #[doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0."]
            #[inline]
            pub fn emc0(&self) -> EMC0R {
                EMC0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1."]
            #[inline]
            pub fn emc1(&self) -> EMC1R {
                EMC1R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2."]
            #[inline]
            pub fn emc2(&self) -> EMC2R {
                EMC2R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3."]
            #[inline]
            pub fn emc3(&self) -> EMC3R {
                EMC3R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Match 0. This bit reflects the state of output CT16B0_MAT0/CT16B1_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT16B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em0(&mut self) -> _EM0W {
                _EM0W { w: self }
            }
            #[doc = "Bit 1 - External Match 1. This bit reflects the state of output CT16B0_MAT1/CT16B1_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT16B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em1(&mut self) -> _EM1W {
                _EM1W { w: self }
            }
            #[doc = "Bit 2 - External Match 2. This bit reflects the state of output match channel 2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. Note that on counter/timer 0 this match channel is not pinned out. This bit is driven to the CT16B1_MAT2 pin if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em2(&mut self) -> _EM2W {
                _EM2W { w: self }
            }
            #[doc = "Bit 3 - External Match 3. This bit reflects the state of output of match channel 3. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. There is no output pin available for this channel on either of the 16-bit timers."]
            #[inline]
            pub fn em3(&mut self) -> _EM3W {
                _EM3W { w: self }
            }
            #[doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0."]
            #[inline]
            pub fn emc0(&mut self) -> _EMC0W {
                _EMC0W { w: self }
            }
            #[doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1."]
            #[inline]
            pub fn emc1(&mut self) -> _EMC1W {
                _EMC1W { w: self }
            }
            #[doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2."]
            #[inline]
            pub fn emc2(&mut self) -> _EMC2W {
                _EMC2W { w: self }
            }
            #[doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3."]
            #[inline]
            pub fn emc3(&mut self) -> _EMC3W {
                _EMC3W { w: self }
            }
        }
    }
    #[doc = "Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
    pub struct BCTCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
    pub mod bctcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCTCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CTM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTMR {
            #[doc = "Timer Mode: every rising PCLK edge"]
            TIMER_MODE_EVERY_RI,
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            RISING,
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            FALLING,
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            BOTHEDGES,
        }
        impl CTMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CTMR::TIMER_MODE_EVERY_RI => 0,
                    CTMR::RISING => 0x01,
                    CTMR::FALLING => 0x02,
                    CTMR::BOTHEDGES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CTMR {
                match value {
                    0 => CTMR::TIMER_MODE_EVERY_RI,
                    1 => CTMR::RISING,
                    2 => CTMR::FALLING,
                    3 => CTMR::BOTHEDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`"]
            #[inline]
            pub fn is_timer_mode_every_ri(&self) -> bool {
                *self == CTMR::TIMER_MODE_EVERY_RI
            }
            #[doc = "Checks if the value of the field is `RISING`"]
            #[inline]
            pub fn is_rising(&self) -> bool {
                *self == CTMR::RISING
            }
            #[doc = "Checks if the value of the field is `FALLING`"]
            #[inline]
            pub fn is_falling(&self) -> bool {
                *self == CTMR::FALLING
            }
            #[doc = "Checks if the value of the field is `BOTHEDGES`"]
            #[inline]
            pub fn is_bothedges(&self) -> bool {
                *self == CTMR::BOTHEDGES
            }
        }
        #[doc = "Possible values of the field `CIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CISR {
            #[doc = "CT16Bn_CAP0"]
            CT16BN_CAP0,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CISR::CT16BN_CAP0 => 0,
                    CISR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CISR {
                match value {
                    0 => CISR::CT16BN_CAP0,
                    i => CISR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CT16BN_CAP0`"]
            #[inline]
            pub fn is_ct16bn_cap0(&self) -> bool {
                *self == CISR::CT16BN_CAP0
            }
        }
        #[doc = "Values that can be written to the field `CTM`"]
        pub enum CTMW {
            #[doc = "Timer Mode: every rising PCLK edge"]
            TIMER_MODE_EVERY_RI,
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            RISING,
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            FALLING,
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            BOTHEDGES,
        }
        impl CTMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CTMW::TIMER_MODE_EVERY_RI => 0,
                    CTMW::RISING => 1,
                    CTMW::FALLING => 2,
                    CTMW::BOTHEDGES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer Mode: every rising PCLK edge"]
            #[inline]
            pub fn timer_mode_every_ri(self) -> &'a mut W {
                self.variant(CTMW::TIMER_MODE_EVERY_RI)
            }
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn rising(self) -> &'a mut W {
                self.variant(CTMW::RISING)
            }
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn falling(self) -> &'a mut W {
                self.variant(CTMW::FALLING)
            }
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn bothedges(self) -> &'a mut W {
                self.variant(CTMW::BOTHEDGES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CIS`"]
        pub enum CISW {
            #[doc = "CT16Bn_CAP0"]
            CT16BN_CAP0,
        }
        impl CISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CISW::CT16BN_CAP0 => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CISW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CT16Bn_CAP0"]
            #[inline]
            pub fn ct16bn_cap0(self) -> &'a mut W {
                self.variant(CISW::CT16BN_CAP0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC)."]
            #[inline]
            pub fn ctm(&self) -> CTMR {
                CTMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected in the CTCR register, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000."]
            #[inline]
            pub fn cis(&self) -> CISR {
                CISR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC)."]
            #[inline]
            pub fn ctm(&mut self) -> _CTMW {
                _CTMW { w: self }
            }
            #[doc = "Bits 2:3 - Count Input Select. In counter mode (when bits 1:0 in this register are not 00), these bits select which CAP pin is sampled for clocking. Note: If Counter mode is selected in the CTCR register, bits 2:0 in the Capture Control Register (CCR) must be programmed as 000."]
            #[inline]
            pub fn cis(&mut self) -> _CISW {
                _CISW { w: self }
            }
        }
    }
    #[doc = "PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0]."]
    pub struct BPWMC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT16B0_MAT[2:0]."]
    pub mod bpwmc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPWMC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PWMEN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN0R {
            #[doc = "CT16Bn_MAT0 is controlled by EM0."]
            EM0,
            #[doc = "PWM mode is enabled for CT16Bn_MAT0."]
            PWM,
        }
        impl PWMEN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN0R::EM0 => false,
                    PWMEN0R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN0R {
                match value {
                    false => PWMEN0R::EM0,
                    true => PWMEN0R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM0`"]
            #[inline]
            pub fn is_em0(&self) -> bool {
                *self == PWMEN0R::EM0
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN0R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN1R {
            #[doc = "CT16Bn_MAT1 is controlled by EM1."]
            EM1,
            #[doc = "PWM mode is enabled for CT16Bn_MAT1."]
            PWM,
        }
        impl PWMEN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN1R::EM1 => false,
                    PWMEN1R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN1R {
                match value {
                    false => PWMEN1R::EM1,
                    true => PWMEN1R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM1`"]
            #[inline]
            pub fn is_em1(&self) -> bool {
                *self == PWMEN1R::EM1
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN1R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN2R {
            #[doc = "Match channel 2 or pin CT16B0_MAT2 is controlled by EM2. Match channel 2 is not pinned out on timer 1."]
            EM2,
            #[doc = "PWM mode is enabled for match channel 2 or pin CT16B0_MAT2."]
            PWM,
        }
        impl PWMEN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN2R::EM2 => false,
                    PWMEN2R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN2R {
                match value {
                    false => PWMEN2R::EM2,
                    true => PWMEN2R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM2`"]
            #[inline]
            pub fn is_em2(&self) -> bool {
                *self == PWMEN2R::EM2
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN2R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN3R {
            #[doc = "Match channel 3 match channel 3 is controlled by EM3."]
            EM3,
            #[doc = "PWM mode is enabled for match channel 3match channel 3."]
            PWM,
        }
        impl PWMEN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN3R::EM3 => false,
                    PWMEN3R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN3R {
                match value {
                    false => PWMEN3R::EM3,
                    true => PWMEN3R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM3`"]
            #[inline]
            pub fn is_em3(&self) -> bool {
                *self == PWMEN3R::EM3
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN3R::PWM
            }
        }
        #[doc = "Values that can be written to the field `PWMEN0`"]
        pub enum PWMEN0W {
            #[doc = "CT16Bn_MAT0 is controlled by EM0."]
            EM0,
            #[doc = "PWM mode is enabled for CT16Bn_MAT0."]
            PWM,
        }
        impl PWMEN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN0W::EM0 => false,
                    PWMEN0W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT16Bn_MAT0 is controlled by EM0."]
            #[inline]
            pub fn em0(self) -> &'a mut W {
                self.variant(PWMEN0W::EM0)
            }
            #[doc = "PWM mode is enabled for CT16Bn_MAT0."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN0W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN1`"]
        pub enum PWMEN1W {
            #[doc = "CT16Bn_MAT1 is controlled by EM1."]
            EM1,
            #[doc = "PWM mode is enabled for CT16Bn_MAT1."]
            PWM,
        }
        impl PWMEN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN1W::EM1 => false,
                    PWMEN1W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT16Bn_MAT1 is controlled by EM1."]
            #[inline]
            pub fn em1(self) -> &'a mut W {
                self.variant(PWMEN1W::EM1)
            }
            #[doc = "PWM mode is enabled for CT16Bn_MAT1."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN1W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN2`"]
        pub enum PWMEN2W {
            #[doc = "Match channel 2 or pin CT16B0_MAT2 is controlled by EM2. Match channel 2 is not pinned out on timer 1."]
            EM2,
            #[doc = "PWM mode is enabled for match channel 2 or pin CT16B0_MAT2."]
            PWM,
        }
        impl PWMEN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN2W::EM2 => false,
                    PWMEN2W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Match channel 2 or pin CT16B0_MAT2 is controlled by EM2. Match channel 2 is not pinned out on timer 1."]
            #[inline]
            pub fn em2(self) -> &'a mut W {
                self.variant(PWMEN2W::EM2)
            }
            #[doc = "PWM mode is enabled for match channel 2 or pin CT16B0_MAT2."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN2W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN3`"]
        pub enum PWMEN3W {
            #[doc = "Match channel 3 match channel 3 is controlled by EM3."]
            EM3,
            #[doc = "PWM mode is enabled for match channel 3match channel 3."]
            PWM,
        }
        impl PWMEN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN3W::EM3 => false,
                    PWMEN3W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Match channel 3 match channel 3 is controlled by EM3."]
            #[inline]
            pub fn em3(self) -> &'a mut W {
                self.variant(PWMEN3W::EM3)
            }
            #[doc = "PWM mode is enabled for match channel 3match channel 3."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN3W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PWM channel0 enable"]
            #[inline]
            pub fn pwmen0(&self) -> PWMEN0R {
                PWMEN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - PWM channel1 enable"]
            #[inline]
            pub fn pwmen1(&self) -> PWMEN1R {
                PWMEN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - PWM channel2 enable"]
            #[inline]
            pub fn pwmen2(&self) -> PWMEN2R {
                PWMEN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - PWM channel3 enable Note: It is recommended to use match channel 3 to set the PWM cycle because it is not pinned out."]
            #[inline]
            pub fn pwmen3(&self) -> PWMEN3R {
                PWMEN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PWM channel0 enable"]
            #[inline]
            pub fn pwmen0(&mut self) -> _PWMEN0W {
                _PWMEN0W { w: self }
            }
            #[doc = "Bit 1 - PWM channel1 enable"]
            #[inline]
            pub fn pwmen1(&mut self) -> _PWMEN1W {
                _PWMEN1W { w: self }
            }
            #[doc = "Bit 2 - PWM channel2 enable"]
            #[inline]
            pub fn pwmen2(&mut self) -> _PWMEN2W {
                _PWMEN2W { w: self }
            }
            #[doc = "Bit 3 - PWM channel3 enable Note: It is recommended to use match channel 3 to set the PWM cycle because it is not pinned out."]
            #[inline]
            pub fn pwmen3(&mut self) -> _PWMEN3W {
                _PWMEN3W { w: self }
            }
        }
    }
}
#[doc = "CT16B1"]
pub struct CT16B1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT16B1 {}
impl CT16B1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ct16b0::RegisterBlock {
        0x4001_0000 as *const _
    }
}
impl Deref for CT16B1 {
    type Target = ct16b0::RegisterBlock;
    fn deref(&self) -> &ct16b0::RegisterBlock {
        unsafe { &*CT16B1::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx 32-bit timer/counters (CT32B0/1) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct CT32B0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT32B0 {}
impl CT32B0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ct32b0::RegisterBlock {
        0x4001_4000 as *const _
    }
}
impl Deref for CT32B0 {
    type Target = ct32b0::RegisterBlock;
    fn deref(&self) -> &ct32b0::RegisterBlock {
        unsafe { &*CT32B0::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx 32-bit timer/counters (CT32B0/1) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod ct32b0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
        pub bir: BIR,
        #[doc = "0x04 - Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
        pub btcr: BTCR,
        #[doc = "0x08 - Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
        pub btc: BTC,
        #[doc = "0x0c - Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
        pub bpr: BPR,
        #[doc = "0x10 - Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
        pub bpc: BPC,
        #[doc = "0x14 - Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
        pub bmcr: BMCR,
        #[doc = "0x18 - Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
        pub bmr: [BMR; 4],
        #[doc = "0x28 - Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
        pub bccr: BCCR,
        #[doc = "0x2c - Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input."]
        pub bcr0: BCR0,
        _reserved0: [u8; 12usize],
        #[doc = "0x3c - External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0]."]
        pub bemr: BEMR,
        _reserved1: [u8; 48usize],
        #[doc = "0x70 - Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
        pub bctcr: BCTCR,
        #[doc = "0x74 - PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0]."]
        pub bpwmc: BPWMC,
    }
    #[doc = "Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
    pub struct BIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Register (IR). The IR can be written to clear interrupts. The IR can be read to identify which of five possible interrupt sources are pending."]
    pub mod bir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR0INTR {
            bits: bool,
        }
        impl MR0INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR1INTR {
            bits: bool,
        }
        impl MR1INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR2INTR {
            bits: bool,
        }
        impl MR2INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MR3INTR {
            bits: bool,
        }
        impl MR3INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CR0INTR {
            bits: bool,
        }
        impl CR0INTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CR0INTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CR0INTW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt flag for match channel 0."]
            #[inline]
            pub fn mr0int(&self) -> MR0INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR0INTR { bits }
            }
            #[doc = "Bit 1 - Interrupt flag for match channel 1."]
            #[inline]
            pub fn mr1int(&self) -> MR1INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR1INTR { bits }
            }
            #[doc = "Bit 2 - Interrupt flag for match channel 2."]
            #[inline]
            pub fn mr2int(&self) -> MR2INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR2INTR { bits }
            }
            #[doc = "Bit 3 - Interrupt flag for match channel 3."]
            #[inline]
            pub fn mr3int(&self) -> MR3INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MR3INTR { bits }
            }
            #[doc = "Bit 4 - Interrupt flag for capture channel 0 event."]
            #[inline]
            pub fn cr0int(&self) -> CR0INTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CR0INTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt flag for match channel 0."]
            #[inline]
            pub fn mr0int(&mut self) -> _MR0INTW {
                _MR0INTW { w: self }
            }
            #[doc = "Bit 1 - Interrupt flag for match channel 1."]
            #[inline]
            pub fn mr1int(&mut self) -> _MR1INTW {
                _MR1INTW { w: self }
            }
            #[doc = "Bit 2 - Interrupt flag for match channel 2."]
            #[inline]
            pub fn mr2int(&mut self) -> _MR2INTW {
                _MR2INTW { w: self }
            }
            #[doc = "Bit 3 - Interrupt flag for match channel 3."]
            #[inline]
            pub fn mr3int(&mut self) -> _MR3INTW {
                _MR3INTW { w: self }
            }
            #[doc = "Bit 4 - Interrupt flag for capture channel 0 event."]
            #[inline]
            pub fn cr0int(&mut self) -> _CR0INTW {
                _CR0INTW { w: self }
            }
        }
    }
    #[doc = "Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
    pub struct BTCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer Control Register (TCR). The TCR is used to control the Timer Counter functions. The Timer Counter can be disabled or reset through the TCR."]
    pub mod btcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BTCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CENR {
            bits: bool,
        }
        impl CENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CRESR {
            bits: bool,
        }
        impl CRESR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _CENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CRESW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CRESW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled."]
            #[inline]
            pub fn cen(&self) -> CENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CENR { bits }
            }
            #[doc = "Bit 1 - When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero."]
            #[inline]
            pub fn cres(&self) -> CRESR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CRESR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - When one, the Timer Counter and Prescale Counter are enabled for counting. When zero, the counters are disabled."]
            #[inline]
            pub fn cen(&mut self) -> _CENW {
                _CENW { w: self }
            }
            #[doc = "Bit 1 - When one, the Timer Counter and the Prescale Counter are synchronously reset on the next positive edge of PCLK. The counters remain reset until TCR[1] is returned to zero."]
            #[inline]
            pub fn cres(&mut self) -> _CRESW {
                _CRESW { w: self }
            }
        }
    }
    #[doc = "Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
    pub struct BTC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Timer Counter (TC). The 32-bit TC is incremented every PR+1 cycles of PCLK. The TC is controlled through the TCR."]
    pub mod btc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BTC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TCR {
            bits: u32,
        }
        impl TCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Timer counter value."]
            #[inline]
            pub fn tc(&self) -> TCR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                TCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Timer counter value."]
            #[inline]
            pub fn tc(&mut self) -> _TCW {
                _TCW { w: self }
            }
        }
    }
    #[doc = "Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
    pub struct BPR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Prescale Register (PR). When the Prescale Counter (below) is equal to this value, the next clock increments the TC and clears the PC."]
    pub mod bpr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PRR {
            bits: u32,
        }
        impl PRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Prescale value."]
            #[inline]
            pub fn pr(&self) -> PRR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Prescale value."]
            #[inline]
            pub fn pr(&mut self) -> _PRW {
                _PRW { w: self }
            }
        }
    }
    #[doc = "Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
    pub struct BPC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Prescale Counter (PC). The 32-bit PC is a counter which is incremented to the value stored in PR. When the value in PR is reached, the TC is incremented and the PC is cleared. The PC is observable and controllable through the bus interface."]
    pub mod bpc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct PCR {
            bits: u32,
        }
        impl PCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _PCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PCW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Prescale counter value."]
            #[inline]
            pub fn pc(&self) -> PCR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                PCR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Prescale counter value."]
            #[inline]
            pub fn pc(&mut self) -> _PCW {
                _PCW { w: self }
            }
        }
    }
    #[doc = "Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
    pub struct BMCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Match Control Register (MCR). The MCR is used to control if an interrupt is generated and if the TC is reset when a Match occurs."]
    pub mod bmcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BMCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MR0I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0IR::ENABLED => true,
                    MR0IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0IR {
                match value {
                    true => MR0IR::ENABLED,
                    false => MR0IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR0R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0RR::ENABLED => true,
                    MR0RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0RR {
                match value {
                    true => MR0RR::ENABLED,
                    false => MR0RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR0S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR0SR::ENABLED => true,
                    MR0SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR0SR {
                match value {
                    true => MR0SR::ENABLED,
                    false => MR0SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR0SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR0SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1IR::ENABLED => true,
                    MR1IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1IR {
                match value {
                    true => MR1IR::ENABLED,
                    false => MR1IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1RR::ENABLED => true,
                    MR1RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1RR {
                match value {
                    true => MR1RR::ENABLED,
                    false => MR1RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR1S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR1SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR1SR::ENABLED => true,
                    MR1SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR1SR {
                match value {
                    true => MR1SR::ENABLED,
                    false => MR1SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR1SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR1SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2IR::ENABLED => true,
                    MR2IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2IR {
                match value {
                    true => MR2IR::ENABLED,
                    false => MR2IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2RR::ENABLED => true,
                    MR2RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2RR {
                match value {
                    true => MR2RR::ENABLED,
                    false => MR2RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR2S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR2SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR2SR::ENABLED => true,
                    MR2SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR2SR {
                match value {
                    true => MR2SR::ENABLED,
                    false => MR2SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR2SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR2SR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3IR::ENABLED => true,
                    MR3IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3IR {
                match value {
                    true => MR3IR::ENABLED,
                    false => MR3IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3IR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3R`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3RR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3RR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3RR::ENABLED => true,
                    MR3RR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3RR {
                match value {
                    true => MR3RR::ENABLED,
                    false => MR3RR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3RR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3RR::DISABLED
            }
        }
        #[doc = "Possible values of the field `MR3S`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR3SR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3SR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MR3SR::ENABLED => true,
                    MR3SR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MR3SR {
                match value {
                    true => MR3SR::ENABLED,
                    false => MR3SR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == MR3SR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == MR3SR::DISABLED
            }
        }
        #[doc = "Values that can be written to the field `MR0I`"]
        pub enum MR0IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0IW::ENABLED => true,
                    MR0IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR0R`"]
        pub enum MR0RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0RW::ENABLED => true,
                    MR0RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR0S`"]
        pub enum MR0SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR0SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR0SW::ENABLED => true,
                    MR0SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR0SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR0SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR0SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR0SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR0SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1I`"]
        pub enum MR1IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1IW::ENABLED => true,
                    MR1IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1R`"]
        pub enum MR1RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1RW::ENABLED => true,
                    MR1RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR1S`"]
        pub enum MR1SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR1SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR1SW::ENABLED => true,
                    MR1SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR1SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR1SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR1SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR1SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR1SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2I`"]
        pub enum MR2IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2IW::ENABLED => true,
                    MR2IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2R`"]
        pub enum MR2RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2RW::ENABLED => true,
                    MR2RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR2S`"]
        pub enum MR2SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR2SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR2SW::ENABLED => true,
                    MR2SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR2SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR2SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR2SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR2SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR2SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3I`"]
        pub enum MR3IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3IW::ENABLED => true,
                    MR3IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3R`"]
        pub enum MR3RW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3RW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3RW::ENABLED => true,
                    MR3RW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3RW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3RW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3RW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3RW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3RW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MR3S`"]
        pub enum MR3SW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl MR3SW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MR3SW::ENABLED => true,
                    MR3SW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MR3SW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MR3SW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MR3SW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MR3SW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MR3SW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC."]
            #[inline]
            pub fn mr0i(&self) -> MR0IR {
                MR0IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it."]
            #[inline]
            pub fn mr0r(&self) -> MR0RR {
                MR0RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC."]
            #[inline]
            pub fn mr0s(&self) -> MR0SR {
                MR0SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC."]
            #[inline]
            pub fn mr1i(&self) -> MR1IR {
                MR1IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it."]
            #[inline]
            pub fn mr1r(&self) -> MR1RR {
                MR1RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC."]
            #[inline]
            pub fn mr1s(&self) -> MR1SR {
                MR1SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC."]
            #[inline]
            pub fn mr2i(&self) -> MR2IR {
                MR2IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it."]
            #[inline]
            pub fn mr2r(&self) -> MR2RR {
                MR2RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC."]
            #[inline]
            pub fn mr2s(&self) -> MR2SR {
                MR2SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC."]
            #[inline]
            pub fn mr3i(&self) -> MR3IR {
                MR3IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it."]
            #[inline]
            pub fn mr3r(&self) -> MR3RR {
                MR3RR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC."]
            #[inline]
            pub fn mr3s(&self) -> MR3SR {
                MR3SR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Interrupt on MR0: an interrupt is generated when MR0 matches the value in the TC."]
            #[inline]
            pub fn mr0i(&mut self) -> _MR0IW {
                _MR0IW { w: self }
            }
            #[doc = "Bit 1 - Reset on MR0: the TC will be reset if MR0 matches it."]
            #[inline]
            pub fn mr0r(&mut self) -> _MR0RW {
                _MR0RW { w: self }
            }
            #[doc = "Bit 2 - Stop on MR0: the TC and PC will be stopped and TCR[0] will be set to 0 if MR0 matches the TC."]
            #[inline]
            pub fn mr0s(&mut self) -> _MR0SW {
                _MR0SW { w: self }
            }
            #[doc = "Bit 3 - Interrupt on MR1: an interrupt is generated when MR1 matches the value in the TC."]
            #[inline]
            pub fn mr1i(&mut self) -> _MR1IW {
                _MR1IW { w: self }
            }
            #[doc = "Bit 4 - Reset on MR1: the TC will be reset if MR1 matches it."]
            #[inline]
            pub fn mr1r(&mut self) -> _MR1RW {
                _MR1RW { w: self }
            }
            #[doc = "Bit 5 - Stop on MR1: the TC and PC will be stopped and TCR[0] will be set to 0 if MR1 matches the TC."]
            #[inline]
            pub fn mr1s(&mut self) -> _MR1SW {
                _MR1SW { w: self }
            }
            #[doc = "Bit 6 - Interrupt on MR2: an interrupt is generated when MR2 matches the value in the TC."]
            #[inline]
            pub fn mr2i(&mut self) -> _MR2IW {
                _MR2IW { w: self }
            }
            #[doc = "Bit 7 - Reset on MR2: the TC will be reset if MR2 matches it."]
            #[inline]
            pub fn mr2r(&mut self) -> _MR2RW {
                _MR2RW { w: self }
            }
            #[doc = "Bit 8 - Stop on MR2: the TC and PC will be stopped and TCR[0] will be set to 0 if MR2 matches the TC."]
            #[inline]
            pub fn mr2s(&mut self) -> _MR2SW {
                _MR2SW { w: self }
            }
            #[doc = "Bit 9 - Interrupt on MR3: an interrupt is generated when MR3 matches the value in the TC."]
            #[inline]
            pub fn mr3i(&mut self) -> _MR3IW {
                _MR3IW { w: self }
            }
            #[doc = "Bit 10 - Reset on MR3: the TC will be reset if MR3 matches it."]
            #[inline]
            pub fn mr3r(&mut self) -> _MR3RW {
                _MR3RW { w: self }
            }
            #[doc = "Bit 11 - Stop on MR3: the TC and PC will be stopped and TCR[0] will be set to 0 if MR3 matches the TC."]
            #[inline]
            pub fn mr3s(&mut self) -> _MR3SW {
                _MR3SW { w: self }
            }
        }
    }
    #[doc = "Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
    pub struct BMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Match Register. MR can be enabled through the MCR to reset the TC, stop both the TC and PC, and/or generate an interrupt every time MR0 matches the TC."]
    pub mod bmr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MATCHR {
            bits: u32,
        }
        impl MATCHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _MATCHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MATCHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Timer counter match value."]
            #[inline]
            pub fn match_(&self) -> MATCHR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                MATCHR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Timer counter match value."]
            #[inline]
            pub fn match_(&mut self) -> _MATCHW {
                _MATCHW { w: self }
            }
        }
    }
    #[doc = "Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
    pub struct BCCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Capture Control Register (CCR). The CCR controls which edges of the capture inputs are used to load the Capture Registers and whether or not an interrupt is generated when a capture takes place."]
    pub mod bccr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CAP0RE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0RER {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0RER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0RER::ENABLED => true,
                    CAP0RER::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0RER {
                match value {
                    true => CAP0RER::ENABLED,
                    false => CAP0RER::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0RER::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0RER::DISABLED
            }
        }
        #[doc = "Possible values of the field `CAP0FE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0FER {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0FER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0FER::ENABLED => true,
                    CAP0FER::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0FER {
                match value {
                    true => CAP0FER::ENABLED,
                    false => CAP0FER::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0FER::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0FER::DISABLED
            }
        }
        #[doc = "Possible values of the field `CAP0I`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAP0IR {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0IR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CAP0IR::ENABLED => true,
                    CAP0IR::DISABLED => false,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CAP0IR {
                match value {
                    true => CAP0IR::ENABLED,
                    false => CAP0IR::DISABLED,
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CAP0IR::ENABLED
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CAP0IR::DISABLED
            }
        }
        #[doc = "Values that can be written to the field `CAP0RE`"]
        pub enum CAP0REW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0REW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0REW::ENABLED => true,
                    CAP0REW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0REW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0REW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0REW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0REW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0REW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP0FE`"]
        pub enum CAP0FEW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0FEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0FEW::ENABLED => true,
                    CAP0FEW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0FEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0FEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0FEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0FEW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0FEW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CAP0I`"]
        pub enum CAP0IW {
            #[doc = "Enabled"]
            ENABLED,
            #[doc = "Disabled"]
            DISABLED,
        }
        impl CAP0IW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CAP0IW::ENABLED => true,
                    CAP0IW::DISABLED => false,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CAP0IW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CAP0IW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CAP0IW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CAP0IW::ENABLED)
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CAP0IW::DISABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Capture on CT32Bn_CAP0 rising edge: a sequence of 0 then 1 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0re(&self) -> CAP0RER {
                CAP0RER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Capture on CT32Bn_CAP0 falling edge: a sequence of 1 then 0 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0fe(&self) -> CAP0FER {
                CAP0FER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Interrupt on CT32Bn_CAP0 event: a CR0 load due to a CT32Bn_CAP0 event will generate an interrupt."]
            #[inline]
            pub fn cap0i(&self) -> CAP0IR {
                CAP0IR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Capture on CT32Bn_CAP0 rising edge: a sequence of 0 then 1 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0re(&mut self) -> _CAP0REW {
                _CAP0REW { w: self }
            }
            #[doc = "Bit 1 - Capture on CT32Bn_CAP0 falling edge: a sequence of 1 then 0 on CT32Bn_CAP0 will cause CR0 to be loaded with the contents of TC."]
            #[inline]
            pub fn cap0fe(&mut self) -> _CAP0FEW {
                _CAP0FEW { w: self }
            }
            #[doc = "Bit 2 - Interrupt on CT32Bn_CAP0 event: a CR0 load due to a CT32Bn_CAP0 event will generate an interrupt."]
            #[inline]
            pub fn cap0i(&mut self) -> _CAP0IW {
                _CAP0IW { w: self }
            }
        }
    }
    #[doc = "Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input."]
    pub struct BCR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Capture Register 0 (CR0). CR0 is loaded with the value of TC when there is an event on the CT32B0_CAP0 input."]
    pub mod bcr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::BCR0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPR {
            bits: u32,
        }
        impl CAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Timer counter capture value."]
            #[inline]
            pub fn cap(&self) -> CAPR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CAPR { bits }
            }
        }
    }
    #[doc = "External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0]."]
    pub struct BEMR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "External Match Register (EMR). The EMR controls the match function and the external match pins CT32B0_MAT[3:0]."]
    pub mod bemr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BEMR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM0R {
            bits: bool,
        }
        impl EM0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM1R {
            bits: bool,
        }
        impl EM1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM2R {
            bits: bool,
        }
        impl EM2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EM3R {
            bits: bool,
        }
        impl EM3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `EMC0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC0R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC0R::DO_NOTHING => 0,
                    EMC0R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC0R::SET_THE_CORRESPONDIN => 0x02,
                    EMC0R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC0R {
                match value {
                    0 => EMC0R::DO_NOTHING,
                    1 => EMC0R::CLEAR_THE_CORRESPOND,
                    2 => EMC0R::SET_THE_CORRESPONDIN,
                    3 => EMC0R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC0R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC0R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC0R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC0R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC1R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC1R::DO_NOTHING => 0,
                    EMC1R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC1R::SET_THE_CORRESPONDIN => 0x02,
                    EMC1R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC1R {
                match value {
                    0 => EMC1R::DO_NOTHING,
                    1 => EMC1R::CLEAR_THE_CORRESPOND,
                    2 => EMC1R::SET_THE_CORRESPONDIN,
                    3 => EMC1R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC1R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC1R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC1R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC1R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC2R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC2R::DO_NOTHING => 0,
                    EMC2R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC2R::SET_THE_CORRESPONDIN => 0x02,
                    EMC2R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC2R {
                match value {
                    0 => EMC2R::DO_NOTHING,
                    1 => EMC2R::CLEAR_THE_CORRESPOND,
                    2 => EMC2R::SET_THE_CORRESPONDIN,
                    3 => EMC2R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC2R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC2R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC2R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC2R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = "Possible values of the field `EMC3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EMC3R {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    EMC3R::DO_NOTHING => 0,
                    EMC3R::CLEAR_THE_CORRESPOND => 0x01,
                    EMC3R::SET_THE_CORRESPONDIN => 0x02,
                    EMC3R::TOGGLE_THE_CORRESPON => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> EMC3R {
                match value {
                    0 => EMC3R::DO_NOTHING,
                    1 => EMC3R::CLEAR_THE_CORRESPOND,
                    2 => EMC3R::SET_THE_CORRESPONDIN,
                    3 => EMC3R::TOGGLE_THE_CORRESPON,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `DO_NOTHING`"]
            #[inline]
            pub fn is_do_nothing(&self) -> bool {
                *self == EMC3R::DO_NOTHING
            }
            #[doc = "Checks if the value of the field is `CLEAR_THE_CORRESPOND`"]
            #[inline]
            pub fn is_clear_the_correspond(&self) -> bool {
                *self == EMC3R::CLEAR_THE_CORRESPOND
            }
            #[doc = "Checks if the value of the field is `SET_THE_CORRESPONDIN`"]
            #[inline]
            pub fn is_set_the_correspondin(&self) -> bool {
                *self == EMC3R::SET_THE_CORRESPONDIN
            }
            #[doc = "Checks if the value of the field is `TOGGLE_THE_CORRESPON`"]
            #[inline]
            pub fn is_toggle_the_correspon(&self) -> bool {
                *self == EMC3R::TOGGLE_THE_CORRESPON
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EM3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EM3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC0`"]
        pub enum EMC0W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC0W::DO_NOTHING => 0,
                    EMC0W::CLEAR_THE_CORRESPOND => 1,
                    EMC0W::SET_THE_CORRESPONDIN => 2,
                    EMC0W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC0W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC0W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC0W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC0W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC0W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC1`"]
        pub enum EMC1W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC1W::DO_NOTHING => 0,
                    EMC1W::CLEAR_THE_CORRESPOND => 1,
                    EMC1W::SET_THE_CORRESPONDIN => 2,
                    EMC1W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC1W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC1W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC1W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC1W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC1W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC2`"]
        pub enum EMC2W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC2W::DO_NOTHING => 0,
                    EMC2W::CLEAR_THE_CORRESPOND => 1,
                    EMC2W::SET_THE_CORRESPONDIN => 2,
                    EMC2W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC2W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC2W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC2W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC2W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC2W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EMC3`"]
        pub enum EMC3W {
            #[doc = "Do Nothing."]
            DO_NOTHING,
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            CLEAR_THE_CORRESPOND,
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            SET_THE_CORRESPONDIN,
            #[doc = "Toggle the corresponding External Match bit/output."]
            TOGGLE_THE_CORRESPON,
        }
        impl EMC3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    EMC3W::DO_NOTHING => 0,
                    EMC3W::CLEAR_THE_CORRESPOND => 1,
                    EMC3W::SET_THE_CORRESPONDIN => 2,
                    EMC3W::TOGGLE_THE_CORRESPON => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EMC3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _EMC3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EMC3W) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Do Nothing."]
            #[inline]
            pub fn do_nothing(self) -> &'a mut W {
                self.variant(EMC3W::DO_NOTHING)
            }
            #[doc = "Clear the corresponding External Match bit/output to 0 (CT32Bn_MATm pin is LOW if pinned out)."]
            #[inline]
            pub fn clear_the_correspond(self) -> &'a mut W {
                self.variant(EMC3W::CLEAR_THE_CORRESPOND)
            }
            #[doc = "Set the corresponding External Match bit/output to 1 (CT32Bn_MATm pin is HIGH if pinned out)."]
            #[inline]
            pub fn set_the_correspondin(self) -> &'a mut W {
                self.variant(EMC3W::SET_THE_CORRESPONDIN)
            }
            #[doc = "Toggle the corresponding External Match bit/output."]
            #[inline]
            pub fn toggle_the_correspon(self) -> &'a mut W {
                self.variant(EMC3W::TOGGLE_THE_CORRESPON)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em0(&self) -> EM0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM0R { bits }
            }
            #[doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em1(&self) -> EM1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM1R { bits }
            }
            #[doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT16B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em2(&self) -> EM2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM2R { bits }
            }
            #[doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. This bit is driven to the CT32B0_MAT3/CT16B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em3(&self) -> EM3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EM3R { bits }
            }
            #[doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0."]
            #[inline]
            pub fn emc0(&self) -> EMC0R {
                EMC0R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1."]
            #[inline]
            pub fn emc1(&self) -> EMC1R {
                EMC1R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2."]
            #[inline]
            pub fn emc2(&self) -> EMC2R {
                EMC2R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3."]
            #[inline]
            pub fn emc3(&self) -> EMC3R {
                EMC3R::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - External Match 0. This bit reflects the state of output CT32Bn_MAT0, whether or not this output is connected to its pin. When a match occurs between the TC and MR0, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[5:4] control the functionality of this output. This bit is driven to the CT32B0_MAT0/CT16B1_MAT0 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em0(&mut self) -> _EM0W {
                _EM0W { w: self }
            }
            #[doc = "Bit 1 - External Match 1. This bit reflects the state of output CT32Bn_MAT1, whether or not this output is connected to its pin. When a match occurs between the TC and MR1, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[7:6] control the functionality of this output. This bit is driven to the CT32B0_MAT1/CT16B1_MAT1 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em1(&mut self) -> _EM1W {
                _EM1W { w: self }
            }
            #[doc = "Bit 2 - External Match 2. This bit reflects the state of output CT32Bn_MAT2, whether or not this output is connected to its pin. When a match occurs between the TC and MR2, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[9:8] control the functionality of this output. This bit is driven to the CT32B0_MAT2/CT16B1_MAT2 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em2(&mut self) -> _EM2W {
                _EM2W { w: self }
            }
            #[doc = "Bit 3 - External Match 3. This bit reflects the state of output CT32Bn_MAT3, whether or not this output is connected to its pin. When a match occurs between the TC and MR3, this bit can either toggle, go LOW, go HIGH, or do nothing. Bits EMR[11:10] control the functionality of this output. This bit is driven to the CT32B0_MAT3/CT16B1_MAT3 pins if the match function is selected in the IOCON registers (0 = LOW, 1 = HIGH)."]
            #[inline]
            pub fn em3(&mut self) -> _EM3W {
                _EM3W { w: self }
            }
            #[doc = "Bits 4:5 - External Match Control 0. Determines the functionality of External Match 0."]
            #[inline]
            pub fn emc0(&mut self) -> _EMC0W {
                _EMC0W { w: self }
            }
            #[doc = "Bits 6:7 - External Match Control 1. Determines the functionality of External Match 1."]
            #[inline]
            pub fn emc1(&mut self) -> _EMC1W {
                _EMC1W { w: self }
            }
            #[doc = "Bits 8:9 - External Match Control 2. Determines the functionality of External Match 2."]
            #[inline]
            pub fn emc2(&mut self) -> _EMC2W {
                _EMC2W { w: self }
            }
            #[doc = "Bits 10:11 - External Match Control 3. Determines the functionality of External Match 3."]
            #[inline]
            pub fn emc3(&mut self) -> _EMC3W {
                _EMC3W { w: self }
            }
        }
    }
    #[doc = "Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
    pub struct BCTCR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Count Control Register (CTCR). The CTCR selects between Timer and Counter mode, and in Counter mode selects the signal and edge(s) for counting."]
    pub mod bctcr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BCTCR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `CTM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTMR {
            #[doc = "Timer Mode: every rising PCLK edge"]
            TIMER_MODE_EVERY_RI,
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            RISING,
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            FALLLING,
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            BOTHEDGES,
        }
        impl CTMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CTMR::TIMER_MODE_EVERY_RI => 0,
                    CTMR::RISING => 0x01,
                    CTMR::FALLLING => 0x02,
                    CTMR::BOTHEDGES => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CTMR {
                match value {
                    0 => CTMR::TIMER_MODE_EVERY_RI,
                    1 => CTMR::RISING,
                    2 => CTMR::FALLLING,
                    3 => CTMR::BOTHEDGES,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `TIMER_MODE_EVERY_RI`"]
            #[inline]
            pub fn is_timer_mode_every_ri(&self) -> bool {
                *self == CTMR::TIMER_MODE_EVERY_RI
            }
            #[doc = "Checks if the value of the field is `RISING`"]
            #[inline]
            pub fn is_rising(&self) -> bool {
                *self == CTMR::RISING
            }
            #[doc = "Checks if the value of the field is `FALLLING`"]
            #[inline]
            pub fn is_fallling(&self) -> bool {
                *self == CTMR::FALLLING
            }
            #[doc = "Checks if the value of the field is `BOTHEDGES`"]
            #[inline]
            pub fn is_bothedges(&self) -> bool {
                *self == CTMR::BOTHEDGES
            }
        }
        #[doc = "Possible values of the field `CIS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CISR {
            #[doc = "CT32Bn_CAP0"]
            CT32BN_CAP0,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl CISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CISR::CT32BN_CAP0 => 0,
                    CISR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CISR {
                match value {
                    0 => CISR::CT32BN_CAP0,
                    i => CISR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `CT32BN_CAP0`"]
            #[inline]
            pub fn is_ct32bn_cap0(&self) -> bool {
                *self == CISR::CT32BN_CAP0
            }
        }
        #[doc = "Values that can be written to the field `CTM`"]
        pub enum CTMW {
            #[doc = "Timer Mode: every rising PCLK edge"]
            TIMER_MODE_EVERY_RI,
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            RISING,
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            FALLLING,
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            BOTHEDGES,
        }
        impl CTMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CTMW::TIMER_MODE_EVERY_RI => 0,
                    CTMW::RISING => 1,
                    CTMW::FALLLING => 2,
                    CTMW::BOTHEDGES => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CTMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CTMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CTMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Timer Mode: every rising PCLK edge"]
            #[inline]
            pub fn timer_mode_every_ri(self) -> &'a mut W {
                self.variant(CTMW::TIMER_MODE_EVERY_RI)
            }
            #[doc = "Counter Mode: TC is incremented on rising edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn rising(self) -> &'a mut W {
                self.variant(CTMW::RISING)
            }
            #[doc = "Counter Mode: TC is incremented on falling edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn fallling(self) -> &'a mut W {
                self.variant(CTMW::FALLLING)
            }
            #[doc = "Counter Mode: TC is incremented on both edges on the CAP input selected by bits 3:2."]
            #[inline]
            pub fn bothedges(self) -> &'a mut W {
                self.variant(CTMW::BOTHEDGES)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CIS`"]
        pub enum CISW {
            #[doc = "CT32Bn_CAP0"]
            CT32BN_CAP0,
        }
        impl CISW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CISW::CT32BN_CAP0 => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CISW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CISW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CISW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "CT32Bn_CAP0"]
            #[inline]
            pub fn ct32bn_cap0(self) -> &'a mut W {
                self.variant(CISW::CT32BN_CAP0)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: every rising PCLK edge"]
            #[inline]
            pub fn ctm(&self) -> CTMR {
                CTMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - Count Input Select. When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking:"]
            #[inline]
            pub fn cis(&self) -> CISR {
                CISR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Counter/Timer Mode. This field selects which rising PCLK edges can increment Timer's Prescale Counter (PC), or clear PC and increment Timer Counter (TC). Timer Mode: every rising PCLK edge"]
            #[inline]
            pub fn ctm(&mut self) -> _CTMW {
                _CTMW { w: self }
            }
            #[doc = "Bits 2:3 - Count Input Select. When bits 1:0 in this register are not 00, these bits select which CAP pin is sampled for clocking:"]
            #[inline]
            pub fn cis(&mut self) -> _CISW {
                _CISW { w: self }
            }
        }
    }
    #[doc = "PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0]."]
    pub struct BPWMC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "PWM Control Register (PWMCON). The PWMCON enables PWM mode for the external match pins CT32B0_MAT[3:0]."]
    pub mod bpwmc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BPWMC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `PWMEN0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN0R {
            #[doc = "CT32Bn_MAT0 is controlled by EM0."]
            EM0,
            #[doc = "PWM mode is enabled for CT32Bn_MAT0."]
            PWM,
        }
        impl PWMEN0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN0R::EM0 => false,
                    PWMEN0R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN0R {
                match value {
                    false => PWMEN0R::EM0,
                    true => PWMEN0R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM0`"]
            #[inline]
            pub fn is_em0(&self) -> bool {
                *self == PWMEN0R::EM0
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN0R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN1R {
            #[doc = "CT32Bn_MAT1 is controlled by EM1."]
            EM1,
            #[doc = "PWM mode is enabled for CT32Bn_MAT1."]
            PWM,
        }
        impl PWMEN1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN1R::EM1 => false,
                    PWMEN1R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN1R {
                match value {
                    false => PWMEN1R::EM1,
                    true => PWMEN1R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM1`"]
            #[inline]
            pub fn is_em1(&self) -> bool {
                *self == PWMEN1R::EM1
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN1R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN2`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN2R {
            #[doc = "CT32Bn_MAT2 is controlled by EM2."]
            EM2,
            #[doc = "PWM mode is enabled for CT32Bn_MAT2."]
            PWM,
        }
        impl PWMEN2R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN2R::EM2 => false,
                    PWMEN2R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN2R {
                match value {
                    false => PWMEN2R::EM2,
                    true => PWMEN2R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM2`"]
            #[inline]
            pub fn is_em2(&self) -> bool {
                *self == PWMEN2R::EM2
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN2R::PWM
            }
        }
        #[doc = "Possible values of the field `PWMEN3`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PWMEN3R {
            #[doc = "CT32Bn_MAT3 is controlled by EM3."]
            EM3,
            #[doc = "PWM mode is enabled for CT32Bn_MAT3."]
            PWM,
        }
        impl PWMEN3R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PWMEN3R::EM3 => false,
                    PWMEN3R::PWM => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PWMEN3R {
                match value {
                    false => PWMEN3R::EM3,
                    true => PWMEN3R::PWM,
                }
            }
            #[doc = "Checks if the value of the field is `EM3`"]
            #[inline]
            pub fn is_em3(&self) -> bool {
                *self == PWMEN3R::EM3
            }
            #[doc = "Checks if the value of the field is `PWM`"]
            #[inline]
            pub fn is_pwm(&self) -> bool {
                *self == PWMEN3R::PWM
            }
        }
        #[doc = "Values that can be written to the field `PWMEN0`"]
        pub enum PWMEN0W {
            #[doc = "CT32Bn_MAT0 is controlled by EM0."]
            EM0,
            #[doc = "PWM mode is enabled for CT32Bn_MAT0."]
            PWM,
        }
        impl PWMEN0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN0W::EM0 => false,
                    PWMEN0W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT32Bn_MAT0 is controlled by EM0."]
            #[inline]
            pub fn em0(self) -> &'a mut W {
                self.variant(PWMEN0W::EM0)
            }
            #[doc = "PWM mode is enabled for CT32Bn_MAT0."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN0W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN1`"]
        pub enum PWMEN1W {
            #[doc = "CT32Bn_MAT1 is controlled by EM1."]
            EM1,
            #[doc = "PWM mode is enabled for CT32Bn_MAT1."]
            PWM,
        }
        impl PWMEN1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN1W::EM1 => false,
                    PWMEN1W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT32Bn_MAT1 is controlled by EM1."]
            #[inline]
            pub fn em1(self) -> &'a mut W {
                self.variant(PWMEN1W::EM1)
            }
            #[doc = "PWM mode is enabled for CT32Bn_MAT1."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN1W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN2`"]
        pub enum PWMEN2W {
            #[doc = "CT32Bn_MAT2 is controlled by EM2."]
            EM2,
            #[doc = "PWM mode is enabled for CT32Bn_MAT2."]
            PWM,
        }
        impl PWMEN2W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN2W::EM2 => false,
                    PWMEN2W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN2W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN2W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT32Bn_MAT2 is controlled by EM2."]
            #[inline]
            pub fn em2(self) -> &'a mut W {
                self.variant(PWMEN2W::EM2)
            }
            #[doc = "PWM mode is enabled for CT32Bn_MAT2."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN2W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PWMEN3`"]
        pub enum PWMEN3W {
            #[doc = "CT32Bn_MAT3 is controlled by EM3."]
            EM3,
            #[doc = "PWM mode is enabled for CT32Bn_MAT3."]
            PWM,
        }
        impl PWMEN3W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    PWMEN3W::EM3 => false,
                    PWMEN3W::PWM => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PWMEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _PWMEN3W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PWMEN3W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "CT32Bn_MAT3 is controlled by EM3."]
            #[inline]
            pub fn em3(self) -> &'a mut W {
                self.variant(PWMEN3W::EM3)
            }
            #[doc = "PWM mode is enabled for CT32Bn_MAT3."]
            #[inline]
            pub fn pwm(self) -> &'a mut W {
                self.variant(PWMEN3W::PWM)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PWM channel 0 enable"]
            #[inline]
            pub fn pwmen0(&self) -> PWMEN0R {
                PWMEN0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - PWM channel 1 enable"]
            #[inline]
            pub fn pwmen1(&self) -> PWMEN1R {
                PWMEN1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - PWM channel 2 enable"]
            #[inline]
            pub fn pwmen2(&self) -> PWMEN2R {
                PWMEN2R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - PWM channel 3 enable Note: It is recommended to use match channel 3 to set the PWM cycle."]
            #[inline]
            pub fn pwmen3(&self) -> PWMEN3R {
                PWMEN3R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - PWM channel 0 enable"]
            #[inline]
            pub fn pwmen0(&mut self) -> _PWMEN0W {
                _PWMEN0W { w: self }
            }
            #[doc = "Bit 1 - PWM channel 1 enable"]
            #[inline]
            pub fn pwmen1(&mut self) -> _PWMEN1W {
                _PWMEN1W { w: self }
            }
            #[doc = "Bit 2 - PWM channel 2 enable"]
            #[inline]
            pub fn pwmen2(&mut self) -> _PWMEN2W {
                _PWMEN2W { w: self }
            }
            #[doc = "Bit 3 - PWM channel 3 enable Note: It is recommended to use match channel 3 to set the PWM cycle."]
            #[inline]
            pub fn pwmen3(&mut self) -> _PWMEN3W {
                _PWMEN3W { w: self }
            }
        }
    }
}
#[doc = "CT32B1"]
pub struct CT32B1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CT32B1 {}
impl CT32B1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ct32b0::RegisterBlock {
        0x4001_8000 as *const _
    }
}
impl Deref for CT32B1 {
    type Target = ct32b0::RegisterBlock;
    fn deref(&self) -> &ct32b0::RegisterBlock {
        unsafe { &*CT32B1::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Analog-to-Digital Converter (ADC) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub struct ADC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC {}
impl ADC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const adc::RegisterBlock {
        0x4001_c000 as *const _
    }
}
impl Deref for ADC {
    type Target = adc::RegisterBlock;
    fn deref(&self) -> &adc::RegisterBlock {
        unsafe { &*ADC::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Analog-to-Digital Converter (ADC) Modification date=4/19/2011 Major revision=2 Minor revision=1"]
pub mod adc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur."]
        pub cr: CR,
        #[doc = "0x04 - A/D Global Data Register. Contains the result of the most recent A/D conversion."]
        pub gdr: GDR,
        _reserved0: [u8; 4usize],
        #[doc = "0x0c - A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt."]
        pub inten: INTEN,
        #[doc = "0x10 - A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n"]
        pub dr: [DR; 8],
        #[doc = "0x30 - A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag."]
        pub stat: STAT,
    }
    #[doc = "A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur."]
    pub struct CR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Control Register. The AD0CR register must be written to select the operating mode before A/D conversion can occur."]
    pub mod cr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct SELR {
            bits: u8,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CLKDIVR {
            bits: u8,
        }
        impl CLKDIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `BURST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BURSTR {
            #[doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks."]
            SOFTWARE_CONTROLLED,
            #[doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher  bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start."]
            HARDWARE_SCAN_MODE,
        }
        impl BURSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BURSTR::SOFTWARE_CONTROLLED => false,
                    BURSTR::HARDWARE_SCAN_MODE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BURSTR {
                match value {
                    false => BURSTR::SOFTWARE_CONTROLLED,
                    true => BURSTR::HARDWARE_SCAN_MODE,
                }
            }
            #[doc = "Checks if the value of the field is `SOFTWARE_CONTROLLED`"]
            #[inline]
            pub fn is_software_controlled(&self) -> bool {
                *self == BURSTR::SOFTWARE_CONTROLLED
            }
            #[doc = "Checks if the value of the field is `HARDWARE_SCAN_MODE`"]
            #[inline]
            pub fn is_hardware_scan_mode(&self) -> bool {
                *self == BURSTR::HARDWARE_SCAN_MODE
            }
        }
        #[doc = "Possible values of the field `CLKS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKSR {
            #[doc = "11 clocks / 10 bits"]
            _11_CLOCKS_10_BITS,
            #[doc = "10 clocks / 9 bits"]
            _10_CLOCKS_9_BITS,
            #[doc = "9 clocks / 8 bits"]
            _9_CLOCKS_8_BITS,
            #[doc = "8 clocks / 7 bits"]
            _8_CLOCKS_7_BITS,
            #[doc = "7 clocks / 6 bits"]
            _7_CLOCKS_6_BITS,
            #[doc = "6 clocks / 5 bits"]
            _6_CLOCKS_5_BITS,
            #[doc = "5 clocks / 4 bits"]
            _5_CLOCKS_4_BITS,
            #[doc = "4 clocks / 3 bits"]
            _4_CLOCKS_3_BITS,
        }
        impl CLKSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    CLKSR::_11_CLOCKS_10_BITS => 0,
                    CLKSR::_10_CLOCKS_9_BITS => 0x01,
                    CLKSR::_9_CLOCKS_8_BITS => 0x02,
                    CLKSR::_8_CLOCKS_7_BITS => 0x03,
                    CLKSR::_7_CLOCKS_6_BITS => 0x04,
                    CLKSR::_6_CLOCKS_5_BITS => 0x05,
                    CLKSR::_5_CLOCKS_4_BITS => 0x06,
                    CLKSR::_4_CLOCKS_3_BITS => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> CLKSR {
                match value {
                    0 => CLKSR::_11_CLOCKS_10_BITS,
                    1 => CLKSR::_10_CLOCKS_9_BITS,
                    2 => CLKSR::_9_CLOCKS_8_BITS,
                    3 => CLKSR::_8_CLOCKS_7_BITS,
                    4 => CLKSR::_7_CLOCKS_6_BITS,
                    5 => CLKSR::_6_CLOCKS_5_BITS,
                    6 => CLKSR::_5_CLOCKS_4_BITS,
                    7 => CLKSR::_4_CLOCKS_3_BITS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_11_CLOCKS_10_BITS`"]
            #[inline]
            pub fn is_11_clocks_10_bits(&self) -> bool {
                *self == CLKSR::_11_CLOCKS_10_BITS
            }
            #[doc = "Checks if the value of the field is `_10_CLOCKS_9_BITS`"]
            #[inline]
            pub fn is_10_clocks_9_bits(&self) -> bool {
                *self == CLKSR::_10_CLOCKS_9_BITS
            }
            #[doc = "Checks if the value of the field is `_9_CLOCKS_8_BITS`"]
            #[inline]
            pub fn is_9_clocks_8_bits(&self) -> bool {
                *self == CLKSR::_9_CLOCKS_8_BITS
            }
            #[doc = "Checks if the value of the field is `_8_CLOCKS_7_BITS`"]
            #[inline]
            pub fn is_8_clocks_7_bits(&self) -> bool {
                *self == CLKSR::_8_CLOCKS_7_BITS
            }
            #[doc = "Checks if the value of the field is `_7_CLOCKS_6_BITS`"]
            #[inline]
            pub fn is_7_clocks_6_bits(&self) -> bool {
                *self == CLKSR::_7_CLOCKS_6_BITS
            }
            #[doc = "Checks if the value of the field is `_6_CLOCKS_5_BITS`"]
            #[inline]
            pub fn is_6_clocks_5_bits(&self) -> bool {
                *self == CLKSR::_6_CLOCKS_5_BITS
            }
            #[doc = "Checks if the value of the field is `_5_CLOCKS_4_BITS`"]
            #[inline]
            pub fn is_5_clocks_4_bits(&self) -> bool {
                *self == CLKSR::_5_CLOCKS_4_BITS
            }
            #[doc = "Checks if the value of the field is `_4_CLOCKS_3_BITS`"]
            #[inline]
            pub fn is_4_clocks_3_bits(&self) -> bool {
                *self == CLKSR::_4_CLOCKS_3_BITS
            }
        }
        #[doc = "Possible values of the field `START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STARTR {
            #[doc = "No start (this value should be used when clearing PDN to 0)."]
            NO_START_THIS_VALUE,
            #[doc = "Start conversion now."]
            NOW,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0."]
            EDGEPIO0_2,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0."]
            EDGEPIO1_5,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0. Timer match function does not need to be selected on the device pin."]
            EDGECT32B0_MAT0,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1. Timer match function does not need to be selected on the device pin."]
            EDGECT32B1_MAT0,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0. Timer match function does not need to be selected on the device pin."]
            EDGECT16B0_MAT0_1,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1. Timer match function does not need to be selected on the device pin."]
            EDGECT16B0_MAT0_2,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    STARTR::NO_START_THIS_VALUE => 0,
                    STARTR::NOW => 0x01,
                    STARTR::EDGEPIO0_2 => 0x02,
                    STARTR::EDGEPIO1_5 => 0x03,
                    STARTR::EDGECT32B0_MAT0 => 0x04,
                    STARTR::EDGECT32B1_MAT0 => 0x05,
                    STARTR::EDGECT16B0_MAT0_1 => 0x06,
                    STARTR::EDGECT16B0_MAT0_2 => 0x07,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> STARTR {
                match value {
                    0 => STARTR::NO_START_THIS_VALUE,
                    1 => STARTR::NOW,
                    2 => STARTR::EDGEPIO0_2,
                    3 => STARTR::EDGEPIO1_5,
                    4 => STARTR::EDGECT32B0_MAT0,
                    5 => STARTR::EDGECT32B1_MAT0,
                    6 => STARTR::EDGECT16B0_MAT0_1,
                    7 => STARTR::EDGECT16B0_MAT0_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `NO_START_THIS_VALUE`"]
            #[inline]
            pub fn is_no_start_this_value(&self) -> bool {
                *self == STARTR::NO_START_THIS_VALUE
            }
            #[doc = "Checks if the value of the field is `NOW`"]
            #[inline]
            pub fn is_now(&self) -> bool {
                *self == STARTR::NOW
            }
            #[doc = "Checks if the value of the field is `EDGEPIO0_2`"]
            #[inline]
            pub fn is_edgepio0_2(&self) -> bool {
                *self == STARTR::EDGEPIO0_2
            }
            #[doc = "Checks if the value of the field is `EDGEPIO1_5`"]
            #[inline]
            pub fn is_edgepio1_5(&self) -> bool {
                *self == STARTR::EDGEPIO1_5
            }
            #[doc = "Checks if the value of the field is `EDGECT32B0_MAT0`"]
            #[inline]
            pub fn is_edgect32b0_mat0(&self) -> bool {
                *self == STARTR::EDGECT32B0_MAT0
            }
            #[doc = "Checks if the value of the field is `EDGECT32B1_MAT0`"]
            #[inline]
            pub fn is_edgect32b1_mat0(&self) -> bool {
                *self == STARTR::EDGECT32B1_MAT0
            }
            #[doc = "Checks if the value of the field is `EDGECT16B0_MAT0_1`"]
            #[inline]
            pub fn is_edgect16b0_mat0_1(&self) -> bool {
                *self == STARTR::EDGECT16B0_MAT0_1
            }
            #[doc = "Checks if the value of the field is `EDGECT16B0_MAT0_2`"]
            #[inline]
            pub fn is_edgect16b0_mat0_2(&self) -> bool {
                *self == STARTR::EDGECT16B0_MAT0_2
            }
        }
        #[doc = "Possible values of the field `EDGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EDGER {
            #[doc = "Start conversion on a rising edge on the selected CAP/MAT signal."]
            RISING,
            #[doc = "Start conversion on a falling edge on the selected CAP/MAT signal."]
            FALLING,
        }
        impl EDGER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EDGER::RISING => false,
                    EDGER::FALLING => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EDGER {
                match value {
                    false => EDGER::RISING,
                    true => EDGER::FALLING,
                }
            }
            #[doc = "Checks if the value of the field is `RISING`"]
            #[inline]
            pub fn is_rising(&self) -> bool {
                *self == EDGER::RISING
            }
            #[doc = "Checks if the value of the field is `FALLING`"]
            #[inline]
            pub fn is_falling(&self) -> bool {
                *self == EDGER::FALLING
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKDIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKDIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BURST`"]
        pub enum BURSTW {
            #[doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks."]
            SOFTWARE_CONTROLLED,
            #[doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher  bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start."]
            HARDWARE_SCAN_MODE,
        }
        impl BURSTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BURSTW::SOFTWARE_CONTROLLED => false,
                    BURSTW::HARDWARE_SCAN_MODE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BURSTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BURSTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BURSTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Software-controlled mode: Conversions are software-controlled and require 11 clocks."]
            #[inline]
            pub fn software_controlled(self) -> &'a mut W {
                self.variant(BURSTW::SOFTWARE_CONTROLLED)
            }
            #[doc = "Hardware scan mode: The AD converter does repeated conversions at the rate selected by the CLKS field, scanning (if necessary) through the pins selected by 1s in the SEL field. The first conversion after the start corresponds to the least-significant bit set to 1 in the SEL field, then the next higher bits (pins) set to 1 are scanned if applicable. Repeated conversions can be terminated by clearing this bit, but the conversion in progress when this bit is cleared will be completed. Important: START bits must be 000 when BURST = 1 or conversions will not start."]
            #[inline]
            pub fn hardware_scan_mode(self) -> &'a mut W {
                self.variant(BURSTW::HARDWARE_SCAN_MODE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CLKS`"]
        pub enum CLKSW {
            #[doc = "11 clocks / 10 bits"]
            _11_CLOCKS_10_BITS,
            #[doc = "10 clocks / 9 bits"]
            _10_CLOCKS_9_BITS,
            #[doc = "9 clocks / 8 bits"]
            _9_CLOCKS_8_BITS,
            #[doc = "8 clocks / 7 bits"]
            _8_CLOCKS_7_BITS,
            #[doc = "7 clocks / 6 bits"]
            _7_CLOCKS_6_BITS,
            #[doc = "6 clocks / 5 bits"]
            _6_CLOCKS_5_BITS,
            #[doc = "5 clocks / 4 bits"]
            _5_CLOCKS_4_BITS,
            #[doc = "4 clocks / 3 bits"]
            _4_CLOCKS_3_BITS,
        }
        impl CLKSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CLKSW::_11_CLOCKS_10_BITS => 0,
                    CLKSW::_10_CLOCKS_9_BITS => 1,
                    CLKSW::_9_CLOCKS_8_BITS => 2,
                    CLKSW::_8_CLOCKS_7_BITS => 3,
                    CLKSW::_7_CLOCKS_6_BITS => 4,
                    CLKSW::_6_CLOCKS_5_BITS => 5,
                    CLKSW::_5_CLOCKS_4_BITS => 6,
                    CLKSW::_4_CLOCKS_3_BITS => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLKSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLKSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CLKSW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "11 clocks / 10 bits"]
            #[inline]
            pub fn _11_clocks_10_bits(self) -> &'a mut W {
                self.variant(CLKSW::_11_CLOCKS_10_BITS)
            }
            #[doc = "10 clocks / 9 bits"]
            #[inline]
            pub fn _10_clocks_9_bits(self) -> &'a mut W {
                self.variant(CLKSW::_10_CLOCKS_9_BITS)
            }
            #[doc = "9 clocks / 8 bits"]
            #[inline]
            pub fn _9_clocks_8_bits(self) -> &'a mut W {
                self.variant(CLKSW::_9_CLOCKS_8_BITS)
            }
            #[doc = "8 clocks / 7 bits"]
            #[inline]
            pub fn _8_clocks_7_bits(self) -> &'a mut W {
                self.variant(CLKSW::_8_CLOCKS_7_BITS)
            }
            #[doc = "7 clocks / 6 bits"]
            #[inline]
            pub fn _7_clocks_6_bits(self) -> &'a mut W {
                self.variant(CLKSW::_7_CLOCKS_6_BITS)
            }
            #[doc = "6 clocks / 5 bits"]
            #[inline]
            pub fn _6_clocks_5_bits(self) -> &'a mut W {
                self.variant(CLKSW::_6_CLOCKS_5_BITS)
            }
            #[doc = "5 clocks / 4 bits"]
            #[inline]
            pub fn _5_clocks_4_bits(self) -> &'a mut W {
                self.variant(CLKSW::_5_CLOCKS_4_BITS)
            }
            #[doc = "4 clocks / 3 bits"]
            #[inline]
            pub fn _4_clocks_3_bits(self) -> &'a mut W {
                self.variant(CLKSW::_4_CLOCKS_3_BITS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `START`"]
        pub enum STARTW {
            #[doc = "No start (this value should be used when clearing PDN to 0)."]
            NO_START_THIS_VALUE,
            #[doc = "Start conversion now."]
            NOW,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0."]
            EDGEPIO0_2,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0."]
            EDGEPIO1_5,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0. Timer match function does not need to be selected on the device pin."]
            EDGECT32B0_MAT0,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1. Timer match function does not need to be selected on the device pin."]
            EDGECT32B1_MAT0,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0. Timer match function does not need to be selected on the device pin."]
            EDGECT16B0_MAT0_1,
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1. Timer match function does not need to be selected on the device pin."]
            EDGECT16B0_MAT0_2,
        }
        impl STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    STARTW::NO_START_THIS_VALUE => 0,
                    STARTW::NOW => 1,
                    STARTW::EDGEPIO0_2 => 2,
                    STARTW::EDGEPIO1_5 => 3,
                    STARTW::EDGECT32B0_MAT0 => 4,
                    STARTW::EDGECT32B1_MAT0 => 5,
                    STARTW::EDGECT16B0_MAT0_1 => 6,
                    STARTW::EDGECT16B0_MAT0_2 => 7,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: STARTW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "No start (this value should be used when clearing PDN to 0)."]
            #[inline]
            pub fn no_start_this_value(self) -> &'a mut W {
                self.variant(STARTW::NO_START_THIS_VALUE)
            }
            #[doc = "Start conversion now."]
            #[inline]
            pub fn now(self) -> &'a mut W {
                self.variant(STARTW::NOW)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO0_2/SSEL/CT16B0_CAP0."]
            #[inline]
            pub fn edgepio0_2(self) -> &'a mut W {
                self.variant(STARTW::EDGEPIO0_2)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on PIO1_5/DIR/CT32B0_CAP0."]
            #[inline]
            pub fn edgepio1_5(self) -> &'a mut W {
                self.variant(STARTW::EDGEPIO1_5)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT0. Timer match function does not need to be selected on the device pin."]
            #[inline]
            pub fn edgect32b0_mat0(self) -> &'a mut W {
                self.variant(STARTW::EDGECT32B0_MAT0)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT32B0_MAT1. Timer match function does not need to be selected on the device pin."]
            #[inline]
            pub fn edgect32b1_mat0(self) -> &'a mut W {
                self.variant(STARTW::EDGECT32B1_MAT0)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT0. Timer match function does not need to be selected on the device pin."]
            #[inline]
            pub fn edgect16b0_mat0_1(self) -> &'a mut W {
                self.variant(STARTW::EDGECT16B0_MAT0_1)
            }
            #[doc = "Start conversion when the edge selected by bit 27 occurs on CT16B0_MAT1. Timer match function does not need to be selected on the device pin."]
            #[inline]
            pub fn edgect16b0_mat0_2(self) -> &'a mut W {
                self.variant(STARTW::EDGECT16B0_MAT0_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `EDGE`"]
        pub enum EDGEW {
            #[doc = "Start conversion on a rising edge on the selected CAP/MAT signal."]
            RISING,
            #[doc = "Start conversion on a falling edge on the selected CAP/MAT signal."]
            FALLING,
        }
        impl EDGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    EDGEW::RISING => false,
                    EDGEW::FALLING => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _EDGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EDGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: EDGEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Start conversion on a rising edge on the selected CAP/MAT signal."]
            #[inline]
            pub fn rising(self) -> &'a mut W {
                self.variant(EDGEW::RISING)
            }
            #[doc = "Start conversion on a falling edge on the selected CAP/MAT signal."]
            #[inline]
            pub fn falling(self) -> &'a mut W {
                self.variant(EDGEW::FALLING)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Selects which of the AD7:0 pins is (are) to be sampled and converted. Bit 0 selects Pin AD0, bit 1 selects pin AD1,..., and bit 7 selects pin AD7. In software-controlled mode (BURST = 0), only one channel can be selected, i.e. only one of these bits should be 1. In hardware scan mode (BURST = 1), any numbers of channels can be selected, i.e any or all bits can be set to 1. If all bits are set to 0, channel 0 is selected automatically (SEL = 0x01)."]
            #[inline]
            pub fn sel(&self) -> SELR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SELR { bits }
            }
            #[doc = "Bits 8:15 - The APB clock (PCLK) is divided by CLKDIV +1 to produce the clock for the ADC, which should be less than or equal to 4.5 MHz. Typically, software should program the smallest value in this field that yields a clock of 4.5 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable."]
            #[inline]
            pub fn clkdiv(&self) -> CLKDIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CLKDIVR { bits }
            }
            #[doc = "Bit 16 - Burst select"]
            #[inline]
            pub fn burst(&self) -> BURSTR {
                BURSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 17:19 - This field selects the number of clocks used for each conversion in Burst mode, and the number of bits of accuracy of the result in the LS bits of ADDR, between 11 clocks (10 bits) and 4 clocks (3 bits)."]
            #[inline]
            pub fn clks(&self) -> CLKSR {
                CLKSR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 24:26 - When the BURST bit is 0, these bits control whether and when an A/D conversion is started:"]
            #[inline]
            pub fn start(&self) -> STARTR {
                STARTR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 27 - This bit is significant only when the START field contains 010-111. In these cases:"]
            #[inline]
            pub fn edge(&self) -> EDGER {
                EDGER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Selects which of the AD7:0 pins is (are) to be sampled and converted. Bit 0 selects Pin AD0, bit 1 selects pin AD1,..., and bit 7 selects pin AD7. In software-controlled mode (BURST = 0), only one channel can be selected, i.e. only one of these bits should be 1. In hardware scan mode (BURST = 1), any numbers of channels can be selected, i.e any or all bits can be set to 1. If all bits are set to 0, channel 0 is selected automatically (SEL = 0x01)."]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
            #[doc = "Bits 8:15 - The APB clock (PCLK) is divided by CLKDIV +1 to produce the clock for the ADC, which should be less than or equal to 4.5 MHz. Typically, software should program the smallest value in this field that yields a clock of 4.5 MHz or slightly less, but in certain cases (such as a high-impedance analog source) a slower clock may be desirable."]
            #[inline]
            pub fn clkdiv(&mut self) -> _CLKDIVW {
                _CLKDIVW { w: self }
            }
            #[doc = "Bit 16 - Burst select"]
            #[inline]
            pub fn burst(&mut self) -> _BURSTW {
                _BURSTW { w: self }
            }
            #[doc = "Bits 17:19 - This field selects the number of clocks used for each conversion in Burst mode, and the number of bits of accuracy of the result in the LS bits of ADDR, between 11 clocks (10 bits) and 4 clocks (3 bits)."]
            #[inline]
            pub fn clks(&mut self) -> _CLKSW {
                _CLKSW { w: self }
            }
            #[doc = "Bits 24:26 - When the BURST bit is 0, these bits control whether and when an A/D conversion is started:"]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
            #[doc = "Bit 27 - This bit is significant only when the START field contains 010-111. In these cases:"]
            #[inline]
            pub fn edge(&mut self) -> _EDGEW {
                _EDGEW { w: self }
            }
        }
    }
    #[doc = "A/D Global Data Register. Contains the result of the most recent A/D conversion."]
    pub struct GDR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Global Data Register. Contains the result of the most recent A/D conversion."]
    pub mod gdr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GDR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct V_VREFR {
            bits: u16,
        }
        impl V_VREFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct CHNR {
            bits: u8,
        }
        impl CHNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONER {
            bits: bool,
        }
        impl DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _V_VREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _V_VREFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CHNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CHNW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin selected by the SEL field, divided by the voltage on the VDD pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VSS, while 0x3FF indicates that the voltage on ADn was close to, equal to, or greater than that on VREF."]
            #[inline]
            pub fn v_vref(&self) -> V_VREFR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                V_VREFR { bits }
            }
            #[doc = "Bits 24:26 - These bits contain the channel from which the V_VREF bits were converted."]
            #[inline]
            pub fn chn(&self) -> CHNR {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CHNR { bits }
            }
            #[doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started."]
            #[inline]
            pub fn done(&self) -> DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin selected by the SEL field, divided by the voltage on the VDD pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VSS, while 0x3FF indicates that the voltage on ADn was close to, equal to, or greater than that on VREF."]
            #[inline]
            pub fn v_vref(&mut self) -> _V_VREFW {
                _V_VREFW { w: self }
            }
            #[doc = "Bits 24:26 - These bits contain the channel from which the V_VREF bits were converted."]
            #[inline]
            pub fn chn(&mut self) -> _CHNW {
                _CHNW { w: self }
            }
            #[doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read and when the ADCR is written. If the ADCR is written while a conversion is still in progress, this bit is set and a new conversion is started."]
            #[inline]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
        }
    }
    #[doc = "A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt."]
    pub struct INTEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Interrupt Enable Register. This register contains enable bits that allow the DONE flag of each A/D channel to be included or excluded from contributing to the generation of an A/D interrupt."]
    pub mod inten {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::INTEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN0R {
            bits: bool,
        }
        impl ADINTEN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN1R {
            bits: bool,
        }
        impl ADINTEN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN2R {
            bits: bool,
        }
        impl ADINTEN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN3R {
            bits: bool,
        }
        impl ADINTEN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN4R {
            bits: bool,
        }
        impl ADINTEN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN5R {
            bits: bool,
        }
        impl ADINTEN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN6R {
            bits: bool,
        }
        impl ADINTEN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTEN7R {
            bits: bool,
        }
        impl ADINTEN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADGINTENR {
            bits: bool,
        }
        impl ADGINTENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADINTEN7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADINTEN7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADGINTENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADGINTENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten0(&self) -> ADINTEN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN0R { bits }
            }
            #[doc = "Bit 1 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten1(&self) -> ADINTEN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN1R { bits }
            }
            #[doc = "Bit 2 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten2(&self) -> ADINTEN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN2R { bits }
            }
            #[doc = "Bit 3 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten3(&self) -> ADINTEN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN3R { bits }
            }
            #[doc = "Bit 4 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten4(&self) -> ADINTEN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN4R { bits }
            }
            #[doc = "Bit 5 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten5(&self) -> ADINTEN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN5R { bits }
            }
            #[doc = "Bit 6 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten6(&self) -> ADINTEN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN6R { bits }
            }
            #[doc = "Bit 7 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten7(&self) -> ADINTEN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTEN7R { bits }
            }
            #[doc = "Bit 8 - When 1, enables the global DONE flag in ADDR to generate an interrupt. When 0, only the individual A/D channels enabled by ADINTEN 7:0 will generate interrupts."]
            #[inline]
            pub fn adginten(&self) -> ADGINTENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADGINTENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x0100 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten0(&mut self) -> _ADINTEN0W {
                _ADINTEN0W { w: self }
            }
            #[doc = "Bit 1 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten1(&mut self) -> _ADINTEN1W {
                _ADINTEN1W { w: self }
            }
            #[doc = "Bit 2 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten2(&mut self) -> _ADINTEN2W {
                _ADINTEN2W { w: self }
            }
            #[doc = "Bit 3 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten3(&mut self) -> _ADINTEN3W {
                _ADINTEN3W { w: self }
            }
            #[doc = "Bit 4 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten4(&mut self) -> _ADINTEN4W {
                _ADINTEN4W { w: self }
            }
            #[doc = "Bit 5 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten5(&mut self) -> _ADINTEN5W {
                _ADINTEN5W { w: self }
            }
            #[doc = "Bit 6 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten6(&mut self) -> _ADINTEN6W {
                _ADINTEN6W { w: self }
            }
            #[doc = "Bit 7 - These bits allow control over which A/D channels generate interrupts for conversion completion. When bit 0 is one, completion of a conversion on A/D channel 0 will generate an interrupt, when bit 1 is one, completion of a conversion on A/D channel 1 will generate an interrupt, etc."]
            #[inline]
            pub fn adinten7(&mut self) -> _ADINTEN7W {
                _ADINTEN7W { w: self }
            }
            #[doc = "Bit 8 - When 1, enables the global DONE flag in ADDR to generate an interrupt. When 0, only the individual A/D channels enabled by ADINTEN 7:0 will generate interrupts."]
            #[inline]
            pub fn adginten(&mut self) -> _ADGINTENW {
                _ADGINTENW { w: self }
            }
        }
    }
    #[doc = "A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n"]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Channel n Data Register. This register contains the result of the most recent conversion completed on channel n"]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct V_VREFR {
            bits: u16,
        }
        impl V_VREFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUNR {
            bits: bool,
        }
        impl OVERRUNR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONER {
            bits: bool,
        }
        impl DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _V_VREFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _V_VREFW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _OVERRUNW<'a> {
            w: &'a mut W,
        }
        impl<'a> _OVERRUNW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DONEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DONEW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF."]
            #[inline]
            pub fn v_vref(&self) -> V_VREFR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                V_VREFR { bits }
            }
            #[doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register."]
            #[inline]
            pub fn overrun(&self) -> OVERRUNR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUNR { bits }
            }
            #[doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read."]
            #[inline]
            pub fn done(&self) -> DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONER { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 6:15 - When DONE is 1, this field contains a binary fraction representing the voltage on the ADn pin, divided by the voltage on the VREF pin. Zero in the field indicates that the voltage on the ADn pin was less than, equal to, or close to that on VREF, while 0x3FF indicates that the voltage on AD input was close to, equal to, or greater than that on VREF."]
            #[inline]
            pub fn v_vref(&mut self) -> _V_VREFW {
                _V_VREFW { w: self }
            }
            #[doc = "Bit 30 - This bit is 1 in burst mode if the results of one or more conversions was (were) lost and overwritten before the conversion that produced the result in the V_VREF bits.This bit is cleared by reading this register."]
            #[inline]
            pub fn overrun(&mut self) -> _OVERRUNW {
                _OVERRUNW { w: self }
            }
            #[doc = "Bit 31 - This bit is set to 1 when an A/D conversion completes. It is cleared when this register is read."]
            #[inline]
            pub fn done(&mut self) -> _DONEW {
                _DONEW { w: self }
            }
        }
    }
    #[doc = "A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag."]
    pub struct STAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "A/D Status Register. This register contains DONE and OVERRUN flags for all of the A/D channels, as well as the A/D interrupt flag."]
    pub mod stat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE0R {
            bits: bool,
        }
        impl DONE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE1R {
            bits: bool,
        }
        impl DONE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE2R {
            bits: bool,
        }
        impl DONE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE3R {
            bits: bool,
        }
        impl DONE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE4R {
            bits: bool,
        }
        impl DONE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE5R {
            bits: bool,
        }
        impl DONE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE6R {
            bits: bool,
        }
        impl DONE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DONE7R {
            bits: bool,
        }
        impl DONE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN0R {
            bits: bool,
        }
        impl OVERRUN0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN1R {
            bits: bool,
        }
        impl OVERRUN1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN2R {
            bits: bool,
        }
        impl OVERRUN2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN3R {
            bits: bool,
        }
        impl OVERRUN3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN4R {
            bits: bool,
        }
        impl OVERRUN4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN5R {
            bits: bool,
        }
        impl OVERRUN5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN6R {
            bits: bool,
        }
        impl OVERRUN6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct OVERRUN7R {
            bits: bool,
        }
        impl OVERRUN7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ADINTR {
            bits: bool,
        }
        impl ADINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done0(&self) -> DONE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE0R { bits }
            }
            #[doc = "Bit 1 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done1(&self) -> DONE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE1R { bits }
            }
            #[doc = "Bit 2 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done2(&self) -> DONE2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE2R { bits }
            }
            #[doc = "Bit 3 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done3(&self) -> DONE3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE3R { bits }
            }
            #[doc = "Bit 4 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done4(&self) -> DONE4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE4R { bits }
            }
            #[doc = "Bit 5 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done5(&self) -> DONE5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE5R { bits }
            }
            #[doc = "Bit 6 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done6(&self) -> DONE6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE6R { bits }
            }
            #[doc = "Bit 7 - These bits mirror the DONE status flags that appear in the result register for each A/D channel."]
            #[inline]
            pub fn done7(&self) -> DONE7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DONE7R { bits }
            }
            #[doc = "Bit 8 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun0(&self) -> OVERRUN0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN0R { bits }
            }
            #[doc = "Bit 9 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun1(&self) -> OVERRUN1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN1R { bits }
            }
            #[doc = "Bit 10 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun2(&self) -> OVERRUN2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN2R { bits }
            }
            #[doc = "Bit 11 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun3(&self) -> OVERRUN3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN3R { bits }
            }
            #[doc = "Bit 12 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun4(&self) -> OVERRUN4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN4R { bits }
            }
            #[doc = "Bit 13 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun5(&self) -> OVERRUN5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN5R { bits }
            }
            #[doc = "Bit 14 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun6(&self) -> OVERRUN6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN6R { bits }
            }
            #[doc = "Bit 15 - These bits mirror the OVERRRUN status flags that appear in the result register for each A/D channel. Reading ADSTAT allows checking the status of all A/D channels simultaneously."]
            #[inline]
            pub fn overrun7(&self) -> OVERRUN7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                OVERRUN7R { bits }
            }
            #[doc = "Bit 16 - This bit is the A/D interrupt flag. It is one when any of the individual A/D channel Done flags is asserted and enabled to contribute to the A/D interrupt via the ADINTEN register."]
            #[inline]
            pub fn adint(&self) -> ADINTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ADINTR { bits }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx USB device controller Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct USB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USB {}
impl USB {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const usb::RegisterBlock {
        0x4002_0000 as *const _
    }
}
impl Deref for USB {
    type Target = usb::RegisterBlock;
    fn deref(&self) -> &usb::RegisterBlock {
        unsafe { &*USB::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx USB device controller Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod usb {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - USB Device Interrupt Status"]
        pub devintst: DEVINTST,
        #[doc = "0x04 - USB Device Interrupt Enable"]
        pub devinten: DEVINTEN,
        #[doc = "0x08 - USB Device Interrupt Clear"]
        pub devintctrl: DEVINTCTRL,
        #[doc = "0x0c - USB Device Interrupt Set"]
        pub devintset: DEVINTSET,
        #[doc = "0x10 - USB Command Code"]
        pub cmdcode: CMDCODE,
        #[doc = "0x14 - USB Command Data"]
        pub cmddata: CMDDATA,
        #[doc = "0x18 - USB Receive Data"]
        pub rxdata: RXDATA,
        #[doc = "0x1c - USB Transmit Data"]
        pub txdata: TXDATA,
        #[doc = "0x20 - USB Receive Packet Length"]
        pub rxplen: RXPLEN,
        #[doc = "0x24 - USB Transmit Packet Length"]
        pub txplenn: TXPLENN,
        #[doc = "0x28 - USB Control"]
        pub ctrl: CTRL,
        #[doc = "0x2c - USB Device FIQ select"]
        pub devfiqsel: DEVFIQSEL,
    }
    #[doc = "USB Device Interrupt Status"]
    pub struct DEVINTST {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Device Interrupt Status"]
    pub mod devintst {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVINTST {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAMER {
            bits: bool,
        }
        impl FRAMER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP0R {
            bits: bool,
        }
        impl EP0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP1R {
            bits: bool,
        }
        impl EP1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP2R {
            bits: bool,
        }
        impl EP2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP3R {
            bits: bool,
        }
        impl EP3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP4R {
            bits: bool,
        }
        impl EP4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP5R {
            bits: bool,
        }
        impl EP5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP6R {
            bits: bool,
        }
        impl EP6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP7R {
            bits: bool,
        }
        impl EP7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEV_STATR {
            bits: bool,
        }
        impl DEV_STATR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC_EMPTYR {
            bits: bool,
        }
        impl CC_EMPTYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CD_FULLR {
            bits: bool,
        }
        impl CD_FULLR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXENDPKTR {
            bits: bool,
        }
        impl RXENDPKTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENDPKTR {
            bits: bool,
        }
        impl TXENDPKTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - The frame interrupt occurs every 1 ms. This is used in isochronous packet transfers. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn frame(&self) -> FRAMER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAMER { bits }
            }
            #[doc = "Bit 1 - USB core interrupt for physical endpoint 0. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep0(&self) -> EP0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP0R { bits }
            }
            #[doc = "Bit 2 - USB core interrupt for physical endpoint 1. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep1(&self) -> EP1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP1R { bits }
            }
            #[doc = "Bit 3 - USB core interrupt for physical endpoint 2. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep2(&self) -> EP2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP2R { bits }
            }
            #[doc = "Bit 4 - USB core interrupt for physical endpoint 3. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep3(&self) -> EP3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP3R { bits }
            }
            #[doc = "Bit 5 - USB core interrupt for physical endpoint 4. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep4(&self) -> EP4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP4R { bits }
            }
            #[doc = "Bit 6 - USB core interrupt for physical endpoint 5. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep5(&self) -> EP5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP5R { bits }
            }
            #[doc = "Bit 7 - USB core interrupt for physical endpoint 6. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep6(&self) -> EP6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP6R { bits }
            }
            #[doc = "Bit 8 - USB core interrupt for physical endpoint 7. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep7(&self) -> EP7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP7R { bits }
            }
            #[doc = "Bit 9 - Set when USB Bus reset, USB suspend change, or Connect change event occurs. Refer to Section 10.11.7. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn dev_stat(&self) -> DEV_STATR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DEV_STATR { bits }
            }
            #[doc = "Bit 10 - The command code register (USBCmdCode) is empty (New command can be written). 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn cc_empty(&self) -> CC_EMPTYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC_EMPTYR { bits }
            }
            #[doc = "Bit 11 - Command data register (USBCmdData) is full (Data can be read now). 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn cd_full(&self) -> CD_FULLR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CD_FULLR { bits }
            }
            #[doc = "Bit 12 - The current packet in the endpoint buffer is transferred to the CPU. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn rx_endpkt(&self) -> RXENDPKTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXENDPKTR { bits }
            }
            #[doc = "Bit 13 - The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen). 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn tx_endpkt(&self) -> TXENDPKTR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENDPKTR { bits }
            }
        }
    }
    #[doc = "USB Device Interrupt Enable"]
    pub struct DEVINTEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Device Interrupt Enable"]
    pub mod devinten {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVINTEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FRAME_ENR {
            bits: bool,
        }
        impl FRAME_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP0_ENR {
            bits: bool,
        }
        impl EP0_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP1_ENR {
            bits: bool,
        }
        impl EP1_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP2_ENR {
            bits: bool,
        }
        impl EP2_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP3_ENR {
            bits: bool,
        }
        impl EP3_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP4_ENR {
            bits: bool,
        }
        impl EP4_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP5_ENR {
            bits: bool,
        }
        impl EP5_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP6_ENR {
            bits: bool,
        }
        impl EP6_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct EP7_ENR {
            bits: bool,
        }
        impl EP7_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEV_STAT_ENR {
            bits: bool,
        }
        impl DEV_STAT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CC_EMPTY_ENR {
            bits: bool,
        }
        impl CC_EMPTY_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CD_FULL_ENR {
            bits: bool,
        }
        impl CD_FULL_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXENDPKT_ENR {
            bits: bool,
        }
        impl RXENDPKT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXENDPKT_ENR {
            bits: bool,
        }
        impl TXENDPKT_ENR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP0_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP0_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP1_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP1_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP2_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP2_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP3_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP3_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP4_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP4_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP5_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP5_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP6_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP6_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP7_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP7_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEV_STAT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEV_STAT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC_EMPTY_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC_EMPTY_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CD_FULL_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CD_FULL_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENDPKT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENDPKT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENDPKT_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENDPKT_ENW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Frame interrupt . For isochronous packet transfers. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn frame_en(&self) -> FRAME_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FRAME_ENR { bits }
            }
            #[doc = "Bit 1 - USB core interrupt for physical endpoint 0. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep0_en(&self) -> EP0_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP0_ENR { bits }
            }
            #[doc = "Bit 2 - USB core interrupt for physical endpoint 1. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep1_en(&self) -> EP1_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP1_ENR { bits }
            }
            #[doc = "Bit 3 - USB core interrupt for physical endpoint 2. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep2_en(&self) -> EP2_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP2_ENR { bits }
            }
            #[doc = "Bit 4 - USB core interrupt for physical endpoint 3. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep3_en(&self) -> EP3_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP3_ENR { bits }
            }
            #[doc = "Bit 5 - USB core interrupt for physical endpoint 4. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep4_en(&self) -> EP4_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP4_ENR { bits }
            }
            #[doc = "Bit 6 - USB core interrupt for physical endpoint 5. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep5_en(&self) -> EP5_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP5_ENR { bits }
            }
            #[doc = "Bit 7 - USB core interrupt for physical endpoint 6. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep6_en(&self) -> EP6_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP6_ENR { bits }
            }
            #[doc = "Bit 8 - USB core interrupt for physical endpoint 7. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep7_en(&self) -> EP7_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                EP7_ENR { bits }
            }
            #[doc = "Bit 9 - Set when USB Bus reset, USB suspend change, or Connect change event occurs. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn dev_stat_en(&self) -> DEV_STAT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DEV_STAT_ENR { bits }
            }
            #[doc = "Bit 10 - The command code register (USBCmdCode) is empty (New command can be written). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cc_empty_en(&self) -> CC_EMPTY_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CC_EMPTY_ENR { bits }
            }
            #[doc = "Bit 11 - Command data register (USBCmdData) is full (Data can be read now). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cd_full_en(&self) -> CD_FULL_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CD_FULL_ENR { bits }
            }
            #[doc = "Bit 12 - The current packet in the endpoint buffer is transferred to the CPU. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn rxendpkt_en(&self) -> RXENDPKT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXENDPKT_ENR { bits }
            }
            #[doc = "Bit 13 - The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn txendpkt_en(&self) -> TXENDPKT_ENR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXENDPKT_ENR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Frame interrupt . For isochronous packet transfers. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn frame_en(&mut self) -> _FRAME_ENW {
                _FRAME_ENW { w: self }
            }
            #[doc = "Bit 1 - USB core interrupt for physical endpoint 0. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep0_en(&mut self) -> _EP0_ENW {
                _EP0_ENW { w: self }
            }
            #[doc = "Bit 2 - USB core interrupt for physical endpoint 1. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep1_en(&mut self) -> _EP1_ENW {
                _EP1_ENW { w: self }
            }
            #[doc = "Bit 3 - USB core interrupt for physical endpoint 2. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep2_en(&mut self) -> _EP2_ENW {
                _EP2_ENW { w: self }
            }
            #[doc = "Bit 4 - USB core interrupt for physical endpoint 3. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep3_en(&mut self) -> _EP3_ENW {
                _EP3_ENW { w: self }
            }
            #[doc = "Bit 5 - USB core interrupt for physical endpoint 4. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep4_en(&mut self) -> _EP4_ENW {
                _EP4_ENW { w: self }
            }
            #[doc = "Bit 6 - USB core interrupt for physical endpoint 5. 0 = no interrupt. 1 = interrupt pending."]
            #[inline]
            pub fn ep5_en(&mut self) -> _EP5_ENW {
                _EP5_ENW { w: self }
            }
            #[doc = "Bit 7 - USB core interrupt for physical endpoint 6. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep6_en(&mut self) -> _EP6_ENW {
                _EP6_ENW { w: self }
            }
            #[doc = "Bit 8 - USB core interrupt for physical endpoint 7. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep7_en(&mut self) -> _EP7_ENW {
                _EP7_ENW { w: self }
            }
            #[doc = "Bit 9 - Set when USB Bus reset, USB suspend change, or Connect change event occurs. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn dev_stat_en(&mut self) -> _DEV_STAT_ENW {
                _DEV_STAT_ENW { w: self }
            }
            #[doc = "Bit 10 - The command code register (USBCmdCode) is empty (New command can be written). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cc_empty_en(&mut self) -> _CC_EMPTY_ENW {
                _CC_EMPTY_ENW { w: self }
            }
            #[doc = "Bit 11 - Command data register (USBCmdData) is full (Data can be read now). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cd_full_en(&mut self) -> _CD_FULL_ENW {
                _CD_FULL_ENW { w: self }
            }
            #[doc = "Bit 12 - The current packet in the endpoint buffer is transferred to the CPU. 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn rxendpkt_en(&mut self) -> _RXENDPKT_ENW {
                _RXENDPKT_ENW { w: self }
            }
            #[doc = "Bit 13 - The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen). 0 = no interrupt generated. 1 = interrupt generated when the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn txendpkt_en(&mut self) -> _TXENDPKT_ENW {
                _TXENDPKT_ENW { w: self }
            }
        }
    }
    #[doc = "USB Device Interrupt Clear"]
    pub struct DEVINTCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Device Interrupt Clear"]
    pub mod devintctrl {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVINTCTRL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP0_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP0_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP1_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP1_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP2_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP2_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP3_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP3_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP4_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP4_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP5_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP5_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP6_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP6_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP7_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP7_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEV_STAT_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEV_STAT_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC_EMPTY_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC_EMPTY_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CD_FULL_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CD_FULL_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENDPKT_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENDPKT_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENDPKT_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENDPKT_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Frame interrupt . For isochronous packet transfers. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn frame_clr(&mut self) -> _FRAME_CLRW {
                _FRAME_CLRW { w: self }
            }
            #[doc = "Bit 1 - USB core interrupt for physical endpoint 0. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep0_clr(&mut self) -> _EP0_CLRW {
                _EP0_CLRW { w: self }
            }
            #[doc = "Bit 2 - USB core interrupt for physical endpoint 1. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep1_clr(&mut self) -> _EP1_CLRW {
                _EP1_CLRW { w: self }
            }
            #[doc = "Bit 3 - USB core interrupt for physical endpoint 2. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep2_clr(&mut self) -> _EP2_CLRW {
                _EP2_CLRW { w: self }
            }
            #[doc = "Bit 4 - USB core interrupt for physical endpoint 3. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep3_clr(&mut self) -> _EP3_CLRW {
                _EP3_CLRW { w: self }
            }
            #[doc = "Bit 5 - USB core interrupt for physical endpoint 4. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep4_clr(&mut self) -> _EP4_CLRW {
                _EP4_CLRW { w: self }
            }
            #[doc = "Bit 6 - USB core interrupt for physical endpoint 5. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep5_clr(&mut self) -> _EP5_CLRW {
                _EP5_CLRW { w: self }
            }
            #[doc = "Bit 7 - USB core interrupt for physical endpoint 6. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep6_clr(&mut self) -> _EP6_CLRW {
                _EP6_CLRW { w: self }
            }
            #[doc = "Bit 8 - USB core interrupt for physical endpoint 7. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn ep7_clr(&mut self) -> _EP7_CLRW {
                _EP7_CLRW { w: self }
            }
            #[doc = "Bit 9 - Set when USB Bus reset, USB suspend change, or Connect change event occurs. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn dev_stat_clr(&mut self) -> _DEV_STAT_CLRW {
                _DEV_STAT_CLRW { w: self }
            }
            #[doc = "Bit 10 - The command code register (USBCmdCode) is empty (New command can be written). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn cc_empty_clr(&mut self) -> _CC_EMPTY_CLRW {
                _CC_EMPTY_CLRW { w: self }
            }
            #[doc = "Bit 11 - Command data register (USBCmdData) is full (Data can be read now). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn cd_full_clr(&mut self) -> _CD_FULL_CLRW {
                _CD_FULL_CLRW { w: self }
            }
            #[doc = "Bit 12 - The current packet in the endpoint buffer is transferred to the CPU. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn rxendpkt_clr(&mut self) -> _RXENDPKT_CLRW {
                _RXENDPKT_CLRW { w: self }
            }
            #[doc = "Bit 13 - The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is cleared."]
            #[inline]
            pub fn txendpkt_clr(&mut self) -> _TXENDPKT_CLRW {
                _TXENDPKT_CLRW { w: self }
            }
        }
    }
    #[doc = "USB Device Interrupt Set"]
    pub struct DEVINTSET {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Device Interrupt Set"]
    pub mod devintset {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVINTSET {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAME_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAME_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP0_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP0_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP1_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP1_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP2_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP2_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP3_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP3_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP4_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP4_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP5_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP5_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP6_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP6_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _EP7_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _EP7_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DEV_STAT_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DEV_STAT_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CC_EMPTY_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CC_EMPTY_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CD_FULL_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CD_FULL_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXENDPKT_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXENDPKT_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXENDPKT_SETW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXENDPKT_SETW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Frame interrupt . For isochronous packet transfers. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn frame_set(&mut self) -> _FRAME_SETW {
                _FRAME_SETW { w: self }
            }
            #[doc = "Bit 1 - USB core interrupt for physical endpoint 0. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep0_set(&mut self) -> _EP0_SETW {
                _EP0_SETW { w: self }
            }
            #[doc = "Bit 2 - USB core interrupt for physical endpoint 1. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep1_set(&mut self) -> _EP1_SETW {
                _EP1_SETW { w: self }
            }
            #[doc = "Bit 3 - USB core interrupt for physical endpoint 2. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep2_set(&mut self) -> _EP2_SETW {
                _EP2_SETW { w: self }
            }
            #[doc = "Bit 4 - USB core interrupt for physical endpoint 3. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep3_set(&mut self) -> _EP3_SETW {
                _EP3_SETW { w: self }
            }
            #[doc = "Bit 5 - USB core interrupt for physical endpoint 4. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep4_set(&mut self) -> _EP4_SETW {
                _EP4_SETW { w: self }
            }
            #[doc = "Bit 6 - USB core interrupt for physical endpoint 5. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep5_set(&mut self) -> _EP5_SETW {
                _EP5_SETW { w: self }
            }
            #[doc = "Bit 7 - USB core interrupt for physical endpoint 6. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep6_set(&mut self) -> _EP6_SETW {
                _EP6_SETW { w: self }
            }
            #[doc = "Bit 8 - USB core interrupt for physical endpoint 7. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn ep7_set(&mut self) -> _EP7_SETW {
                _EP7_SETW { w: self }
            }
            #[doc = "Bit 9 - Set when USB Bus reset, USB suspend change, or Connect change event occurs. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn dev_stat_set(&mut self) -> _DEV_STAT_SETW {
                _DEV_STAT_SETW { w: self }
            }
            #[doc = "Bit 10 - The command code register (USBCmdCode) is empty (New command can be written). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cc_empty_set(&mut self) -> _CC_EMPTY_SETW {
                _CC_EMPTY_SETW { w: self }
            }
            #[doc = "Bit 11 - Command data register (USBCmdData) is full (Data can be read now). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn cd_full_set(&mut self) -> _CD_FULL_SETW {
                _CD_FULL_SETW { w: self }
            }
            #[doc = "Bit 12 - The current packet in the endpoint buffer is transferred to the CPU. 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn rxendpkt_set(&mut self) -> _RXENDPKT_SETW {
                _RXENDPKT_SETW { w: self }
            }
            #[doc = "Bit 13 - The number of data bytes transferred to the endpoint buffer equals the number of bytes programmed in the TxPacket length register (USBTxPLen). 0 = no effect. 1 = the corresponding bit in USBDevIntSt is set."]
            #[inline]
            pub fn txendpkt_set(&mut self) -> _TXENDPKT_SETW {
                _TXENDPKT_SETW { w: self }
            }
        }
    }
    #[doc = "USB Command Code"]
    pub struct CMDCODE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Command Code"]
    pub mod cmdcode {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CMDCODE {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `CMD_PHASE`"]
        pub enum CMD_PHASEW {
            #[doc = "Write"]
            WRITE,
            #[doc = "Read"]
            READ,
            #[doc = "Command"]
            COMMAND,
        }
        impl CMD_PHASEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    CMD_PHASEW::WRITE => 1,
                    CMD_PHASEW::READ => 2,
                    CMD_PHASEW::COMMAND => 5,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CMD_PHASEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CMD_PHASEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CMD_PHASEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Write"]
            #[inline]
            pub fn write(self) -> &'a mut W {
                self.variant(CMD_PHASEW::WRITE)
            }
            #[doc = "Read"]
            #[inline]
            pub fn read(self) -> &'a mut W {
                self.variant(CMD_PHASEW::READ)
            }
            #[doc = "Command"]
            #[inline]
            pub fn command(self) -> &'a mut W {
                self.variant(CMD_PHASEW::COMMAND)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CODE_WDATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CODE_WDATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 8:15 - Command phase action"]
            #[inline]
            pub fn cmd_phase(&mut self) -> _CMD_PHASEW {
                _CMD_PHASEW { w: self }
            }
            #[doc = "Bits 16:23 - This is a multi-purpose field. When CMD_PHASE is Command or Read, this field contains the code for the command (CMD_CODE). When CMD_PHASE is Write, this field contains the command write data (CMD_WDATA)."]
            #[inline]
            pub fn code_wdata(&mut self) -> _CODE_WDATAW {
                _CODE_WDATAW { w: self }
            }
        }
    }
    #[doc = "USB Command Data"]
    pub struct CMDDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Command Data"]
    pub mod cmddata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::CMDDATA {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CMD_RDATAR {
            bits: u8,
        }
        impl CMD_RDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Command Read Data."]
            #[inline]
            pub fn cmd_rdata(&self) -> CMD_RDATAR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CMD_RDATAR { bits }
            }
        }
    }
    #[doc = "USB Receive Data"]
    pub struct RXDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Receive Data"]
    pub mod rxdata {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXDATA {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RX_DATAR {
            bits: u32,
        }
        impl RX_DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data received."]
            #[inline]
            pub fn rx_data(&self) -> RX_DATAR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                RX_DATAR { bits }
            }
        }
    }
    #[doc = "USB Transmit Data"]
    pub struct TXDATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Transmit Data"]
    pub mod txdata {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXDATA {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _TX_DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TX_DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Transmit Data."]
            #[inline]
            pub fn tx_data(&mut self) -> _TX_DATAW {
                _TX_DATAW { w: self }
            }
        }
    }
    #[doc = "USB Receive Packet Length"]
    pub struct RXPLEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Receive Packet Length"]
    pub mod rxplen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RXPLEN {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct PKT_LNGTHR {
            bits: u16,
        }
        impl PKT_LNGTHR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `DV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DVR {
            #[doc = "Data is invalid."]
            DATA_IS_INVALID,
            #[doc = "Data is valid."]
            DATA_IS_VALID,
        }
        impl DVR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DVR::DATA_IS_INVALID => false,
                    DVR::DATA_IS_VALID => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DVR {
                match value {
                    false => DVR::DATA_IS_INVALID,
                    true => DVR::DATA_IS_VALID,
                }
            }
            #[doc = "Checks if the value of the field is `DATA_IS_INVALID`"]
            #[inline]
            pub fn is_data_is_invalid(&self) -> bool {
                *self == DVR::DATA_IS_INVALID
            }
            #[doc = "Checks if the value of the field is `DATA_IS_VALID`"]
            #[inline]
            pub fn is_data_is_valid(&self) -> bool {
                *self == DVR::DATA_IS_VALID
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:9 - The remaining number of bytes to be read from the currently selected endpoint's buffer. When this field decrements to 0, the RxENDPKT bit will be set in USBDevIntSt."]
            #[inline]
            pub fn pkt_lngth(&self) -> PKT_LNGTHR {
                let bits = {
                    const MASK: u16 = 0x03ff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                PKT_LNGTHR { bits }
            }
            #[doc = "Bit 10 - Data valid. This bit is useful for isochronous endpoints. Non-isochronous endpoints do not raise an interrupt when an erroneous data packet is received. But invalid data packet can be produced with a bus reset. For isochronous endpoints, data transfer will happen even if an erroneous packet is received. In this case DV bit will not be set for the packet."]
            #[inline]
            pub fn dv(&self) -> DVR {
                DVR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "USB Transmit Packet Length"]
    pub struct TXPLENN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Transmit Packet Length"]
    pub mod txplenn {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TXPLENN {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _PKT_LNGTHW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PKT_LNGTHW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0x03ff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:9 - The remaining number of bytes to be written to the selected endpoint buffer. This field is decremented by 4 by hardware after each write to USBTxData. When this field decrements to 0, the TxENDPKT bit will be set in USBDevIntSt."]
            #[inline]
            pub fn pkt_lngth(&mut self) -> _PKT_LNGTHW {
                _PKT_LNGTHW { w: self }
            }
        }
    }
    #[doc = "USB Control"]
    pub struct CTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Control"]
    pub mod ctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RD_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RD_ENR {
            #[doc = "Read mode is disabled."]
            READ_MODE_IS_DISABLE,
            #[doc = "Read mode is enabled."]
            READ_MODE_IS_ENABLED,
        }
        impl RD_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RD_ENR::READ_MODE_IS_DISABLE => false,
                    RD_ENR::READ_MODE_IS_ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RD_ENR {
                match value {
                    false => RD_ENR::READ_MODE_IS_DISABLE,
                    true => RD_ENR::READ_MODE_IS_ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `READ_MODE_IS_DISABLE`"]
            #[inline]
            pub fn is_read_mode_is_disable(&self) -> bool {
                *self == RD_ENR::READ_MODE_IS_DISABLE
            }
            #[doc = "Checks if the value of the field is `READ_MODE_IS_ENABLED`"]
            #[inline]
            pub fn is_read_mode_is_enabled(&self) -> bool {
                *self == RD_ENR::READ_MODE_IS_ENABLED
            }
        }
        #[doc = "Possible values of the field `WR_EN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WR_ENR {
            #[doc = "Write mode is disabled."]
            WRITE_MODE_IS_DISABL,
            #[doc = "Write mode is enabled."]
            WRITE_MODE_IS_ENABLE,
        }
        impl WR_ENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WR_ENR::WRITE_MODE_IS_DISABL => false,
                    WR_ENR::WRITE_MODE_IS_ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WR_ENR {
                match value {
                    false => WR_ENR::WRITE_MODE_IS_DISABL,
                    true => WR_ENR::WRITE_MODE_IS_ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `WRITE_MODE_IS_DISABL`"]
            #[inline]
            pub fn is_write_mode_is_disabl(&self) -> bool {
                *self == WR_ENR::WRITE_MODE_IS_DISABL
            }
            #[doc = "Checks if the value of the field is `WRITE_MODE_IS_ENABLE`"]
            #[inline]
            pub fn is_write_mode_is_enable(&self) -> bool {
                *self == WR_ENR::WRITE_MODE_IS_ENABLE
            }
        }
        #[doc = r" Value of the field"]
        pub struct LOG_ENDPOINTR {
            bits: u8,
        }
        impl LOG_ENDPOINTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `RD_EN`"]
        pub enum RD_ENW {
            #[doc = "Read mode is disabled."]
            READ_MODE_IS_DISABLE,
            #[doc = "Read mode is enabled."]
            READ_MODE_IS_ENABLED,
        }
        impl RD_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RD_ENW::READ_MODE_IS_DISABLE => false,
                    RD_ENW::READ_MODE_IS_ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RD_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RD_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RD_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read mode is disabled."]
            #[inline]
            pub fn read_mode_is_disable(self) -> &'a mut W {
                self.variant(RD_ENW::READ_MODE_IS_DISABLE)
            }
            #[doc = "Read mode is enabled."]
            #[inline]
            pub fn read_mode_is_enabled(self) -> &'a mut W {
                self.variant(RD_ENW::READ_MODE_IS_ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WR_EN`"]
        pub enum WR_ENW {
            #[doc = "Write mode is disabled."]
            WRITE_MODE_IS_DISABL,
            #[doc = "Write mode is enabled."]
            WRITE_MODE_IS_ENABLE,
        }
        impl WR_ENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WR_ENW::WRITE_MODE_IS_DISABL => false,
                    WR_ENW::WRITE_MODE_IS_ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WR_ENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WR_ENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WR_ENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Write mode is disabled."]
            #[inline]
            pub fn write_mode_is_disabl(self) -> &'a mut W {
                self.variant(WR_ENW::WRITE_MODE_IS_DISABL)
            }
            #[doc = "Write mode is enabled."]
            #[inline]
            pub fn write_mode_is_enable(self) -> &'a mut W {
                self.variant(WR_ENW::WRITE_MODE_IS_ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _LOG_ENDPOINTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LOG_ENDPOINTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Read mode control. Enables reading data from the OUT endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBRxData register. This bit is cleared by hardware when the last word of the current packet is read from USBRxData."]
            #[inline]
            pub fn rd_en(&self) -> RD_ENR {
                RD_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Write mode control. Enables writing data to the IN endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBTxData register. This bit is cleared by hardware when the number of bytes in USBTxLen have been sent."]
            #[inline]
            pub fn wr_en(&self) -> WR_ENR {
                WR_ENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 2:5 - Logical Endpoint number."]
            #[inline]
            pub fn log_endpoint(&self) -> LOG_ENDPOINTR {
                let bits = {
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                LOG_ENDPOINTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Read mode control. Enables reading data from the OUT endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBRxData register. This bit is cleared by hardware when the last word of the current packet is read from USBRxData."]
            #[inline]
            pub fn rd_en(&mut self) -> _RD_ENW {
                _RD_ENW { w: self }
            }
            #[doc = "Bit 1 - Write mode control. Enables writing data to the IN endpoint buffer for the endpoint specified in the LOG_ENDPOINT field using the USBTxData register. This bit is cleared by hardware when the number of bytes in USBTxLen have been sent."]
            #[inline]
            pub fn wr_en(&mut self) -> _WR_ENW {
                _WR_ENW { w: self }
            }
            #[doc = "Bits 2:5 - Logical Endpoint number."]
            #[inline]
            pub fn log_endpoint(&mut self) -> _LOG_ENDPOINTW {
                _LOG_ENDPOINTW { w: self }
            }
        }
    }
    #[doc = "USB Device FIQ select"]
    pub struct DEVFIQSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB Device FIQ select"]
    pub mod devfiqsel {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DEVFIQSEL {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = "Values that can be written to the field `FRAME`"]
        pub enum FRAMEW {
            #[doc = "FRAME interrupt will be routed to the low-priority interrupt line IRQ."]
            LOWPRIORITY,
            #[doc = "FRAME interrupt will be routed to the high-priority interrupt line FIQ."]
            HIGHPRIORITY,
        }
        impl FRAMEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FRAMEW::LOWPRIORITY => false,
                    FRAMEW::HIGHPRIORITY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRAMEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRAMEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FRAMEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "FRAME interrupt will be routed to the low-priority interrupt line IRQ."]
            #[inline]
            pub fn lowpriority(self) -> &'a mut W {
                self.variant(FRAMEW::LOWPRIORITY)
            }
            #[doc = "FRAME interrupt will be routed to the high-priority interrupt line FIQ."]
            #[inline]
            pub fn highpriority(self) -> &'a mut W {
                self.variant(FRAMEW::HIGHPRIORITY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BULKOUT`"]
        pub enum BULKOUTW {
            #[doc = "BULKOUT interrupt will be routed to the low-priority interrupt line IRQ."]
            LOWPRIORITY,
            #[doc = "BULKOUT interrupt will be routed to the high-priority interrupt line FIQ."]
            HIGHPRIORITY,
        }
        impl BULKOUTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BULKOUTW::LOWPRIORITY => false,
                    BULKOUTW::HIGHPRIORITY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BULKOUTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BULKOUTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BULKOUTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "BULKOUT interrupt will be routed to the low-priority interrupt line IRQ."]
            #[inline]
            pub fn lowpriority(self) -> &'a mut W {
                self.variant(BULKOUTW::LOWPRIORITY)
            }
            #[doc = "BULKOUT interrupt will be routed to the high-priority interrupt line FIQ."]
            #[inline]
            pub fn highpriority(self) -> &'a mut W {
                self.variant(BULKOUTW::HIGHPRIORITY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BULKIN`"]
        pub enum BULKINW {
            #[doc = "BULKIN interrupt will be routed to the low-priority interrupt line IRQ."]
            LOWPRIORITY,
            #[doc = "BULKIN interrupt will be routed to the high-priority interrupt line FIQ."]
            HIGHPRIORITY,
        }
        impl BULKINW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BULKINW::LOWPRIORITY => false,
                    BULKINW::HIGHPRIORITY => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BULKINW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BULKINW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BULKINW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "BULKIN interrupt will be routed to the low-priority interrupt line IRQ."]
            #[inline]
            pub fn lowpriority(self) -> &'a mut W {
                self.variant(BULKINW::LOWPRIORITY)
            }
            #[doc = "BULKIN interrupt will be routed to the high-priority interrupt line FIQ."]
            #[inline]
            pub fn highpriority(self) -> &'a mut W {
                self.variant(BULKINW::HIGHPRIORITY)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - This interrupt comes from a 1 KHz free running clock resynchronized on the incoming SoF tokens. This is to be used for isochronous packet transfer."]
            #[inline]
            pub fn frame(&mut self) -> _FRAMEW {
                _FRAMEW { w: self }
            }
            #[doc = "Bit 1 - Interrupt routing for bulk out endpoints For logical endpoint 3 (physical endpoints 6 and 7) only."]
            #[inline]
            pub fn bulkout(&mut self) -> _BULKOUTW {
                _BULKOUTW { w: self }
            }
            #[doc = "Bit 2 - Interrupt routing for bulk in endpoints For logical endpoint 3 (physical endpoints 6 and 7) only."]
            #[inline]
            pub fn bulkin(&mut self) -> _BULKINW {
                _BULKINW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Power Management Unit (PMU) Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct PMU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PMU {}
impl PMU {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const pmu::RegisterBlock {
        0x4003_8000 as *const _
    }
}
impl Deref for PMU {
    type Target = pmu::RegisterBlock;
    fn deref(&self) -> &pmu::RegisterBlock {
        unsafe { &*PMU::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Power Management Unit (PMU) Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod pmu {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Power control register"]
        pub pcon: PCON,
        #[doc = "0x04 - General purpose register"]
        pub gpreg: [GPREG; 4],
        #[doc = "0x14 - General purpose register 4"]
        pub gpreg4: GPREG4,
    }
    #[doc = "Power control register"]
    pub struct PCON {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power control register"]
    pub mod pcon {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PCON {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DPDEN`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DPDENR {
            #[doc = "ARM WFI will enter Sleep or Deep-sleep mode (clock to ARM Cortex-M3 core turned off)."]
            SLEEP_DEEPSLEEP,
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M3 core powered-down)."]
            DEEPPOWERDOWN,
        }
        impl DPDENR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DPDENR::SLEEP_DEEPSLEEP => false,
                    DPDENR::DEEPPOWERDOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DPDENR {
                match value {
                    false => DPDENR::SLEEP_DEEPSLEEP,
                    true => DPDENR::DEEPPOWERDOWN,
                }
            }
            #[doc = "Checks if the value of the field is `SLEEP_DEEPSLEEP`"]
            #[inline]
            pub fn is_sleep_deepsleep(&self) -> bool {
                *self == DPDENR::SLEEP_DEEPSLEEP
            }
            #[doc = "Checks if the value of the field is `DEEPPOWERDOWN`"]
            #[inline]
            pub fn is_deeppowerdown(&self) -> bool {
                *self == DPDENR::DEEPPOWERDOWN
            }
        }
        #[doc = "Possible values of the field `SLEEPFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SLEEPFLAGR {
            #[doc = "Read: No power-down mode entered. LPC13xx is in Run mode. Write: No effect."]
            NO_POWER_DOWN,
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            POWERDOWN,
        }
        impl SLEEPFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SLEEPFLAGR::NO_POWER_DOWN => false,
                    SLEEPFLAGR::POWERDOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SLEEPFLAGR {
                match value {
                    false => SLEEPFLAGR::NO_POWER_DOWN,
                    true => SLEEPFLAGR::POWERDOWN,
                }
            }
            #[doc = "Checks if the value of the field is `NO_POWER_DOWN`"]
            #[inline]
            pub fn is_no_power_down(&self) -> bool {
                *self == SLEEPFLAGR::NO_POWER_DOWN
            }
            #[doc = "Checks if the value of the field is `POWERDOWN`"]
            #[inline]
            pub fn is_powerdown(&self) -> bool {
                *self == SLEEPFLAGR::POWERDOWN
            }
        }
        #[doc = "Possible values of the field `DPDFLAG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DPDFLAGR {
            #[doc = "Read: Deep power-down mode  not entered. Write: No effect."]
            NO_DEEPPOWERDOWN,
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            DEEPPOWERDOWN,
        }
        impl DPDFLAGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    DPDFLAGR::NO_DEEPPOWERDOWN => false,
                    DPDFLAGR::DEEPPOWERDOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> DPDFLAGR {
                match value {
                    false => DPDFLAGR::NO_DEEPPOWERDOWN,
                    true => DPDFLAGR::DEEPPOWERDOWN,
                }
            }
            #[doc = "Checks if the value of the field is `NO_DEEPPOWERDOWN`"]
            #[inline]
            pub fn is_no_deeppowerdown(&self) -> bool {
                *self == DPDFLAGR::NO_DEEPPOWERDOWN
            }
            #[doc = "Checks if the value of the field is `DEEPPOWERDOWN`"]
            #[inline]
            pub fn is_deeppowerdown(&self) -> bool {
                *self == DPDFLAGR::DEEPPOWERDOWN
            }
        }
        #[doc = "Values that can be written to the field `DPDEN`"]
        pub enum DPDENW {
            #[doc = "ARM WFI will enter Sleep or Deep-sleep mode (clock to ARM Cortex-M3 core turned off)."]
            SLEEP_DEEPSLEEP,
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M3 core powered-down)."]
            DEEPPOWERDOWN,
        }
        impl DPDENW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DPDENW::SLEEP_DEEPSLEEP => false,
                    DPDENW::DEEPPOWERDOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPDENW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPDENW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DPDENW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "ARM WFI will enter Sleep or Deep-sleep mode (clock to ARM Cortex-M3 core turned off)."]
            #[inline]
            pub fn sleep_deepsleep(self) -> &'a mut W {
                self.variant(DPDENW::SLEEP_DEEPSLEEP)
            }
            #[doc = "ARM WFI will enter Deep-power down mode (ARM Cortex-M3 core powered-down)."]
            #[inline]
            pub fn deeppowerdown(self) -> &'a mut W {
                self.variant(DPDENW::DEEPPOWERDOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SLEEPFLAG`"]
        pub enum SLEEPFLAGW {
            #[doc = "Read: No power-down mode entered. LPC13xx is in Run mode. Write: No effect."]
            NO_POWER_DOWN,
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            POWERDOWN,
        }
        impl SLEEPFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SLEEPFLAGW::NO_POWER_DOWN => false,
                    SLEEPFLAGW::POWERDOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SLEEPFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SLEEPFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SLEEPFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read: No power-down mode entered. LPC13xx is in Run mode. Write: No effect."]
            #[inline]
            pub fn no_power_down(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::NO_POWER_DOWN)
            }
            #[doc = "Read: Sleep/Deep-sleep or Deep power-down mode entered. Write: Writing a 1 clears the SLEEPFLAG bit to 0."]
            #[inline]
            pub fn powerdown(self) -> &'a mut W {
                self.variant(SLEEPFLAGW::POWERDOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `DPDFLAG`"]
        pub enum DPDFLAGW {
            #[doc = "Read: Deep power-down mode  not entered. Write: No effect."]
            NO_DEEPPOWERDOWN,
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            DEEPPOWERDOWN,
        }
        impl DPDFLAGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    DPDFLAGW::NO_DEEPPOWERDOWN => false,
                    DPDFLAGW::DEEPPOWERDOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DPDFLAGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DPDFLAGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DPDFLAGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Read: Deep power-down mode not entered. Write: No effect."]
            #[inline]
            pub fn no_deeppowerdown(self) -> &'a mut W {
                self.variant(DPDFLAGW::NO_DEEPPOWERDOWN)
            }
            #[doc = "Read: Deep power-down mode entered. Write: Clear the Deep power-down flag."]
            #[inline]
            pub fn deeppowerdown(self) -> &'a mut W {
                self.variant(DPDFLAGW::DEEPPOWERDOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 1 - Deep power-down mode enable"]
            #[inline]
            pub fn dpden(&self) -> DPDENR {
                DPDENR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline]
            pub fn sleepflag(&self) -> SLEEPFLAGR {
                SLEEPFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline]
            pub fn dpdflag(&self) -> DPDFLAGR {
                DPDFLAGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 1 - Deep power-down mode enable"]
            #[inline]
            pub fn dpden(&mut self) -> _DPDENW {
                _DPDENW { w: self }
            }
            #[doc = "Bit 8 - Sleep mode flag"]
            #[inline]
            pub fn sleepflag(&mut self) -> _SLEEPFLAGW {
                _SLEEPFLAGW { w: self }
            }
            #[doc = "Bit 11 - Deep power-down flag"]
            #[inline]
            pub fn dpdflag(&mut self) -> _DPDFLAGW {
                _DPDFLAGW { w: self }
            }
        }
    }
    #[doc = "General purpose register"]
    pub struct GPREG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "General purpose register"]
    pub mod gpreg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GPREG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPDATAR {
            bits: u32,
        }
        impl GPDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPDATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPDATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0xffff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&self) -> GPDATAR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                GPDATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&mut self) -> _GPDATAW {
                _GPDATAW { w: self }
            }
        }
    }
    #[doc = "General purpose register 4"]
    pub struct GPREG4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "General purpose register 4"]
    pub mod gpreg4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::GPREG4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `WAKEUPHYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKEUPHYSR {
            #[doc = "Hysteresis for WAKUP pin disabled."]
            DISABLED,
            #[doc = "Hysteresis for WAKEUP pin enabled."]
            ENABLED,
        }
        impl WAKEUPHYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WAKEUPHYSR::DISABLED => false,
                    WAKEUPHYSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WAKEUPHYSR {
                match value {
                    false => WAKEUPHYSR::DISABLED,
                    true => WAKEUPHYSR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WAKEUPHYSR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WAKEUPHYSR::ENABLED
            }
        }
        #[doc = r" Value of the field"]
        pub struct GPDATAR {
            bits: u32,
        }
        impl GPDATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `WAKEUPHYS`"]
        pub enum WAKEUPHYSW {
            #[doc = "Hysteresis for WAKUP pin disabled."]
            DISABLED,
            #[doc = "Hysteresis for WAKEUP pin enabled."]
            ENABLED,
        }
        impl WAKEUPHYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WAKEUPHYSW::DISABLED => false,
                    WAKEUPHYSW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WAKEUPHYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WAKEUPHYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WAKEUPHYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Hysteresis for WAKUP pin disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::DISABLED)
            }
            #[doc = "Hysteresis for WAKEUP pin enabled."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAKEUPHYSW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPDATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPDATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x001f_ffff;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 10 - WAKEUP pin hysteresis enable"]
            #[inline]
            pub fn wakeuphys(&self) -> WAKEUPHYSR {
                WAKEUPHYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 11:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&self) -> GPDATAR {
                let bits = {
                    const MASK: u32 = 0x001f_ffff;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                GPDATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 10 - WAKEUP pin hysteresis enable"]
            #[inline]
            pub fn wakeuphys(&mut self) -> _WAKEUPHYSW {
                _WAKEUPHYSW { w: self }
            }
            #[doc = "Bits 11:31 - Data retained during Deep power-down mode."]
            #[inline]
            pub fn gpdata(&mut self) -> _GPDATAW {
                _GPDATAW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Flash memory programming firmware Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct FMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FMC {}
impl FMC {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const fmc::RegisterBlock {
        0x4003_c000 as *const _
    }
}
impl Deref for FMC {
    type Target = fmc::RegisterBlock;
    fn deref(&self) -> &fmc::RegisterBlock {
        unsafe { &*FMC::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx Flash memory programming firmware Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod fmc {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16usize],
        #[doc = "0x10 - Flash configuration register"]
        pub flashcfg: FLASHCFG,
        _reserved1: [u8; 12usize],
        #[doc = "0x20 - Signature start address register"]
        pub fmsstart: FMSSTART,
        #[doc = "0x24 - Signature stop-address register"]
        pub fmsstop: FMSSTOP,
        _reserved2: [u8; 4usize],
        #[doc = "0x2c - Word 0 [31:0]"]
        pub fmsw0: FMSW0,
        #[doc = "0x30 - Word 1 [63:32]"]
        pub fmsw1: FMSW1,
        #[doc = "0x34 - Word 2 [95:64]"]
        pub fmsw2: FMSW2,
        #[doc = "0x38 - Word 3 [127:96]"]
        pub fmsw3: FMSW3,
        _reserved3: [u8; 4004usize],
        #[doc = "0xfe0 - Signature generation status register"]
        pub fmstat: FMSTAT,
        _reserved4: [u8; 4usize],
        #[doc = "0xfe8 - Signature generation status clear register"]
        pub fmstatclr: FMSTATCLR,
    }
    #[doc = "Flash configuration register"]
    pub struct FLASHCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Flash configuration register"]
    pub mod flashcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FLASHCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FLASHTIM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHTIMR {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "3 system clocks flash access time (for system clock frequencies of up to 72 MHz)."]
            _3_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED,
        }
        impl FLASHTIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FLASHTIMR::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS => 0x01,
                    FLASHTIMR::_3_SYSTEM_CLOCKS_FLAS => 0x02,
                    FLASHTIMR::RESERVED => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FLASHTIMR {
                match value {
                    0 => FLASHTIMR::_1_SYSTEM_CLOCK_FLASH,
                    1 => FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS,
                    2 => FLASHTIMR::_3_SYSTEM_CLOCKS_FLAS,
                    3 => FLASHTIMR::RESERVED,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `_1_SYSTEM_CLOCK_FLASH`"]
            #[inline]
            pub fn is_1_system_clock_flash(&self) -> bool {
                *self == FLASHTIMR::_1_SYSTEM_CLOCK_FLASH
            }
            #[doc = "Checks if the value of the field is `_2_SYSTEM_CLOCKS_FLAS`"]
            #[inline]
            pub fn is_2_system_clocks_flas(&self) -> bool {
                *self == FLASHTIMR::_2_SYSTEM_CLOCKS_FLAS
            }
            #[doc = "Checks if the value of the field is `_3_SYSTEM_CLOCKS_FLAS`"]
            #[inline]
            pub fn is_3_system_clocks_flas(&self) -> bool {
                *self == FLASHTIMR::_3_SYSTEM_CLOCKS_FLAS
            }
            #[doc = "Checks if the value of the field is `RESERVED`"]
            #[inline]
            pub fn is_reserved(&self) -> bool {
                *self == FLASHTIMR::RESERVED
            }
        }
        #[doc = "Values that can be written to the field `FLASHTIM`"]
        pub enum FLASHTIMW {
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            _1_SYSTEM_CLOCK_FLASH,
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)."]
            _2_SYSTEM_CLOCKS_FLAS,
            #[doc = "3 system clocks flash access time (for system clock frequencies of up to 72 MHz)."]
            _3_SYSTEM_CLOCKS_FLAS,
            #[doc = "Reserved."]
            RESERVED,
        }
        impl FLASHTIMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FLASHTIMW::_1_SYSTEM_CLOCK_FLASH => 0,
                    FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS => 1,
                    FLASHTIMW::_3_SYSTEM_CLOCKS_FLAS => 2,
                    FLASHTIMW::RESERVED => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHTIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHTIMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHTIMW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "1 system clock flash access time (for system clock frequencies of up to 20 MHz)."]
            #[inline]
            pub fn _1_system_clock_flash(self) -> &'a mut W {
                self.variant(FLASHTIMW::_1_SYSTEM_CLOCK_FLASH)
            }
            #[doc = "2 system clocks flash access time (for system clock frequencies of up to 40 MHz)."]
            #[inline]
            pub fn _2_system_clocks_flas(self) -> &'a mut W {
                self.variant(FLASHTIMW::_2_SYSTEM_CLOCKS_FLAS)
            }
            #[doc = "3 system clocks flash access time (for system clock frequencies of up to 72 MHz)."]
            #[inline]
            pub fn _3_system_clocks_flas(self) -> &'a mut W {
                self.variant(FLASHTIMW::_3_SYSTEM_CLOCKS_FLAS)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved(self) -> &'a mut W {
                self.variant(FLASHTIMW::RESERVED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline]
            pub fn flashtim(&self) -> FLASHTIMR {
                FLASHTIMR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Flash memory access time. FLASHTIM +1 is equal to the number of system clocks used for flash access."]
            #[inline]
            pub fn flashtim(&mut self) -> _FLASHTIMW {
                _FLASHTIMW { w: self }
            }
        }
    }
    #[doc = "Signature start address register"]
    pub struct FMSSTART {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature start address register"]
    pub mod fmsstart {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTART {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STARTR {
            bits: u32,
        }
        impl STARTR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STARTW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0001_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline]
            pub fn start(&self) -> STARTR {
                let bits = {
                    const MASK: u32 = 0x0001_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STARTR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - Signature generation start address (corresponds to AHB byte address bits[20:4])."]
            #[inline]
            pub fn start(&mut self) -> _STARTW {
                _STARTW { w: self }
            }
        }
    }
    #[doc = "Signature stop-address register"]
    pub struct FMSSTOP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature stop-address register"]
    pub mod fmsstop {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSSTOP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct STOPR {
            bits: u32,
        }
        impl STOPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `SIG_START`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SIG_STARTR {
            #[doc = "Signature generation is stopped"]
            SIGNATURE_GENERATION,
            #[doc = "Initiate signature generation"]
            INITIATE_SIGNATURE_G,
        }
        impl SIG_STARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SIG_STARTR::SIGNATURE_GENERATION => false,
                    SIG_STARTR::INITIATE_SIGNATURE_G => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SIG_STARTR {
                match value {
                    false => SIG_STARTR::SIGNATURE_GENERATION,
                    true => SIG_STARTR::INITIATE_SIGNATURE_G,
                }
            }
            #[doc = "Checks if the value of the field is `SIGNATURE_GENERATION`"]
            #[inline]
            pub fn is_signature_generation(&self) -> bool {
                *self == SIG_STARTR::SIGNATURE_GENERATION
            }
            #[doc = "Checks if the value of the field is `INITIATE_SIGNATURE_G`"]
            #[inline]
            pub fn is_initiate_signature_g(&self) -> bool {
                *self == SIG_STARTR::INITIATE_SIGNATURE_G
            }
        }
        #[doc = r" Proxy"]
        pub struct _STOPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _STOPW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x0001_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SIG_START`"]
        pub enum SIG_STARTW {
            #[doc = "Signature generation is stopped"]
            SIGNATURE_GENERATION,
            #[doc = "Initiate signature generation"]
            INITIATE_SIGNATURE_G,
        }
        impl SIG_STARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SIG_STARTW::SIGNATURE_GENERATION => false,
                    SIG_STARTW::INITIATE_SIGNATURE_G => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SIG_STARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SIG_STARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SIG_STARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Signature generation is stopped"]
            #[inline]
            pub fn signature_generation(self) -> &'a mut W {
                self.variant(SIG_STARTW::SIGNATURE_GENERATION)
            }
            #[doc = "Initiate signature generation"]
            #[inline]
            pub fn initiate_signature_g(self) -> &'a mut W {
                self.variant(SIG_STARTW::INITIATE_SIGNATURE_G)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:16 - BIST stop address divided by 16 (corresponds to AHB byte address [20:4])."]
            #[inline]
            pub fn stop(&self) -> STOPR {
                let bits = {
                    const MASK: u32 = 0x0001_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                STOPR { bits }
            }
            #[doc = "Bit 17 - Start control bit for signature generation."]
            #[inline]
            pub fn sig_start(&self) -> SIG_STARTR {
                SIG_STARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:16 - BIST stop address divided by 16 (corresponds to AHB byte address [20:4])."]
            #[inline]
            pub fn stop(&mut self) -> _STOPW {
                _STOPW { w: self }
            }
            #[doc = "Bit 17 - Start control bit for signature generation."]
            #[inline]
            pub fn sig_start(&mut self) -> _SIG_STARTW {
                _SIG_STARTW { w: self }
            }
        }
    }
    #[doc = "Word 0 [31:0]"]
    pub struct FMSW0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Word 0 [31:0]"]
    pub mod fmsw0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SW0_31_0R {
            bits: u32,
        }
        impl SW0_31_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Word 0 of 128-bit signature (bits 31 to 0)."]
            #[inline]
            pub fn sw0_31_0(&self) -> SW0_31_0R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SW0_31_0R { bits }
            }
        }
    }
    #[doc = "Word 1 [63:32]"]
    pub struct FMSW1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Word 1 [63:32]"]
    pub mod fmsw1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SW1_63_32R {
            bits: u32,
        }
        impl SW1_63_32R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Word 1 of 128-bit signature (bits 63 to 32)."]
            #[inline]
            pub fn sw1_63_32(&self) -> SW1_63_32R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SW1_63_32R { bits }
            }
        }
    }
    #[doc = "Word 2 [95:64]"]
    pub struct FMSW2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Word 2 [95:64]"]
    pub mod fmsw2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW2 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SW2_95_64R {
            bits: u32,
        }
        impl SW2_95_64R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Word 2 of 128-bit signature (bits 95 to 64)."]
            #[inline]
            pub fn sw2_95_64(&self) -> SW2_95_64R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SW2_95_64R { bits }
            }
        }
    }
    #[doc = "Word 3 [127:96]"]
    pub struct FMSW3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Word 3 [127:96]"]
    pub mod fmsw3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSW3 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SW3_127_96R {
            bits: u32,
        }
        impl SW3_127_96R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Word 3 of 128-bit signature (bits 127 to 96)."]
            #[inline]
            pub fn sw3_127_96(&self) -> SW3_127_96R {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                SW3_127_96R { bits }
            }
        }
    }
    #[doc = "Signature generation status register"]
    pub struct FMSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature generation status register"]
    pub mod fmstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::FMSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SIG_DONER {
            bits: bool,
        }
        impl SIG_DONER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 2 - When 1, a previously started signature generation has completed. See FMSTATCLR register description for clearing this flag."]
            #[inline]
            pub fn sig_done(&self) -> SIG_DONER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SIG_DONER { bits }
            }
        }
    }
    #[doc = "Signature generation status clear register"]
    pub struct FMSTATCLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Signature generation status clear register"]
    pub mod fmstatclr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::FMSTATCLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _SIG_DONE_CLRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SIG_DONE_CLRW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 2 - Writing a 1 to this bits clears the signature generation completion flag (SIG_DONE) in the FMSTAT register."]
            #[inline]
            pub fn sig_done_clr(&mut self) -> _SIG_DONE_CLRW {
                _SIG_DONE_CLRW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx SSP0/1 Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct SSP0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SSP0 {}
impl SSP0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ssp0::RegisterBlock {
        0x4004_0000 as *const _
    }
}
impl Deref for SSP0 {
    type Target = ssp0::RegisterBlock;
    fn deref(&self) -> &ssp0::RegisterBlock {
        unsafe { &*SSP0::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx SSP0/1 Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod ssp0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - Control Register 0. Selects the serial clock rate, bus type, and data size."]
        pub cr0: CR0,
        #[doc = "0x04 - Control Register 1. Selects master/slave and other modes."]
        pub cr1: CR1,
        #[doc = "0x08 - Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO."]
        pub dr: DR,
        #[doc = "0x0c - Status Register."]
        pub sr: SR,
        #[doc = "0x10 - Clock Prescale Register."]
        pub cpsr: CPSR,
        #[doc = "0x14 - Interrupt Mask Set and Clear Register."]
        pub imsc: IMSC,
        #[doc = "0x18 - Raw Interrupt Status Register."]
        pub ris: RIS,
        #[doc = "0x1c - Masked Interrupt Status Register."]
        pub mis: MIS,
        #[doc = "0x20 - SSPICR Interrupt Clear Register."]
        pub icr: ICR,
    }
    #[doc = "Control Register 0. Selects the serial clock rate, bus type, and data size."]
    pub struct CR0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 0. Selects the serial clock rate, bus type, and data size."]
    pub mod cr0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DSS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DSSR {
            #[doc = "4-bit transfer"]
            _4_BIT_TRANSFER,
            #[doc = "5-bit transfer"]
            _5_BIT_TRANSFER,
            #[doc = "6-bit transfer"]
            _6_BIT_TRANSFER,
            #[doc = "7-bit transfer"]
            _7_BIT_TRANSFER,
            #[doc = "8-bit transfer"]
            _8_BIT_TRANSFER,
            #[doc = "9-bit transfer"]
            _9_BIT_TRANSFER,
            #[doc = "10-bit transfer"]
            _10_BIT_TRANSFER,
            #[doc = "11-bit transfer"]
            _11_BIT_TRANSFER,
            #[doc = "12-bit transfer"]
            _12_BIT_TRANSFER,
            #[doc = "13-bit transfer"]
            _13_BIT_TRANSFER,
            #[doc = "14-bit transfer"]
            _14_BIT_TRANSFER,
            #[doc = "15-bit transfer"]
            _15_BIT_TRANSFER,
            #[doc = "16-bit transfer"]
            _16_BIT_TRANSFER,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl DSSR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DSSR::_4_BIT_TRANSFER => 0x03,
                    DSSR::_5_BIT_TRANSFER => 0x04,
                    DSSR::_6_BIT_TRANSFER => 0x05,
                    DSSR::_7_BIT_TRANSFER => 0x06,
                    DSSR::_8_BIT_TRANSFER => 0x07,
                    DSSR::_9_BIT_TRANSFER => 0x08,
                    DSSR::_10_BIT_TRANSFER => 0x09,
                    DSSR::_11_BIT_TRANSFER => 0x0a,
                    DSSR::_12_BIT_TRANSFER => 0x0b,
                    DSSR::_13_BIT_TRANSFER => 0x0c,
                    DSSR::_14_BIT_TRANSFER => 0x0d,
                    DSSR::_15_BIT_TRANSFER => 0x0e,
                    DSSR::_16_BIT_TRANSFER => 0x0f,
                    DSSR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DSSR {
                match value {
                    3 => DSSR::_4_BIT_TRANSFER,
                    4 => DSSR::_5_BIT_TRANSFER,
                    5 => DSSR::_6_BIT_TRANSFER,
                    6 => DSSR::_7_BIT_TRANSFER,
                    7 => DSSR::_8_BIT_TRANSFER,
                    8 => DSSR::_9_BIT_TRANSFER,
                    9 => DSSR::_10_BIT_TRANSFER,
                    10 => DSSR::_11_BIT_TRANSFER,
                    11 => DSSR::_12_BIT_TRANSFER,
                    12 => DSSR::_13_BIT_TRANSFER,
                    13 => DSSR::_14_BIT_TRANSFER,
                    14 => DSSR::_15_BIT_TRANSFER,
                    15 => DSSR::_16_BIT_TRANSFER,
                    i => DSSR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_4_BIT_TRANSFER`"]
            #[inline]
            pub fn is_4_bit_transfer(&self) -> bool {
                *self == DSSR::_4_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_5_BIT_TRANSFER`"]
            #[inline]
            pub fn is_5_bit_transfer(&self) -> bool {
                *self == DSSR::_5_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_6_BIT_TRANSFER`"]
            #[inline]
            pub fn is_6_bit_transfer(&self) -> bool {
                *self == DSSR::_6_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_7_BIT_TRANSFER`"]
            #[inline]
            pub fn is_7_bit_transfer(&self) -> bool {
                *self == DSSR::_7_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_8_BIT_TRANSFER`"]
            #[inline]
            pub fn is_8_bit_transfer(&self) -> bool {
                *self == DSSR::_8_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_9_BIT_TRANSFER`"]
            #[inline]
            pub fn is_9_bit_transfer(&self) -> bool {
                *self == DSSR::_9_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_10_BIT_TRANSFER`"]
            #[inline]
            pub fn is_10_bit_transfer(&self) -> bool {
                *self == DSSR::_10_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_11_BIT_TRANSFER`"]
            #[inline]
            pub fn is_11_bit_transfer(&self) -> bool {
                *self == DSSR::_11_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_12_BIT_TRANSFER`"]
            #[inline]
            pub fn is_12_bit_transfer(&self) -> bool {
                *self == DSSR::_12_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_13_BIT_TRANSFER`"]
            #[inline]
            pub fn is_13_bit_transfer(&self) -> bool {
                *self == DSSR::_13_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_14_BIT_TRANSFER`"]
            #[inline]
            pub fn is_14_bit_transfer(&self) -> bool {
                *self == DSSR::_14_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_15_BIT_TRANSFER`"]
            #[inline]
            pub fn is_15_bit_transfer(&self) -> bool {
                *self == DSSR::_15_BIT_TRANSFER
            }
            #[doc = "Checks if the value of the field is `_16_BIT_TRANSFER`"]
            #[inline]
            pub fn is_16_bit_transfer(&self) -> bool {
                *self == DSSR::_16_BIT_TRANSFER
            }
        }
        #[doc = "Possible values of the field `FRF`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FRFR {
            #[doc = "SPI"]
            SPI,
            #[doc = "TI"]
            TI,
            #[doc = "Microwire"]
            MICROWIRE,
            #[doc = "This combination is not supported and should not be used."]
            THIS_COMBINATION_IS,
        }
        impl FRFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FRFR::SPI => 0,
                    FRFR::TI => 0x01,
                    FRFR::MICROWIRE => 0x02,
                    FRFR::THIS_COMBINATION_IS => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FRFR {
                match value {
                    0 => FRFR::SPI,
                    1 => FRFR::TI,
                    2 => FRFR::MICROWIRE,
                    3 => FRFR::THIS_COMBINATION_IS,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SPI`"]
            #[inline]
            pub fn is_spi(&self) -> bool {
                *self == FRFR::SPI
            }
            #[doc = "Checks if the value of the field is `TI`"]
            #[inline]
            pub fn is_ti(&self) -> bool {
                *self == FRFR::TI
            }
            #[doc = "Checks if the value of the field is `MICROWIRE`"]
            #[inline]
            pub fn is_microwire(&self) -> bool {
                *self == FRFR::MICROWIRE
            }
            #[doc = "Checks if the value of the field is `THIS_COMBINATION_IS`"]
            #[inline]
            pub fn is_this_combination_is(&self) -> bool {
                *self == FRFR::THIS_COMBINATION_IS
            }
        }
        #[doc = "Possible values of the field `CPOL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOLR {
            #[doc = "SSP controller maintains the bus clock low between frames."]
            LOW,
            #[doc = "SSP controller maintains the bus clock high between frames."]
            HIGH,
        }
        impl CPOLR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPOLR::LOW => false,
                    CPOLR::HIGH => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPOLR {
                match value {
                    false => CPOLR::LOW,
                    true => CPOLR::HIGH,
                }
            }
            #[doc = "Checks if the value of the field is `LOW`"]
            #[inline]
            pub fn is_low(&self) -> bool {
                *self == CPOLR::LOW
            }
            #[doc = "Checks if the value of the field is `HIGH`"]
            #[inline]
            pub fn is_high(&self) -> bool {
                *self == CPOLR::HIGH
            }
        }
        #[doc = "Possible values of the field `CPHA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHAR {
            #[doc = "SSP controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line."]
            FIRSTCLOCK,
            #[doc = "SSP controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line."]
            SECONDCLOK,
        }
        impl CPHAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CPHAR::FIRSTCLOCK => false,
                    CPHAR::SECONDCLOK => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CPHAR {
                match value {
                    false => CPHAR::FIRSTCLOCK,
                    true => CPHAR::SECONDCLOK,
                }
            }
            #[doc = "Checks if the value of the field is `FIRSTCLOCK`"]
            #[inline]
            pub fn is_firstclock(&self) -> bool {
                *self == CPHAR::FIRSTCLOCK
            }
            #[doc = "Checks if the value of the field is `SECONDCLOK`"]
            #[inline]
            pub fn is_secondclok(&self) -> bool {
                *self == CPHAR::SECONDCLOK
            }
        }
        #[doc = r" Value of the field"]
        pub struct SCRR {
            bits: u8,
        }
        impl SCRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `DSS`"]
        pub enum DSSW {
            #[doc = "4-bit transfer"]
            _4_BIT_TRANSFER,
            #[doc = "5-bit transfer"]
            _5_BIT_TRANSFER,
            #[doc = "6-bit transfer"]
            _6_BIT_TRANSFER,
            #[doc = "7-bit transfer"]
            _7_BIT_TRANSFER,
            #[doc = "8-bit transfer"]
            _8_BIT_TRANSFER,
            #[doc = "9-bit transfer"]
            _9_BIT_TRANSFER,
            #[doc = "10-bit transfer"]
            _10_BIT_TRANSFER,
            #[doc = "11-bit transfer"]
            _11_BIT_TRANSFER,
            #[doc = "12-bit transfer"]
            _12_BIT_TRANSFER,
            #[doc = "13-bit transfer"]
            _13_BIT_TRANSFER,
            #[doc = "14-bit transfer"]
            _14_BIT_TRANSFER,
            #[doc = "15-bit transfer"]
            _15_BIT_TRANSFER,
            #[doc = "16-bit transfer"]
            _16_BIT_TRANSFER,
        }
        impl DSSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DSSW::_4_BIT_TRANSFER => 3,
                    DSSW::_5_BIT_TRANSFER => 4,
                    DSSW::_6_BIT_TRANSFER => 5,
                    DSSW::_7_BIT_TRANSFER => 6,
                    DSSW::_8_BIT_TRANSFER => 7,
                    DSSW::_9_BIT_TRANSFER => 8,
                    DSSW::_10_BIT_TRANSFER => 9,
                    DSSW::_11_BIT_TRANSFER => 10,
                    DSSW::_12_BIT_TRANSFER => 11,
                    DSSW::_13_BIT_TRANSFER => 12,
                    DSSW::_14_BIT_TRANSFER => 13,
                    DSSW::_15_BIT_TRANSFER => 14,
                    DSSW::_16_BIT_TRANSFER => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DSSW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "4-bit transfer"]
            #[inline]
            pub fn _4_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_4_BIT_TRANSFER)
            }
            #[doc = "5-bit transfer"]
            #[inline]
            pub fn _5_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_5_BIT_TRANSFER)
            }
            #[doc = "6-bit transfer"]
            #[inline]
            pub fn _6_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_6_BIT_TRANSFER)
            }
            #[doc = "7-bit transfer"]
            #[inline]
            pub fn _7_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_7_BIT_TRANSFER)
            }
            #[doc = "8-bit transfer"]
            #[inline]
            pub fn _8_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_8_BIT_TRANSFER)
            }
            #[doc = "9-bit transfer"]
            #[inline]
            pub fn _9_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_9_BIT_TRANSFER)
            }
            #[doc = "10-bit transfer"]
            #[inline]
            pub fn _10_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_10_BIT_TRANSFER)
            }
            #[doc = "11-bit transfer"]
            #[inline]
            pub fn _11_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_11_BIT_TRANSFER)
            }
            #[doc = "12-bit transfer"]
            #[inline]
            pub fn _12_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_12_BIT_TRANSFER)
            }
            #[doc = "13-bit transfer"]
            #[inline]
            pub fn _13_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_13_BIT_TRANSFER)
            }
            #[doc = "14-bit transfer"]
            #[inline]
            pub fn _14_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_14_BIT_TRANSFER)
            }
            #[doc = "15-bit transfer"]
            #[inline]
            pub fn _15_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_15_BIT_TRANSFER)
            }
            #[doc = "16-bit transfer"]
            #[inline]
            pub fn _16_bit_transfer(self) -> &'a mut W {
                self.variant(DSSW::_16_BIT_TRANSFER)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FRF`"]
        pub enum FRFW {
            #[doc = "SPI"]
            SPI,
            #[doc = "TI"]
            TI,
            #[doc = "Microwire"]
            MICROWIRE,
            #[doc = "This combination is not supported and should not be used."]
            THIS_COMBINATION_IS,
        }
        impl FRFW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FRFW::SPI => 0,
                    FRFW::TI => 1,
                    FRFW::MICROWIRE => 2,
                    FRFW::THIS_COMBINATION_IS => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FRFW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FRFW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FRFW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "SPI"]
            #[inline]
            pub fn spi(self) -> &'a mut W {
                self.variant(FRFW::SPI)
            }
            #[doc = "TI"]
            #[inline]
            pub fn ti(self) -> &'a mut W {
                self.variant(FRFW::TI)
            }
            #[doc = "Microwire"]
            #[inline]
            pub fn microwire(self) -> &'a mut W {
                self.variant(FRFW::MICROWIRE)
            }
            #[doc = "This combination is not supported and should not be used."]
            #[inline]
            pub fn this_combination_is(self) -> &'a mut W {
                self.variant(FRFW::THIS_COMBINATION_IS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPOL`"]
        pub enum CPOLW {
            #[doc = "SSP controller maintains the bus clock low between frames."]
            LOW,
            #[doc = "SSP controller maintains the bus clock high between frames."]
            HIGH,
        }
        impl CPOLW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPOLW::LOW => false,
                    CPOLW::HIGH => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPOLW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPOLW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPOLW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSP controller maintains the bus clock low between frames."]
            #[inline]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOLW::LOW)
            }
            #[doc = "SSP controller maintains the bus clock high between frames."]
            #[inline]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOLW::HIGH)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CPHA`"]
        pub enum CPHAW {
            #[doc = "SSP controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line."]
            FIRSTCLOCK,
            #[doc = "SSP controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line."]
            SECONDCLOK,
        }
        impl CPHAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CPHAW::FIRSTCLOCK => false,
                    CPHAW::SECONDCLOK => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPHAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPHAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CPHAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "SSP controller captures serial data on the first clock transition of the frame, that is, the transition away from the inter-frame state of the clock line."]
            #[inline]
            pub fn firstclock(self) -> &'a mut W {
                self.variant(CPHAW::FIRSTCLOCK)
            }
            #[doc = "SSP controller captures serial data on the second clock transition of the frame, that is, the transition back to the inter-frame state of the clock line."]
            #[inline]
            pub fn secondclok(self) -> &'a mut W {
                self.variant(CPHAW::SECONDCLOK)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:3 - Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used."]
            #[inline]
            pub fn dss(&self) -> DSSR {
                DSSR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 4:5 - Frame Format."]
            #[inline]
            pub fn frf(&self) -> FRFR {
                FRFR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 6 - Clock Out Polarity. This bit is only used in SPI mode."]
            #[inline]
            pub fn cpol(&self) -> CPOLR {
                CPOLR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Clock Out Phase. This bit is only used in SPI mode."]
            #[inline]
            pub fn cpha(&self) -> CPHAR {
                CPHAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 8:15 - Serial Clock Rate. The number of prescaler-output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn scr(&self) -> SCRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                SCRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:3 - Data Size Select. This field controls the number of bits transferred in each frame. Values 0000-0010 are not supported and should not be used."]
            #[inline]
            pub fn dss(&mut self) -> _DSSW {
                _DSSW { w: self }
            }
            #[doc = "Bits 4:5 - Frame Format."]
            #[inline]
            pub fn frf(&mut self) -> _FRFW {
                _FRFW { w: self }
            }
            #[doc = "Bit 6 - Clock Out Polarity. This bit is only used in SPI mode."]
            #[inline]
            pub fn cpol(&mut self) -> _CPOLW {
                _CPOLW { w: self }
            }
            #[doc = "Bit 7 - Clock Out Phase. This bit is only used in SPI mode."]
            #[inline]
            pub fn cpha(&mut self) -> _CPHAW {
                _CPHAW { w: self }
            }
            #[doc = "Bits 8:15 - Serial Clock Rate. The number of prescaler-output clocks per bit on the bus, minus one. Given that CPSDVSR is the prescale divider, and the APB clock PCLK clocks the prescaler, the bit frequency is PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn scr(&mut self) -> _SCRW {
                _SCRW { w: self }
            }
        }
    }
    #[doc = "Control Register 1. Selects master/slave and other modes."]
    pub struct CR1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Control Register 1. Selects master/slave and other modes."]
    pub mod cr1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CR1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `LBM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBMR {
            #[doc = "During normal operation."]
            NORMAL,
            #[doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)."]
            OUTPUT,
        }
        impl LBMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LBMR::NORMAL => false,
                    LBMR::OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LBMR {
                match value {
                    false => LBMR::NORMAL,
                    true => LBMR::OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `NORMAL`"]
            #[inline]
            pub fn is_normal(&self) -> bool {
                *self == LBMR::NORMAL
            }
            #[doc = "Checks if the value of the field is `OUTPUT`"]
            #[inline]
            pub fn is_output(&self) -> bool {
                *self == LBMR::OUTPUT
            }
        }
        #[doc = "Possible values of the field `SSE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSER {
            #[doc = "The SSP controller is disabled."]
            DISABLED,
            #[doc = "The SSP controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP registers and interrupt controller registers, before setting this bit."]
            ENABLED,
        }
        impl SSER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSER::DISABLED => false,
                    SSER::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSER {
                match value {
                    false => SSER::DISABLED,
                    true => SSER::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SSER::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SSER::ENABLED
            }
        }
        #[doc = "Possible values of the field `MS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSR {
            #[doc = "The SSP controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line."]
            MASTER,
            #[doc = "The SSP controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines."]
            SLAVE,
        }
        impl MSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    MSR::MASTER => false,
                    MSR::SLAVE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> MSR {
                match value {
                    false => MSR::MASTER,
                    true => MSR::SLAVE,
                }
            }
            #[doc = "Checks if the value of the field is `MASTER`"]
            #[inline]
            pub fn is_master(&self) -> bool {
                *self == MSR::MASTER
            }
            #[doc = "Checks if the value of the field is `SLAVE`"]
            #[inline]
            pub fn is_slave(&self) -> bool {
                *self == MSR::SLAVE
            }
        }
        #[doc = r" Value of the field"]
        pub struct SODR {
            bits: bool,
        }
        impl SODR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `LBM`"]
        pub enum LBMW {
            #[doc = "During normal operation."]
            NORMAL,
            #[doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)."]
            OUTPUT,
        }
        impl LBMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    LBMW::NORMAL => false,
                    LBMW::OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _LBMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _LBMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: LBMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "During normal operation."]
            #[inline]
            pub fn normal(self) -> &'a mut W {
                self.variant(LBMW::NORMAL)
            }
            #[doc = "Serial input is taken from the serial output (MOSI or MISO) rather than the serial input pin (MISO or MOSI respectively)."]
            #[inline]
            pub fn output(self) -> &'a mut W {
                self.variant(LBMW::OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSE`"]
        pub enum SSEW {
            #[doc = "The SSP controller is disabled."]
            DISABLED,
            #[doc = "The SSP controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP registers and interrupt controller registers, before setting this bit."]
            ENABLED,
        }
        impl SSEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSEW::DISABLED => false,
                    SSEW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SSP controller is disabled."]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSEW::DISABLED)
            }
            #[doc = "The SSP controller will interact with other devices on the serial bus. Software should write the appropriate control information to the other SSP registers and interrupt controller registers, before setting this bit."]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSEW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MS`"]
        pub enum MSW {
            #[doc = "The SSP controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line."]
            MASTER,
            #[doc = "The SSP controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines."]
            SLAVE,
        }
        impl MSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    MSW::MASTER => false,
                    MSW::SLAVE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "The SSP controller acts as a master on the bus, driving the SCLK, MOSI, and SSEL lines and receiving the MISO line."]
            #[inline]
            pub fn master(self) -> &'a mut W {
                self.variant(MSW::MASTER)
            }
            #[doc = "The SSP controller acts as a slave on the bus, driving MISO line and receiving SCLK, MOSI, and SSEL lines."]
            #[inline]
            pub fn slave(self) -> &'a mut W {
                self.variant(MSW::SLAVE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _SODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SODW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Loop Back Mode."]
            #[inline]
            pub fn lbm(&self) -> LBMR {
                LBMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - SSP Enable."]
            #[inline]
            pub fn sse(&self) -> SSER {
                SSER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Master/Slave Mode.This bit can only be written when the SSE bit is 0."]
            #[inline]
            pub fn ms(&self) -> MSR {
                MSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SSP controller from driving the transmit data line (MISO)."]
            #[inline]
            pub fn sod(&self) -> SODR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SODR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Loop Back Mode."]
            #[inline]
            pub fn lbm(&mut self) -> _LBMW {
                _LBMW { w: self }
            }
            #[doc = "Bit 1 - SSP Enable."]
            #[inline]
            pub fn sse(&mut self) -> _SSEW {
                _SSEW { w: self }
            }
            #[doc = "Bit 2 - Master/Slave Mode.This bit can only be written when the SSE bit is 0."]
            #[inline]
            pub fn ms(&mut self) -> _MSW {
                _MSW { w: self }
            }
            #[doc = "Bit 3 - Slave Output Disable. This bit is relevant only in slave mode (MS = 1). If it is 1, this blocks this SSP controller from driving the transmit data line (MISO)."]
            #[inline]
            pub fn sod(&mut self) -> _SODW {
                _SODW { w: self }
            }
        }
    }
    #[doc = "Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO."]
    pub struct DR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data Register. Writes fill the transmit FIFO, and reads empty the receive FIFO."]
    pub mod dr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATAR {
            bits: u16,
        }
        impl DATAR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u16 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATAW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                const MASK: u16 = 0xffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:15 - Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SSP controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SSP controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s."]
            #[inline]
            pub fn data(&self) -> DATAR {
                let bits = {
                    const MASK: u16 = 0xffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u16
                };
                DATAR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:15 - Write: software can write data to be sent in a future frame to this register whenever the TNF bit in the Status register is 1, indicating that the Tx FIFO is not full. If the Tx FIFO was previously empty and the SSP controller is not busy on the bus, transmission of the data will begin immediately. Otherwise the data written to this register will be sent as soon as all previous data has been sent (and received). If the data length is less than 16 bit, software must right-justify the data written to this register. Read: software can read data from this register whenever the RNE bit in the Status register is 1, indicating that the Rx FIFO is not empty. When software reads this register, the SSP controller returns data from the least recent frame in the Rx FIFO. If the data length is less than 16 bit, the data is right-justified in this field with higher order bits filled with 0s."]
            #[inline]
            pub fn data(&mut self) -> _DATAW {
                _DATAW { w: self }
            }
        }
    }
    #[doc = "Status Register."]
    pub struct SR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Status Register."]
    pub mod sr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SR {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct TFER {
            bits: bool,
        }
        impl TFER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TNFR {
            bits: bool,
        }
        impl TNFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RNER {
            bits: bool,
        }
        impl RNER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RFFR {
            bits: bool,
        }
        impl RFFR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct BSYR {
            bits: bool,
        }
        impl BSYR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Transmit FIFO Empty. This bit is 1 is the Transmit FIFO is empty, 0 if not."]
            #[inline]
            pub fn tfe(&self) -> TFER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TFER { bits }
            }
            #[doc = "Bit 1 - Transmit FIFO Not Full. This bit is 0 if the Tx FIFO is full, 1 if not."]
            #[inline]
            pub fn tnf(&self) -> TNFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TNFR { bits }
            }
            #[doc = "Bit 2 - Receive FIFO Not Empty. This bit is 0 if the Receive FIFO is empty, 1 if not."]
            #[inline]
            pub fn rne(&self) -> RNER {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RNER { bits }
            }
            #[doc = "Bit 3 - Receive FIFO Full. This bit is 1 if the Receive FIFO is full, 0 if not."]
            #[inline]
            pub fn rff(&self) -> RFFR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RFFR { bits }
            }
            #[doc = "Bit 4 - Busy. This bit is 0 if the SSP0 controller is idle, or 1 if it is currently sending/receiving a frame and/or the Tx FIFO is not empty."]
            #[inline]
            pub fn bsy(&self) -> BSYR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                BSYR { bits }
            }
        }
    }
    #[doc = "Clock Prescale Register."]
    pub struct CPSR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Clock Prescale Register."]
    pub mod cpsr {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CPSR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CPSDVSRR {
            bits: u8,
        }
        impl CPSDVSRR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CPSDVSRW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CPSDVSRW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - This even value between 2 and 254, by which SSP_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0."]
            #[inline]
            pub fn cpsdvsr(&self) -> CPSDVSRR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                CPSDVSRR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - This even value between 2 and 254, by which SSP_PCLK is divided to yield the prescaler output clock. Bit 0 always reads as 0."]
            #[inline]
            pub fn cpsdvsr(&mut self) -> _CPSDVSRW {
                _CPSDVSRW { w: self }
            }
        }
    }
    #[doc = "Interrupt Mask Set and Clear Register."]
    pub struct IMSC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt Mask Set and Clear Register."]
    pub mod imsc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IMSC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct RORIMR {
            bits: bool,
        }
        impl RORIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTIMR {
            bits: bool,
        }
        impl RTIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXIMR {
            bits: bool,
        }
        impl RXIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXIMR {
            bits: bool,
        }
        impl TXIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _RORIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RORIMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTIMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RXIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RXIMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _TXIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TXIMW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs."]
            #[inline]
            pub fn rorim(&self) -> RORIMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RORIMR { bits }
            }
            #[doc = "Bit 1 - Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn rtim(&self) -> RTIMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTIMR { bits }
            }
            #[doc = "Bit 2 - Software should set this bit to enable interrupt when the Rx FIFO is at least half full."]
            #[inline]
            pub fn rxim(&self) -> RXIMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXIMR { bits }
            }
            #[doc = "Bit 3 - Software should set this bit to enable interrupt when the Tx FIFO is at least half empty."]
            #[inline]
            pub fn txim(&self) -> TXIMR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXIMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Software should set this bit to enable interrupt when a Receive Overrun occurs, that is, when the Rx FIFO is full and another frame is completely received. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs."]
            #[inline]
            pub fn rorim(&mut self) -> _RORIMW {
                _RORIMW { w: self }
            }
            #[doc = "Bit 1 - Software should set this bit to enable interrupt when a Receive Time-out condition occurs. A Receive Time-out occurs when the Rx FIFO is not empty, and no has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn rtim(&mut self) -> _RTIMW {
                _RTIMW { w: self }
            }
            #[doc = "Bit 2 - Software should set this bit to enable interrupt when the Rx FIFO is at least half full."]
            #[inline]
            pub fn rxim(&mut self) -> _RXIMW {
                _RXIMW { w: self }
            }
            #[doc = "Bit 3 - Software should set this bit to enable interrupt when the Tx FIFO is at least half empty."]
            #[inline]
            pub fn txim(&mut self) -> _TXIMW {
                _TXIMW { w: self }
            }
        }
    }
    #[doc = "Raw Interrupt Status Register."]
    pub struct RIS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw Interrupt Status Register."]
    pub mod ris {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RIS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RORRISR {
            bits: bool,
        }
        impl RORRISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTRISR {
            bits: bool,
        }
        impl RTRISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXRISR {
            bits: bool,
        }
        impl RXRISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXRISR {
            bits: bool,
        }
        impl TXRISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - This bit is 1 if another frame was completely received while the RxFIFO was full. The ARM spec implies that the preceding frame data is overwritten by the new frame data when this occurs."]
            #[inline]
            pub fn rorris(&self) -> RORRISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RORRISR { bits }
            }
            #[doc = "Bit 1 - This bit is 1 if the Rx FIFO is not empty, and has not been read for a time-out period. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn rtris(&self) -> RTRISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTRISR { bits }
            }
            #[doc = "Bit 2 - This bit is 1 if the Rx FIFO is at least half full."]
            #[inline]
            pub fn rxris(&self) -> RXRISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXRISR { bits }
            }
            #[doc = "Bit 3 - This bit is 1 if the Tx FIFO is at least half empty."]
            #[inline]
            pub fn txris(&self) -> TXRISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXRISR { bits }
            }
        }
    }
    #[doc = "Masked Interrupt Status Register."]
    pub struct MIS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Masked Interrupt Status Register."]
    pub mod mis {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MIS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RORMISR {
            bits: bool,
        }
        impl RORMISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RTMISR {
            bits: bool,
        }
        impl RTMISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RXMISR {
            bits: bool,
        }
        impl RXMISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct TXMISR {
            bits: bool,
        }
        impl TXMISR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - This bit is 1 if another frame was completely received while the RxFIFO was full, and this interrupt is enabled."]
            #[inline]
            pub fn rormis(&self) -> RORMISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RORMISR { bits }
            }
            #[doc = "Bit 1 - This bit is 1 if the Rx FIFO is not empty, has not been read for a time-out period, and this interrupt is enabled. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn rtmis(&self) -> RTMISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RTMISR { bits }
            }
            #[doc = "Bit 2 - This bit is 1 if the Rx FIFO is at least half full, and this interrupt is enabled."]
            #[inline]
            pub fn rxmis(&self) -> RXMISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RXMISR { bits }
            }
            #[doc = "Bit 3 - This bit is 1 if the Tx FIFO is at least half empty, and this interrupt is enabled."]
            #[inline]
            pub fn txmis(&self) -> TXMISR {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                TXMISR { bits }
            }
        }
    }
    #[doc = "SSPICR Interrupt Clear Register."]
    pub struct ICR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SSPICR Interrupt Clear Register."]
    pub mod icr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::ICR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RORICW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RORICW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RTICW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RTICW<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Writing a 1 to this bit clears the frame was received when RxFIFO was full interrupt."]
            #[inline]
            pub fn roric(&mut self) -> _RORICW {
                _RORICW { w: self }
            }
            #[doc = "Bit 1 - Writing a 1 to this bit clears the Rx FIFO was not empty and has not been read-bit for a time-out period interrupt. The time-out period is the same for master and slave modes and is determined by the SSP bit rate: 32 bits at PCLK / (CPSDVSR x [SCR+1])."]
            #[inline]
            pub fn rtic(&mut self) -> _RTICW {
                _RTICW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx I/O configuration Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct IOCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IOCON {}
impl IOCON {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const iocon::RegisterBlock {
        0x4004_4000 as *const _
    }
}
impl Deref for IOCON {
    type Target = iocon::RegisterBlock;
    fn deref(&self) -> &iocon::RegisterBlock {
        unsafe { &*IOCON::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx I/O configuration Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod iocon {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - I/O configuration for pin PIO2_6"]
        pub pio2_6: PIO2_6,
        _reserved0: [u8; 4usize],
        #[doc = "0x08 - I/O configuration for pin PIO2_0/DTR/SSEL1"]
        pub pio2_0: PIO2_0,
        #[doc = "0x0c - I/O configuration for pin RESET/PIO0_0"]
        pub reset_pio0_0: RESET_PIO0_0,
        #[doc = "0x10 - I/O configuration for pin PIO0_1/CLKOUT/ CT32B0_MAT2/USB_FTOGGLE"]
        pub pio0_1: PIO0_1,
        #[doc = "0x14 - I/O configuration for pin PIO1_8/CT16B1_CAP0"]
        pub pio1_8: PIO1_8,
        _reserved1: [u8; 4usize],
        #[doc = "0x1c - I/O configuration for pin PIO0_2/SSEL0/ CT16B0_CAP0"]
        pub pio0_2: PIO0_2,
        #[doc = "0x20 - I/O configuration for pin PIO2_7"]
        pub pio2_7: PIO2_7,
        #[doc = "0x24 - I/O configuration for pin PIO2_8"]
        pub pio2_8: PIO2_8,
        #[doc = "0x28 - I/O configuration for pin PIO2_1/DSR/SCK1"]
        pub pio2_1: PIO2_1,
        #[doc = "0x2c - I/O configuration for pin PIO0_3/USB_VBUS"]
        pub pio0_3: PIO0_3,
        #[doc = "0x30 - I/O configuration for pin PIO0_4/SCL"]
        pub pio0_4: PIO0_4,
        #[doc = "0x34 - I/O configuration for pin PIO0_5/SDA"]
        pub pio0_5: PIO0_5,
        #[doc = "0x38 - I/O configuration for pin PIO1_9/CT16B1_MAT0"]
        pub pio1_9: PIO1_9,
        #[doc = "0x3c - I/O configuration for pin PIO3_4"]
        pub pio3_4: PIO3_4,
        #[doc = "0x40 - I/O configuration for pin PIO2_4"]
        pub pio2_4: PIO2_4,
        #[doc = "0x44 - I/O configuration for pin PIO2_5"]
        pub pio2_5: PIO2_5,
        #[doc = "0x48 - I/O configuration for pin PIO3_5"]
        pub pio3_5: PIO3_5,
        #[doc = "0x4c - I/O configuration for pin PIO0_6/USB_CONNECT/SCK"]
        pub pio0_6: PIO0_6,
        #[doc = "0x50 - I/O configuration for pin PIO0_7/CTS"]
        pub pio0_7: PIO0_7,
        #[doc = "0x54 - I/O configuration for pin PIO2_9"]
        pub pio2_9: PIO2_9,
        #[doc = "0x58 - I/O configuration for pin PIO2_10"]
        pub pio2_10: PIO2_10,
        #[doc = "0x5c - I/O configuration for pin PIO2_2/DCD/MISO1"]
        pub pio2_2: PIO2_2,
        #[doc = "0x60 - I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0"]
        pub pio0_8: PIO0_8,
        #[doc = "0x64 - I/O configuration for pin PIO0_9/MOSI0/ CT16B0_MAT1/SWO"]
        pub pio0_9: PIO0_9,
        #[doc = "0x68 - I/O configuration for pin SWCLK/PIO0_10/ SCK/CT16B0_MAT2"]
        pub swclk_pio0_10: SWCLK_PIO0_10,
        #[doc = "0x6c - I/O configuration for pin PIO1_10/AD6/ CT16B1_MAT1"]
        pub pio1_10: PIO1_10,
        #[doc = "0x70 - I/O configuration for pin PIO2_11/SCK"]
        pub pio2_11: PIO2_11,
        #[doc = "0x74 - I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3"]
        pub r_pio0_11: R_PIO0_11,
        #[doc = "0x78 - I/O configuration for pin R/PIO1_0/AD1/ CT32B1_CAP0"]
        pub r_pio1_0: R_PIO1_0,
        #[doc = "0x7c - I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0"]
        pub r_pio1_1: R_PIO1_1,
        #[doc = "0x80 - I/O configuration for pin R/PIO1_2/AD3/ CT32B1_MAT1"]
        pub r_pio1_2: R_PIO1_2,
        #[doc = "0x84 - I/O configuration for pin PIO3_0/DTR"]
        pub pio3_0: PIO3_0,
        #[doc = "0x88 - I/O configuration for pin PIO3_1/DSR"]
        pub pio3_1: PIO3_1,
        #[doc = "0x8c - I/O configuration for pin PIO2_3/RI/MOSI1"]
        pub pio2_3: PIO2_3,
        #[doc = "0x90 - I/O configuration for pin SWDIO/PIO1_3/AD4/ CT32B1_MAT2"]
        pub swdio_pio1_3: SWDIO_PIO1_3,
        #[doc = "0x94 - I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3"]
        pub pio1_4: PIO1_4,
        #[doc = "0x98 - I/O configuration for pin PIO1_11/AD7"]
        pub pio1_11: PIO1_11,
        #[doc = "0x9c - I/O configuration for pin PIO3_2/DCD"]
        pub pio3_2: PIO3_2,
        #[doc = "0xa0 - I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0"]
        pub pio1_5: PIO1_5,
        #[doc = "0xa4 - I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0"]
        pub pio1_6: PIO1_6,
        #[doc = "0xa8 - I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1"]
        pub pio1_7: PIO1_7,
        #[doc = "0xac - I/O configuration for pin PIO3_3/RI"]
        pub pio3_3: PIO3_3,
        #[doc = "0xb0 - SCK0 pin location register"]
        pub sck0_loc: SCK0_LOC,
        #[doc = "0xb4 - DSR pin location select register"]
        pub dsr_loc: DSR_LOC,
        #[doc = "0xb8 - DCD pin location select register"]
        pub dcd_loc: DCD_LOC,
        #[doc = "0xbc - RI pin location register"]
        pub ri_loc: RI_LOC,
    }
    #[doc = "I/O configuration for pin PIO2_6"]
    pub struct PIO2_6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_6"]
    pub mod pio2_6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_6."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_6."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_6."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)."]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_0/DTR/SSEL1"]
    pub struct PIO2_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_0/DTR/SSEL1"]
    pub mod pio2_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Select function PIO2_0."]
            PIO2,
            #[doc = "Select function DTR."]
            DTR,
            #[doc = "Select function SSEL1 (function not available on all parts)."]
            SSEL,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO2 => 0,
                    FUNCR::DTR => 0x01,
                    FUNCR::SSEL => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO2,
                    1 => FUNCR::DTR,
                    2 => FUNCR::SSEL,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO2`"]
            #[inline]
            pub fn is_pio2(&self) -> bool {
                *self == FUNCR::PIO2
            }
            #[doc = "Checks if the value of the field is `DTR`"]
            #[inline]
            pub fn is_dtr(&self) -> bool {
                *self == FUNCR::DTR
            }
            #[doc = "Checks if the value of the field is `SSEL`"]
            #[inline]
            pub fn is_ssel(&self) -> bool {
                *self == FUNCR::SSEL
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Select function PIO2_0."]
            PIO2,
            #[doc = "Select function DTR."]
            DTR,
            #[doc = "Select function SSEL1 (function not available on all parts)."]
            SSEL,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO2 => 0,
                    FUNCW::DTR => 1,
                    FUNCW::SSEL => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Select function PIO2_0."]
            #[inline]
            pub fn pio2(self) -> &'a mut W {
                self.variant(FUNCW::PIO2)
            }
            #[doc = "Select function DTR."]
            #[inline]
            pub fn dtr(self) -> &'a mut W {
                self.variant(FUNCW::DTR)
            }
            #[doc = "Select function SSEL1 (function not available on all parts)."]
            #[inline]
            pub fn ssel(self) -> &'a mut W {
                self.variant(FUNCW::SSEL)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin RESET/PIO0_0"]
    pub struct RESET_PIO0_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin RESET/PIO0_0"]
    pub mod reset_pio0_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RESET_PIO0_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function RESET."]
            RES,
            #[doc = "Selects function PIO0_0."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::RES => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::RES,
                    1 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `RES`"]
            #[inline]
            pub fn is_res(&self) -> bool {
                *self == FUNCR::RES
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function RESET."]
            RES,
            #[doc = "Selects function PIO0_0."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::RES => 0,
                    FUNCW::PIO => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function RESET."]
            #[inline]
            pub fn res(self) -> &'a mut W {
                self.variant(FUNCW::RES)
            }
            #[doc = "Selects function PIO0_0."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_1/CLKOUT/ CT32B0_MAT2/USB_FTOGGLE"]
    pub struct PIO0_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_1/CLKOUT/ CT32B0_MAT2/USB_FTOGGLE"]
    pub mod pio0_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_1."]
            PIO,
            #[doc = "Selects function CLKOUT."]
            CLK,
            #[doc = "Selects function CT32B0_MAT2."]
            CT3,
            #[doc = "Selects function USB_FTOGGLE (function not available on all parts)"]
            USB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::CLK => 0x01,
                    FUNCR::CT3 => 0x02,
                    FUNCR::USB => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::CLK,
                    2 => FUNCR::CT3,
                    3 => FUNCR::USB,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `CLK`"]
            #[inline]
            pub fn is_clk(&self) -> bool {
                *self == FUNCR::CLK
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
            #[doc = "Checks if the value of the field is `USB`"]
            #[inline]
            pub fn is_usb(&self) -> bool {
                *self == FUNCR::USB
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_1."]
            PIO,
            #[doc = "Selects function CLKOUT."]
            CLK,
            #[doc = "Selects function CT32B0_MAT2."]
            CT3,
            #[doc = "Selects function USB_FTOGGLE (function not available on all parts)"]
            USB,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::CLK => 1,
                    FUNCW::CT3 => 2,
                    FUNCW::USB => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_1."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function CLKOUT."]
            #[inline]
            pub fn clk(self) -> &'a mut W {
                self.variant(FUNCW::CLK)
            }
            #[doc = "Selects function CT32B0_MAT2."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = "Selects function USB_FTOGGLE (function not available on all parts)"]
            #[inline]
            pub fn usb(self) -> &'a mut W {
                self.variant(FUNCW::USB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_8/CT16B1_CAP0"]
    pub struct PIO1_8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_8/CT16B1_CAP0"]
    pub mod pio1_8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_8."]
            PIO,
            #[doc = "Selects function CT16B1_CAP0."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::CT1 => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_8."]
            PIO,
            #[doc = "Selects function CT16B1_CAP0."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::CT1 => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_8."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function CT16B1_CAP0."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_2/SSEL0/ CT16B0_CAP0"]
    pub struct PIO0_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_2/SSEL0/ CT16B0_CAP0"]
    pub mod pio0_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_2."]
            PIO,
            #[doc = "Selects function SSEL0."]
            SSE,
            #[doc = "Selects function CT16B0_CAP0."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::SSE => 0x01,
                    FUNCR::CT1 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::SSE,
                    2 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `SSE`"]
            #[inline]
            pub fn is_sse(&self) -> bool {
                *self == FUNCR::SSE
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_2."]
            PIO,
            #[doc = "Selects function SSEL0."]
            SSE,
            #[doc = "Selects function CT16B0_CAP0."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::SSE => 1,
                    FUNCW::CT1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_2."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function SSEL0."]
            #[inline]
            pub fn sse(self) -> &'a mut W {
                self.variant(FUNCW::SSE)
            }
            #[doc = "Selects function CT16B0_CAP0."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_7"]
    pub struct PIO2_7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_7"]
    pub mod pio2_7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_7."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_7."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_7."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_8"]
    pub struct PIO2_8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_8"]
    pub mod pio2_8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_8."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_8."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_8."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_1/DSR/SCK1"]
    pub struct PIO2_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_1/DSR/SCK1"]
    pub mod pio2_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_1."]
            PIO,
            #[doc = "Select function DSR."]
            DSR,
            #[doc = "Select function SCK1 (function not available on all parts)."]
            SCK1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::DSR => 0x01,
                    FUNCR::SCK1 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::DSR,
                    2 => FUNCR::SCK1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `DSR`"]
            #[inline]
            pub fn is_dsr(&self) -> bool {
                *self == FUNCR::DSR
            }
            #[doc = "Checks if the value of the field is `SCK1`"]
            #[inline]
            pub fn is_sck1(&self) -> bool {
                *self == FUNCR::SCK1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_1."]
            PIO,
            #[doc = "Select function DSR."]
            DSR,
            #[doc = "Select function SCK1 (function not available on all parts)."]
            SCK1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::DSR => 1,
                    FUNCW::SCK1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_1."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Select function DSR."]
            #[inline]
            pub fn dsr(self) -> &'a mut W {
                self.variant(FUNCW::DSR)
            }
            #[doc = "Select function SCK1 (function not available on all parts)."]
            #[inline]
            pub fn sck1(self) -> &'a mut W {
                self.variant(FUNCW::SCK1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_3/USB_VBUS"]
    pub struct PIO0_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_3/USB_VBUS"]
    pub mod pio0_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_3."]
            PIO,
            #[doc = "Selects function USB_VBUS (function not available on all parts)."]
            USB,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::USB => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::USB,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `USB`"]
            #[inline]
            pub fn is_usb(&self) -> bool {
                *self == FUNCR::USB
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_3."]
            PIO,
            #[doc = "Selects function USB_VBUS (function not available on all parts)."]
            USB,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::USB => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_3."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function USB_VBUS (function not available on all parts)."]
            #[inline]
            pub fn usb(self) -> &'a mut W {
                self.variant(FUNCW::USB)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_4/SCL"]
    pub struct PIO0_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_4/SCL"]
    pub mod pio0_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_4 (open-drain pin)."]
            PIO,
            #[doc = "Selects I2C function SCL (open-drain pin)."]
            SELECTS_I2C_FUNCTION,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::SELECTS_I2C_FUNCTION => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::SELECTS_I2C_FUNCTION,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `SELECTS_I2C_FUNCTION`"]
            #[inline]
            pub fn is_selects_i2c_function(&self) -> bool {
                *self == FUNCR::SELECTS_I2C_FUNCTION
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C"]
            STANDARD_MODE_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO_FUNCTIO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_MODE_FAST => 0,
                    I2CMODER::STANDARD_IO_FUNCTIO => 0x01,
                    I2CMODER::FAST_MODE_PLUS_I2C => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_MODE_FAST,
                    1 => I2CMODER::STANDARD_IO_FUNCTIO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_MODE_FAST`"]
            #[inline]
            pub fn is_standard_mode_fast(&self) -> bool {
                *self == I2CMODER::STANDARD_MODE_FAST
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO_FUNCTIO`"]
            #[inline]
            pub fn is_standard_io_functio(&self) -> bool {
                *self == I2CMODER::STANDARD_IO_FUNCTIO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_4 (open-drain pin)."]
            PIO,
            #[doc = "Selects I2C function SCL (open-drain pin)."]
            SELECTS_I2C_FUNCTION,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::SELECTS_I2C_FUNCTION => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_4 (open-drain pin)."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects I2C function SCL (open-drain pin)."]
            #[inline]
            pub fn selects_i2c_function(self) -> &'a mut W {
                self.variant(FUNCW::SELECTS_I2C_FUNCTION)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C"]
            STANDARD_MODE_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO_FUNCTIO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_MODE_FAST => 0,
                    I2CMODEW::STANDARD_IO_FUNCTIO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Standard mode/ Fast-mode I2C"]
            #[inline]
            pub fn standard_mode_fast(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_MODE_FAST)
            }
            #[doc = "Standard I/O functionality"]
            #[inline]
            pub fn standard_io_functio(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO_FUNCTIO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_5/SDA"]
    pub struct PIO0_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_5/SDA"]
    pub mod pio0_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_5 (open-drain pin)."]
            PIO,
            #[doc = "Selects I2C function SDA (open-drain pin)."]
            SELECTS_I2C_FUNCTION,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::SELECTS_I2C_FUNCTION => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::SELECTS_I2C_FUNCTION,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `SELECTS_I2C_FUNCTION`"]
            #[inline]
            pub fn is_selects_i2c_function(&self) -> bool {
                *self == FUNCR::SELECTS_I2C_FUNCTION
            }
        }
        #[doc = "Possible values of the field `I2CMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CMODER {
            #[doc = "Standard mode/ Fast-mode I2C"]
            STANDARD_MODE_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO_FUNCTIO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    I2CMODER::STANDARD_MODE_FAST => 0,
                    I2CMODER::STANDARD_IO_FUNCTIO => 0x01,
                    I2CMODER::FAST_MODE_PLUS_I2C => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> I2CMODER {
                match value {
                    0 => I2CMODER::STANDARD_MODE_FAST,
                    1 => I2CMODER::STANDARD_IO_FUNCTIO,
                    2 => I2CMODER::FAST_MODE_PLUS_I2C,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_MODE_FAST`"]
            #[inline]
            pub fn is_standard_mode_fast(&self) -> bool {
                *self == I2CMODER::STANDARD_MODE_FAST
            }
            #[doc = "Checks if the value of the field is `STANDARD_IO_FUNCTIO`"]
            #[inline]
            pub fn is_standard_io_functio(&self) -> bool {
                *self == I2CMODER::STANDARD_IO_FUNCTIO
            }
            #[doc = "Checks if the value of the field is `FAST_MODE_PLUS_I2C`"]
            #[inline]
            pub fn is_fast_mode_plus_i2c(&self) -> bool {
                *self == I2CMODER::FAST_MODE_PLUS_I2C
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_5 (open-drain pin)."]
            PIO,
            #[doc = "Selects I2C function SDA (open-drain pin)."]
            SELECTS_I2C_FUNCTION,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::SELECTS_I2C_FUNCTION => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_5 (open-drain pin)."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects I2C function SDA (open-drain pin)."]
            #[inline]
            pub fn selects_i2c_function(self) -> &'a mut W {
                self.variant(FUNCW::SELECTS_I2C_FUNCTION)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2CMODE`"]
        pub enum I2CMODEW {
            #[doc = "Standard mode/ Fast-mode I2C"]
            STANDARD_MODE_FAST,
            #[doc = "Standard I/O functionality"]
            STANDARD_IO_FUNCTIO,
            #[doc = "Fast-mode Plus I2C"]
            FAST_MODE_PLUS_I2C,
        }
        impl I2CMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    I2CMODEW::STANDARD_MODE_FAST => 0,
                    I2CMODEW::STANDARD_IO_FUNCTIO => 1,
                    I2CMODEW::FAST_MODE_PLUS_I2C => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2CMODEW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Standard mode/ Fast-mode I2C"]
            #[inline]
            pub fn standard_mode_fast(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_MODE_FAST)
            }
            #[doc = "Standard I/O functionality"]
            #[inline]
            pub fn standard_io_functio(self) -> &'a mut W {
                self.variant(I2CMODEW::STANDARD_IO_FUNCTIO)
            }
            #[doc = "Fast-mode Plus I2C"]
            #[inline]
            pub fn fast_mode_plus_i2c(self) -> &'a mut W {
                self.variant(I2CMODEW::FAST_MODE_PLUS_I2C)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&self) -> I2CMODER {
                I2CMODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 8:9 - Selects I2C mode. Select Standard mode (I2CMODE = 00, default) or Standard I/O functionality (I2CMODE = 01) if the pin function is GPIO (FUNC = 000)."]
            #[inline]
            pub fn i2cmode(&mut self) -> _I2CMODEW {
                _I2CMODEW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_9/CT16B1_MAT0"]
    pub struct PIO1_9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_9/CT16B1_MAT0"]
    pub mod pio1_9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_9."]
            PIO,
            #[doc = "Selects function CT16B1_MAT0."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::CT1 => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_9."]
            PIO,
            #[doc = "Selects function CT16B1_MAT0."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::CT1 => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_9."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function CT16B1_MAT0."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_4"]
    pub struct PIO3_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_4"]
    pub mod pio3_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_4."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_4."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_4."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_4"]
    pub struct PIO2_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_4"]
    pub mod pio2_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_4."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_4."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_4."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_5"]
    pub struct PIO2_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_5"]
    pub mod pio2_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_5."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_5."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_5."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_5"]
    pub struct PIO3_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_5"]
    pub mod pio3_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_5."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_5."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_5."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_6/USB_CONNECT/SCK"]
    pub struct PIO0_6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_6/USB_CONNECT/SCK"]
    pub mod pio0_6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_6."]
            PIO,
            #[doc = "Selects function USB_CONNECT (function not available on all parts)."]
            USB,
            #[doc = "Selects function SCK0 (only if pin PIO0_6/ USB_CONNECT/ SCK0 selected in Table 139)."]
            SCK,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::USB => 0x01,
                    FUNCR::SCK => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::USB,
                    2 => FUNCR::SCK,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `USB`"]
            #[inline]
            pub fn is_usb(&self) -> bool {
                *self == FUNCR::USB
            }
            #[doc = "Checks if the value of the field is `SCK`"]
            #[inline]
            pub fn is_sck(&self) -> bool {
                *self == FUNCR::SCK
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_6."]
            PIO,
            #[doc = "Selects function USB_CONNECT (function not available on all parts)."]
            USB,
            #[doc = "Selects function SCK0 (only if pin PIO0_6/ USB_CONNECT/ SCK0 selected in Table 139)."]
            SCK,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::USB => 1,
                    FUNCW::SCK => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_6."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function USB_CONNECT (function not available on all parts)."]
            #[inline]
            pub fn usb(self) -> &'a mut W {
                self.variant(FUNCW::USB)
            }
            #[doc = "Selects function SCK0 (only if pin PIO0_6/ USB_CONNECT/ SCK0 selected in Table 139)."]
            #[inline]
            pub fn sck(self) -> &'a mut W {
                self.variant(FUNCW::SCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_7/CTS"]
    pub struct PIO0_7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_7/CTS"]
    pub mod pio0_7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_7."]
            PIO,
            #[doc = "Select function CTS."]
            CTS,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::CTS => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::CTS,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `CTS`"]
            #[inline]
            pub fn is_cts(&self) -> bool {
                *self == FUNCR::CTS
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_7."]
            PIO,
            #[doc = "Select function CTS."]
            CTS,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::CTS => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_7."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Select function CTS."]
            #[inline]
            pub fn cts(self) -> &'a mut W {
                self.variant(FUNCW::CTS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_9"]
    pub struct PIO2_9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_9"]
    pub mod pio2_9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_9."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_9."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_9."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_10"]
    pub struct PIO2_10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_10"]
    pub mod pio2_10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_10."]
            PIO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_10."]
            PIO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_10."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_2/DCD/MISO1"]
    pub struct PIO2_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_2/DCD/MISO1"]
    pub mod pio2_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_2."]
            PIO,
            #[doc = "Select function DCD."]
            DCD,
            #[doc = "Select function MISO1 (function not available on all parts)."]
            MISO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::DCD => 0x01,
                    FUNCR::MISO => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::DCD,
                    2 => FUNCR::MISO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `DCD`"]
            #[inline]
            pub fn is_dcd(&self) -> bool {
                *self == FUNCR::DCD
            }
            #[doc = "Checks if the value of the field is `MISO`"]
            #[inline]
            pub fn is_miso(&self) -> bool {
                *self == FUNCR::MISO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_2."]
            PIO,
            #[doc = "Select function DCD."]
            DCD,
            #[doc = "Select function MISO1 (function not available on all parts)."]
            MISO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::DCD => 1,
                    FUNCW::MISO => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_2."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Select function DCD."]
            #[inline]
            pub fn dcd(self) -> &'a mut W {
                self.variant(FUNCW::DCD)
            }
            #[doc = "Select function MISO1 (function not available on all parts)."]
            #[inline]
            pub fn miso(self) -> &'a mut W {
                self.variant(FUNCW::MISO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0"]
    pub struct PIO0_8 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_8/MISO0/CT16B0_MAT0"]
    pub mod pio0_8 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_8 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_8."]
            PIO,
            #[doc = "Selects function MISO0."]
            MIS,
            #[doc = "Selects function CT16B0_MAT0."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::MIS => 0x01,
                    FUNCR::CT1 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::MIS,
                    2 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `MIS`"]
            #[inline]
            pub fn is_mis(&self) -> bool {
                *self == FUNCR::MIS
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_8."]
            PIO,
            #[doc = "Selects function MISO0."]
            MIS,
            #[doc = "Selects function CT16B0_MAT0."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::MIS => 1,
                    FUNCW::CT1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_8."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function MISO0."]
            #[inline]
            pub fn mis(self) -> &'a mut W {
                self.variant(FUNCW::MIS)
            }
            #[doc = "Selects function CT16B0_MAT0."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO0_9/MOSI0/ CT16B0_MAT1/SWO"]
    pub struct PIO0_9 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO0_9/MOSI0/ CT16B0_MAT1/SWO"]
    pub mod pio0_9 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO0_9 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO0_9."]
            PIO,
            #[doc = "Selects function MOSI0."]
            MOS,
            #[doc = "Selects function CT16B0_MAT1."]
            CT1,
            #[doc = "Selects function SWO"]
            SWO,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::MOS => 0x01,
                    FUNCR::CT1 => 0x02,
                    FUNCR::SWO => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::MOS,
                    2 => FUNCR::CT1,
                    3 => FUNCR::SWO,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `MOS`"]
            #[inline]
            pub fn is_mos(&self) -> bool {
                *self == FUNCR::MOS
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
            #[doc = "Checks if the value of the field is `SWO`"]
            #[inline]
            pub fn is_swo(&self) -> bool {
                *self == FUNCR::SWO
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO0_9."]
            PIO,
            #[doc = "Selects function MOSI0."]
            MOS,
            #[doc = "Selects function CT16B0_MAT1."]
            CT1,
            #[doc = "Selects function SWO"]
            SWO,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::MOS => 1,
                    FUNCW::CT1 => 2,
                    FUNCW::SWO => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO0_9."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function MOSI0."]
            #[inline]
            pub fn mos(self) -> &'a mut W {
                self.variant(FUNCW::MOS)
            }
            #[doc = "Selects function CT16B0_MAT1."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = "Selects function SWO"]
            #[inline]
            pub fn swo(self) -> &'a mut W {
                self.variant(FUNCW::SWO)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin SWCLK/PIO0_10/ SCK/CT16B0_MAT2"]
    pub struct SWCLK_PIO0_10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin SWCLK/PIO0_10/ SCK/CT16B0_MAT2"]
    pub mod swclk_pio0_10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SWCLK_PIO0_10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function SWCLK."]
            SWC,
            #[doc = "Selects function PIO0_10."]
            PIO,
            #[doc = "Selects function SCK0 (only if pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table 139)."]
            SCK,
            #[doc = "Selects function CT16B0_MAT2."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::SWC => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::SCK => 0x02,
                    FUNCR::CT1 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::SWC,
                    1 => FUNCR::PIO,
                    2 => FUNCR::SCK,
                    3 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SWC`"]
            #[inline]
            pub fn is_swc(&self) -> bool {
                *self == FUNCR::SWC
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `SCK`"]
            #[inline]
            pub fn is_sck(&self) -> bool {
                *self == FUNCR::SCK
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function SWCLK."]
            SWC,
            #[doc = "Selects function PIO0_10."]
            PIO,
            #[doc = "Selects function SCK0 (only if pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table 139)."]
            SCK,
            #[doc = "Selects function CT16B0_MAT2."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::SWC => 0,
                    FUNCW::PIO => 1,
                    FUNCW::SCK => 2,
                    FUNCW::CT1 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function SWCLK."]
            #[inline]
            pub fn swc(self) -> &'a mut W {
                self.variant(FUNCW::SWC)
            }
            #[doc = "Selects function PIO0_10."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function SCK0 (only if pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 selected in Table 139)."]
            #[inline]
            pub fn sck(self) -> &'a mut W {
                self.variant(FUNCW::SCK)
            }
            #[doc = "Selects function CT16B0_MAT2."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_10/AD6/ CT16B1_MAT1"]
    pub struct PIO1_10 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_10/AD6/ CT16B1_MAT1"]
    pub mod pio1_10 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_10 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_10."]
            PIO,
            #[doc = "Selects function AD6."]
            AD6,
            #[doc = "Selects function CT16B1_MAT1."]
            CT1,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::AD6 => 0x01,
                    FUNCR::CT1 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::AD6,
                    2 => FUNCR::CT1,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD6`"]
            #[inline]
            pub fn is_ad6(&self) -> bool {
                *self == FUNCR::AD6
            }
            #[doc = "Checks if the value of the field is `CT1`"]
            #[inline]
            pub fn is_ct1(&self) -> bool {
                *self == FUNCR::CT1
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_10."]
            PIO,
            #[doc = "Selects function AD6."]
            AD6,
            #[doc = "Selects function CT16B1_MAT1."]
            CT1,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::AD6 => 1,
                    FUNCW::CT1 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_10."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD6."]
            #[inline]
            pub fn ad6(self) -> &'a mut W {
                self.variant(FUNCW::AD6)
            }
            #[doc = "Selects function CT16B1_MAT1."]
            #[inline]
            pub fn ct1(self) -> &'a mut W {
                self.variant(FUNCW::CT1)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_11/SCK"]
    pub struct PIO2_11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_11/SCK"]
    pub mod pio2_11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_11."]
            PIO,
            #[doc = "Selects function SCK0 (only if pin PIO2_11/SCK0 selected in Table 139)"]
            SCK,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::SCK => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::SCK,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `SCK`"]
            #[inline]
            pub fn is_sck(&self) -> bool {
                *self == FUNCR::SCK
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_11."]
            PIO,
            #[doc = "Selects function SCK0 (only if pin PIO2_11/SCK0 selected in Table 139)"]
            SCK,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::SCK => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_11."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function SCK0 (only if pin PIO2_11/SCK0 selected in Table 139)"]
            #[inline]
            pub fn sck(self) -> &'a mut W {
                self.variant(FUNCW::SCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3"]
    pub struct R_PIO0_11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin R/PIO0_11/AD0/CT32B0_MAT3"]
    pub mod r_pio0_11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::R_PIO0_11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO0_11."]
            PIO,
            #[doc = "Selects function AD0."]
            AD0,
            #[doc = "Selects function CT32B0_MAT3."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::R => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::AD0 => 0x02,
                    FUNCR::CT3 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::R,
                    1 => FUNCR::PIO,
                    2 => FUNCR::AD0,
                    3 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `R`"]
            #[inline]
            pub fn is_r(&self) -> bool {
                *self == FUNCR::R
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD0`"]
            #[inline]
            pub fn is_ad0(&self) -> bool {
                *self == FUNCR::AD0
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO0_11."]
            PIO,
            #[doc = "Selects function AD0."]
            AD0,
            #[doc = "Selects function CT32B0_MAT3."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::R => 0,
                    FUNCW::PIO => 1,
                    FUNCW::AD0 => 2,
                    FUNCW::CT3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            #[inline]
            pub fn r(self) -> &'a mut W {
                self.variant(FUNCW::R)
            }
            #[doc = "Selects function PIO0_11."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD0."]
            #[inline]
            pub fn ad0(self) -> &'a mut W {
                self.variant(FUNCW::AD0)
            }
            #[doc = "Selects function CT32B0_MAT3."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin R/PIO1_0/AD1/ CT32B1_CAP0"]
    pub struct R_PIO1_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin R/PIO1_0/AD1/ CT32B1_CAP0"]
    pub mod r_pio1_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::R_PIO1_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_0."]
            PIO,
            #[doc = "Selects function AD1."]
            AD1,
            #[doc = "Selects function CT32B1_CAP0."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::R => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::AD1 => 0x02,
                    FUNCR::CT3 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::R,
                    1 => FUNCR::PIO,
                    2 => FUNCR::AD1,
                    3 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `R`"]
            #[inline]
            pub fn is_r(&self) -> bool {
                *self == FUNCR::R
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD1`"]
            #[inline]
            pub fn is_ad1(&self) -> bool {
                *self == FUNCR::AD1
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_0."]
            PIO,
            #[doc = "Selects function AD1."]
            AD1,
            #[doc = "Selects function CT32B1_CAP0."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::R => 0,
                    FUNCW::PIO => 1,
                    FUNCW::AD1 => 2,
                    FUNCW::CT3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            #[inline]
            pub fn r(self) -> &'a mut W {
                self.variant(FUNCW::R)
            }
            #[doc = "Selects function PIO1_0."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD1."]
            #[inline]
            pub fn ad1(self) -> &'a mut W {
                self.variant(FUNCW::AD1)
            }
            #[doc = "Selects function CT32B1_CAP0."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0"]
    pub struct R_PIO1_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin R/PIO1_1/AD2/CT32B1_MAT0"]
    pub mod r_pio1_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::R_PIO1_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_1."]
            PIO,
            #[doc = "Selects function AD2."]
            AD2,
            #[doc = "Selects function CT32B1_MAT0."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::R => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::AD2 => 0x02,
                    FUNCR::CT3 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::R,
                    1 => FUNCR::PIO,
                    2 => FUNCR::AD2,
                    3 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `R`"]
            #[inline]
            pub fn is_r(&self) -> bool {
                *self == FUNCR::R
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD2`"]
            #[inline]
            pub fn is_ad2(&self) -> bool {
                *self == FUNCR::AD2
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_1."]
            PIO,
            #[doc = "Selects function AD2."]
            AD2,
            #[doc = "Selects function CT32B1_MAT0."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::R => 0,
                    FUNCW::PIO => 1,
                    FUNCW::AD2 => 2,
                    FUNCW::CT3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            #[inline]
            pub fn r(self) -> &'a mut W {
                self.variant(FUNCW::R)
            }
            #[doc = "Selects function PIO1_1."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD2."]
            #[inline]
            pub fn ad2(self) -> &'a mut W {
                self.variant(FUNCW::AD2)
            }
            #[doc = "Selects function CT32B1_MAT0."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin R/PIO1_2/AD3/ CT32B1_MAT1"]
    pub struct R_PIO1_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin R/PIO1_2/AD3/ CT32B1_MAT1"]
    pub mod r_pio1_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::R_PIO1_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_2."]
            PIO,
            #[doc = "Selects function AD3."]
            AD3,
            #[doc = "Selects function CT32B1_MAT1."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::R => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::AD3 => 0x02,
                    FUNCR::CT3 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::R,
                    1 => FUNCR::PIO,
                    2 => FUNCR::AD3,
                    3 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `R`"]
            #[inline]
            pub fn is_r(&self) -> bool {
                *self == FUNCR::R
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD3`"]
            #[inline]
            pub fn is_ad3(&self) -> bool {
                *self == FUNCR::AD3
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            R,
            #[doc = "Selects function PIO1_2."]
            PIO,
            #[doc = "Selects function AD3."]
            AD3,
            #[doc = "Selects function CT32B1_MAT1."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::R => 0,
                    FUNCW::PIO => 1,
                    FUNCW::AD3 => 2,
                    FUNCW::CT3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function R. This function is reserved. Select one of the alternate functions below."]
            #[inline]
            pub fn r(self) -> &'a mut W {
                self.variant(FUNCW::R)
            }
            #[doc = "Selects function PIO1_2."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD3."]
            #[inline]
            pub fn ad3(self) -> &'a mut W {
                self.variant(FUNCW::AD3)
            }
            #[doc = "Selects function CT32B1_MAT1."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_0/DTR"]
    pub struct PIO3_0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_0/DTR"]
    pub mod pio3_0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_0."]
            PIO,
            #[doc = "Selects function DTR (function not available on all parts)."]
            DTR,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::DTR => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::DTR,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `DTR`"]
            #[inline]
            pub fn is_dtr(&self) -> bool {
                *self == FUNCR::DTR
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_0."]
            PIO,
            #[doc = "Selects function DTR (function not available on all parts)."]
            DTR,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::DTR => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_0."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function DTR (function not available on all parts)."]
            #[inline]
            pub fn dtr(self) -> &'a mut W {
                self.variant(FUNCW::DTR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_1/DSR"]
    pub struct PIO3_1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_1/DSR"]
    pub mod pio3_1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_1."]
            PIO,
            #[doc = "Selects function DSR (function not available on all parts, must also be configured in the corresponding DSR_LOC register)."]
            DSR,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::DSR => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::DSR,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `DSR`"]
            #[inline]
            pub fn is_dsr(&self) -> bool {
                *self == FUNCR::DSR
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_1."]
            PIO,
            #[doc = "Selects function DSR (function not available on all parts, must also be configured in the corresponding DSR_LOC register)."]
            DSR,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::DSR => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_1."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function DSR (function not available on all parts, must also be configured in the corresponding DSR_LOC register)."]
            #[inline]
            pub fn dsr(self) -> &'a mut W {
                self.variant(FUNCW::DSR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO2_3/RI/MOSI1"]
    pub struct PIO2_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO2_3/RI/MOSI1"]
    pub mod pio2_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO2_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO2_3."]
            PIO,
            #[doc = "Selects function RI."]
            RI,
            #[doc = "Selects function MOSI1 (function not available on all parts)."]
            MOS,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::RI => 0x01,
                    FUNCR::MOS => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::RI,
                    2 => FUNCR::MOS,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `RI`"]
            #[inline]
            pub fn is_ri(&self) -> bool {
                *self == FUNCR::RI
            }
            #[doc = "Checks if the value of the field is `MOS`"]
            #[inline]
            pub fn is_mos(&self) -> bool {
                *self == FUNCR::MOS
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO2_3."]
            PIO,
            #[doc = "Selects function RI."]
            RI,
            #[doc = "Selects function MOSI1 (function not available on all parts)."]
            MOS,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::RI => 1,
                    FUNCW::MOS => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO2_3."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function RI."]
            #[inline]
            pub fn ri(self) -> &'a mut W {
                self.variant(FUNCW::RI)
            }
            #[doc = "Selects function MOSI1 (function not available on all parts)."]
            #[inline]
            pub fn mos(self) -> &'a mut W {
                self.variant(FUNCW::MOS)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin SWDIO/PIO1_3/AD4/ CT32B1_MAT2"]
    pub struct SWDIO_PIO1_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin SWDIO/PIO1_3/AD4/ CT32B1_MAT2"]
    pub mod swdio_pio1_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SWDIO_PIO1_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function SWDIO."]
            SWD,
            #[doc = "Selects function PIO1_3."]
            PIO,
            #[doc = "Selects function AD4."]
            AD4,
            #[doc = "Selects function CT32B1_MAT2."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::SWD => 0,
                    FUNCR::PIO => 0x01,
                    FUNCR::AD4 => 0x02,
                    FUNCR::CT3 => 0x03,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::SWD,
                    1 => FUNCR::PIO,
                    2 => FUNCR::AD4,
                    3 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `SWD`"]
            #[inline]
            pub fn is_swd(&self) -> bool {
                *self == FUNCR::SWD
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD4`"]
            #[inline]
            pub fn is_ad4(&self) -> bool {
                *self == FUNCR::AD4
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function SWDIO."]
            SWD,
            #[doc = "Selects function PIO1_3."]
            PIO,
            #[doc = "Selects function AD4."]
            AD4,
            #[doc = "Selects function CT32B1_MAT2."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::SWD => 0,
                    FUNCW::PIO => 1,
                    FUNCW::AD4 => 2,
                    FUNCW::CT3 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function SWDIO."]
            #[inline]
            pub fn swd(self) -> &'a mut W {
                self.variant(FUNCW::SWD)
            }
            #[doc = "Selects function PIO1_3."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD4."]
            #[inline]
            pub fn ad4(self) -> &'a mut W {
                self.variant(FUNCW::AD4)
            }
            #[doc = "Selects function CT32B1_MAT2."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3"]
    pub struct PIO1_4 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_4/AD5/CT32B1_MAT3"]
    pub mod pio1_4 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_4 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_4."]
            PIO,
            #[doc = "Selects function AD5."]
            AD5,
            #[doc = "Selects function CT32B1_MAT3."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::AD5 => 0x01,
                    FUNCR::CT3 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::AD5,
                    2 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD5`"]
            #[inline]
            pub fn is_ad5(&self) -> bool {
                *self == FUNCR::AD5
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_4."]
            PIO,
            #[doc = "Selects function AD5."]
            AD5,
            #[doc = "Selects function CT32B1_MAT3."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::AD5 => 1,
                    FUNCW::CT3 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_4."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD5."]
            #[inline]
            pub fn ad5(self) -> &'a mut W {
                self.variant(FUNCW::AD5)
            }
            #[doc = "Selects function CT32B1_MAT3."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. This pin functions as WAKEUP pin if the LPC13xx is in Deep power-down mode regardless of the value of FUNC. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. This pin functions as WAKEUP pin if the LPC13xx is in Deep power-down mode regardless of the value of FUNC. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_11/AD7"]
    pub struct PIO1_11 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_11/AD7"]
    pub mod pio1_11 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_11 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_11."]
            PIO,
            #[doc = "Selects function AD7."]
            AD7,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::AD7 => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::AD7,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `AD7`"]
            #[inline]
            pub fn is_ad7(&self) -> bool {
                *self == FUNCR::AD7
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `ADMODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADMODER {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADMODER::ANALOG_INPUT_MODE => false,
                    ADMODER::DIGITAL_FUNCTIONAL_M => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADMODER {
                match value {
                    false => ADMODER::ANALOG_INPUT_MODE,
                    true => ADMODER::DIGITAL_FUNCTIONAL_M,
                }
            }
            #[doc = "Checks if the value of the field is `ANALOG_INPUT_MODE`"]
            #[inline]
            pub fn is_analog_input_mode(&self) -> bool {
                *self == ADMODER::ANALOG_INPUT_MODE
            }
            #[doc = "Checks if the value of the field is `DIGITAL_FUNCTIONAL_M`"]
            #[inline]
            pub fn is_digital_functional_m(&self) -> bool {
                *self == ADMODER::DIGITAL_FUNCTIONAL_M
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_11."]
            PIO,
            #[doc = "Selects function AD7."]
            AD7,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::AD7 => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_11."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function AD7."]
            #[inline]
            pub fn ad7(self) -> &'a mut W {
                self.variant(FUNCW::AD7)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADMODE`"]
        pub enum ADMODEW {
            #[doc = "Analog input mode"]
            ANALOG_INPUT_MODE,
            #[doc = "Digital functional mode"]
            DIGITAL_FUNCTIONAL_M,
        }
        impl ADMODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADMODEW::ANALOG_INPUT_MODE => false,
                    ADMODEW::DIGITAL_FUNCTIONAL_M => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADMODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADMODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADMODEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Analog input mode"]
            #[inline]
            pub fn analog_input_mode(self) -> &'a mut W {
                self.variant(ADMODEW::ANALOG_INPUT_MODE)
            }
            #[doc = "Digital functional mode"]
            #[inline]
            pub fn digital_functional_m(self) -> &'a mut W {
                self.variant(ADMODEW::DIGITAL_FUNCTIONAL_M)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&self) -> ADMODER {
                ADMODER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 7 - Selects Analog/Digital mode"]
            #[inline]
            pub fn admode(&mut self) -> _ADMODEW {
                _ADMODEW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_2/DCD"]
    pub struct PIO3_2 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_2/DCD"]
    pub mod pio3_2 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_2 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_2."]
            PIO,
            #[doc = "Selects function DCD (function not available on all parts, must also be configured in the corresponding DCD_LOC register)."]
            DCD,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::DCD => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::DCD,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `DCD`"]
            #[inline]
            pub fn is_dcd(&self) -> bool {
                *self == FUNCR::DCD
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_2."]
            PIO,
            #[doc = "Selects function DCD (function not available on all parts, must also be configured in the corresponding DCD_LOC register)."]
            DCD,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::DCD => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_2."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function DCD (function not available on all parts, must also be configured in the corresponding DCD_LOC register)."]
            #[inline]
            pub fn dcd(self) -> &'a mut W {
                self.variant(FUNCW::DCD)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0"]
    pub struct PIO1_5 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_5/RTS/CT32B0_CAP0"]
    pub mod pio1_5 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_5 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_5."]
            PIO,
            #[doc = "Selects function RTS."]
            RTS,
            #[doc = "Selects function CT32B0_CAP0."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::RTS => 0x01,
                    FUNCR::CT3 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::RTS,
                    2 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `RTS`"]
            #[inline]
            pub fn is_rts(&self) -> bool {
                *self == FUNCR::RTS
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_5."]
            PIO,
            #[doc = "Selects function RTS."]
            RTS,
            #[doc = "Selects function CT32B0_CAP0."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::RTS => 1,
                    FUNCW::CT3 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_5."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function RTS."]
            #[inline]
            pub fn rts(self) -> &'a mut W {
                self.variant(FUNCW::RTS)
            }
            #[doc = "Selects function CT32B0_CAP0."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0"]
    pub struct PIO1_6 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_6/RXD/CT32B0_MAT0"]
    pub mod pio1_6 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_6 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_6."]
            PIO,
            #[doc = "Selects function RXD."]
            RXD,
            #[doc = "Selects function CT32B0_MAT0."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::RXD => 0x01,
                    FUNCR::CT3 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::RXD,
                    2 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `RXD`"]
            #[inline]
            pub fn is_rxd(&self) -> bool {
                *self == FUNCR::RXD
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_6."]
            PIO,
            #[doc = "Selects function RXD."]
            RXD,
            #[doc = "Selects function CT32B0_MAT0."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::RXD => 1,
                    FUNCW::CT3 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_6."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function RXD."]
            #[inline]
            pub fn rxd(self) -> &'a mut W {
                self.variant(FUNCW::RXD)
            }
            #[doc = "Selects function CT32B0_MAT0."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1"]
    pub struct PIO1_7 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO1_7/TXD/CT32B0_MAT1"]
    pub mod pio1_7 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO1_7 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO1_7."]
            PIO,
            #[doc = "Selects function TXD."]
            TXD,
            #[doc = "Selects function CT32B0_MAT1."]
            CT3,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::TXD => 0x01,
                    FUNCR::CT3 => 0x02,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::TXD,
                    2 => FUNCR::CT3,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `TXD`"]
            #[inline]
            pub fn is_txd(&self) -> bool {
                *self == FUNCR::TXD
            }
            #[doc = "Checks if the value of the field is `CT3`"]
            #[inline]
            pub fn is_ct3(&self) -> bool {
                *self == FUNCR::CT3
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO1_7."]
            PIO,
            #[doc = "Selects function TXD."]
            TXD,
            #[doc = "Selects function CT32B0_MAT1."]
            CT3,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::TXD => 1,
                    FUNCW::CT3 => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO1_7."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function TXD."]
            #[inline]
            pub fn txd(self) -> &'a mut W {
                self.variant(FUNCW::TXD)
            }
            #[doc = "Selects function CT32B0_MAT1."]
            #[inline]
            pub fn ct3(self) -> &'a mut W {
                self.variant(FUNCW::CT3)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "I/O configuration for pin PIO3_3/RI"]
    pub struct PIO3_3 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "I/O configuration for pin PIO3_3/RI"]
    pub mod pio3_3 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PIO3_3 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `FUNC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FUNCR {
            #[doc = "Selects function PIO3_3."]
            PIO,
            #[doc = "Selects function RI (function not available on all parts, must also be configured in the corresponding RI_LOC register)."]
            RI,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FUNCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FUNCR::PIO => 0,
                    FUNCR::RI => 0x01,
                    FUNCR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FUNCR {
                match value {
                    0 => FUNCR::PIO,
                    1 => FUNCR::RI,
                    i => FUNCR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `PIO`"]
            #[inline]
            pub fn is_pio(&self) -> bool {
                *self == FUNCR::PIO
            }
            #[doc = "Checks if the value of the field is `RI`"]
            #[inline]
            pub fn is_ri(&self) -> bool {
                *self == FUNCR::RI
            }
        }
        #[doc = "Possible values of the field `MODE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODER {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODER {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MODER::INACTIVE_NO_PULL_DO => 0,
                    MODER::PULL_DOWN_RESISTOR_E => 0x01,
                    MODER::PULL_UP_RESISTOR_ENA => 0x02,
                    MODER::REPEATER_MODE => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MODER {
                match value {
                    0 => MODER::INACTIVE_NO_PULL_DO,
                    1 => MODER::PULL_DOWN_RESISTOR_E,
                    2 => MODER::PULL_UP_RESISTOR_ENA,
                    3 => MODER::REPEATER_MODE,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `INACTIVE_NO_PULL_DO`"]
            #[inline]
            pub fn is_inactive_no_pull_do(&self) -> bool {
                *self == MODER::INACTIVE_NO_PULL_DO
            }
            #[doc = "Checks if the value of the field is `PULL_DOWN_RESISTOR_E`"]
            #[inline]
            pub fn is_pull_down_resistor_e(&self) -> bool {
                *self == MODER::PULL_DOWN_RESISTOR_E
            }
            #[doc = "Checks if the value of the field is `PULL_UP_RESISTOR_ENA`"]
            #[inline]
            pub fn is_pull_up_resistor_ena(&self) -> bool {
                *self == MODER::PULL_UP_RESISTOR_ENA
            }
            #[doc = "Checks if the value of the field is `REPEATER_MODE`"]
            #[inline]
            pub fn is_repeater_mode(&self) -> bool {
                *self == MODER::REPEATER_MODE
            }
        }
        #[doc = "Possible values of the field `HYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HYSR {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    HYSR::DISABLE => false,
                    HYSR::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> HYSR {
                match value {
                    false => HYSR::DISABLE,
                    true => HYSR::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == HYSR::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == HYSR::ENABLE
            }
        }
        #[doc = "Possible values of the field `OD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ODR::STANDARD_GPIO_OUTPUT => false,
                    ODR::OPEN_DRAIN_OUTPUT => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ODR {
                match value {
                    false => ODR::STANDARD_GPIO_OUTPUT,
                    true => ODR::OPEN_DRAIN_OUTPUT,
                }
            }
            #[doc = "Checks if the value of the field is `STANDARD_GPIO_OUTPUT`"]
            #[inline]
            pub fn is_standard_gpio_output(&self) -> bool {
                *self == ODR::STANDARD_GPIO_OUTPUT
            }
            #[doc = "Checks if the value of the field is `OPEN_DRAIN_OUTPUT`"]
            #[inline]
            pub fn is_open_drain_output(&self) -> bool {
                *self == ODR::OPEN_DRAIN_OUTPUT
            }
        }
        #[doc = "Values that can be written to the field `FUNC`"]
        pub enum FUNCW {
            #[doc = "Selects function PIO3_3."]
            PIO,
            #[doc = "Selects function RI (function not available on all parts, must also be configured in the corresponding RI_LOC register)."]
            RI,
        }
        impl FUNCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FUNCW::PIO => 0,
                    FUNCW::RI => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FUNCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FUNCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FUNCW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Selects function PIO3_3."]
            #[inline]
            pub fn pio(self) -> &'a mut W {
                self.variant(FUNCW::PIO)
            }
            #[doc = "Selects function RI (function not available on all parts, must also be configured in the corresponding RI_LOC register)."]
            #[inline]
            pub fn ri(self) -> &'a mut W {
                self.variant(FUNCW::RI)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `MODE`"]
        pub enum MODEW {
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            INACTIVE_NO_PULL_DO,
            #[doc = "Pull-down resistor enabled"]
            PULL_DOWN_RESISTOR_E,
            #[doc = "Pull-up resistor enabled"]
            PULL_UP_RESISTOR_ENA,
            #[doc = "Repeater mode"]
            REPEATER_MODE,
        }
        impl MODEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MODEW::INACTIVE_NO_PULL_DO => 0,
                    MODEW::PULL_DOWN_RESISTOR_E => 1,
                    MODEW::PULL_UP_RESISTOR_ENA => 2,
                    MODEW::REPEATER_MODE => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MODEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MODEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MODEW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Inactive (no pull-down/pull-up resistor enabled)"]
            #[inline]
            pub fn inactive_no_pull_do(self) -> &'a mut W {
                self.variant(MODEW::INACTIVE_NO_PULL_DO)
            }
            #[doc = "Pull-down resistor enabled"]
            #[inline]
            pub fn pull_down_resistor_e(self) -> &'a mut W {
                self.variant(MODEW::PULL_DOWN_RESISTOR_E)
            }
            #[doc = "Pull-up resistor enabled"]
            #[inline]
            pub fn pull_up_resistor_ena(self) -> &'a mut W {
                self.variant(MODEW::PULL_UP_RESISTOR_ENA)
            }
            #[doc = "Repeater mode"]
            #[inline]
            pub fn repeater_mode(self) -> &'a mut W {
                self.variant(MODEW::REPEATER_MODE)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `HYS`"]
        pub enum HYSW {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl HYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    HYSW::DISABLE => false,
                    HYSW::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _HYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _HYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: HYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(HYSW::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(HYSW::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `OD`"]
        pub enum ODW {
            #[doc = "Standard GPIO output"]
            STANDARD_GPIO_OUTPUT,
            #[doc = "Open-drain output"]
            OPEN_DRAIN_OUTPUT,
        }
        impl ODW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ODW::STANDARD_GPIO_OUTPUT => false,
                    ODW::OPEN_DRAIN_OUTPUT => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ODW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ODW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ODW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Standard GPIO output"]
            #[inline]
            pub fn standard_gpio_output(self) -> &'a mut W {
                self.variant(ODW::STANDARD_GPIO_OUTPUT)
            }
            #[doc = "Open-drain output"]
            #[inline]
            pub fn open_drain_output(self) -> &'a mut W {
                self.variant(ODW::OPEN_DRAIN_OUTPUT)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&self) -> FUNCR {
                FUNCR::_from({
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&self) -> MODER {
                MODER::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&self) -> HYSR {
                HYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&self) -> ODR {
                ODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xd0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Selects pin function. All other values are reserved."]
            #[inline]
            pub fn func(&mut self) -> _FUNCW {
                _FUNCW { w: self }
            }
            #[doc = "Bits 3:4 - Selects function mode (on-chip pull-up/pull-down resistor control)"]
            #[inline]
            pub fn mode(&mut self) -> _MODEW {
                _MODEW { w: self }
            }
            #[doc = "Bit 5 - Hysteresis"]
            #[inline]
            pub fn hys(&mut self) -> _HYSW {
                _HYSW { w: self }
            }
            #[doc = "Bit 10 - Selects pseudo open-drain mode."]
            #[inline]
            pub fn od(&mut self) -> _ODW {
                _ODW { w: self }
            }
        }
    }
    #[doc = "SCK0 pin location register"]
    pub struct SCK0_LOC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SCK0 pin location register"]
    pub mod sck0_loc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SCK0_LOC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SCKLOC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCKLOCR {
            #[doc = "Selects SCK0 function for pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 (see Table 121)."]
            SELECTS_SCK0_FUNCTIO_1,
            #[doc = "Selects SCK0 function for pin PIO2_11/SCK0 (see Table 123"]
            SELECTS_SCK0_FUNCTIO_2,
            #[doc = "Selects SCK0 function for pin PIO0_6/USB_CONNECT/SCK0 (see Table 114)."]
            SELECTS_SCK0_FUNCTIO_3,
            #[doc = "Reserved."]
            RESERVED,
        }
        impl SCKLOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SCKLOCR::SELECTS_SCK0_FUNCTIO_1 => 0,
                    SCKLOCR::SELECTS_SCK0_FUNCTIO_2 => 0x01,
                    SCKLOCR::SELECTS_SCK0_FUNCTIO_3 => 0x02,
                    SCKLOCR::RESERVED => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SCKLOCR {
                match value {
                    0 => SCKLOCR::SELECTS_SCK0_FUNCTIO_1,
                    1 => SCKLOCR::SELECTS_SCK0_FUNCTIO_2,
                    2 => SCKLOCR::SELECTS_SCK0_FUNCTIO_3,
                    3 => SCKLOCR::RESERVED,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_SCK0_FUNCTIO_1`"]
            #[inline]
            pub fn is_selects_sck0_functio_1(&self) -> bool {
                *self == SCKLOCR::SELECTS_SCK0_FUNCTIO_1
            }
            #[doc = "Checks if the value of the field is `SELECTS_SCK0_FUNCTIO_2`"]
            #[inline]
            pub fn is_selects_sck0_functio_2(&self) -> bool {
                *self == SCKLOCR::SELECTS_SCK0_FUNCTIO_2
            }
            #[doc = "Checks if the value of the field is `SELECTS_SCK0_FUNCTIO_3`"]
            #[inline]
            pub fn is_selects_sck0_functio_3(&self) -> bool {
                *self == SCKLOCR::SELECTS_SCK0_FUNCTIO_3
            }
            #[doc = "Checks if the value of the field is `RESERVED`"]
            #[inline]
            pub fn is_reserved(&self) -> bool {
                *self == SCKLOCR::RESERVED
            }
        }
        #[doc = "Values that can be written to the field `SCKLOC`"]
        pub enum SCKLOCW {
            #[doc = "Selects SCK0 function for pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 (see Table 121)."]
            SELECTS_SCK0_FUNCTIO_1,
            #[doc = "Selects SCK0 function for pin PIO2_11/SCK0 (see Table 123"]
            SELECTS_SCK0_FUNCTIO_2,
            #[doc = "Selects SCK0 function for pin PIO0_6/USB_CONNECT/SCK0 (see Table 114)."]
            SELECTS_SCK0_FUNCTIO_3,
            #[doc = "Reserved."]
            RESERVED,
        }
        impl SCKLOCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SCKLOCW::SELECTS_SCK0_FUNCTIO_1 => 0,
                    SCKLOCW::SELECTS_SCK0_FUNCTIO_2 => 1,
                    SCKLOCW::SELECTS_SCK0_FUNCTIO_3 => 2,
                    SCKLOCW::RESERVED => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SCKLOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SCKLOCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SCKLOCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Selects SCK0 function for pin SWCLK/PIO0_10/SCK0/CT16B0_MAT2 (see Table 121)."]
            #[inline]
            pub fn selects_sck0_functio_1(self) -> &'a mut W {
                self.variant(SCKLOCW::SELECTS_SCK0_FUNCTIO_1)
            }
            #[doc = "Selects SCK0 function for pin PIO2_11/SCK0 (see Table 123"]
            #[inline]
            pub fn selects_sck0_functio_2(self) -> &'a mut W {
                self.variant(SCKLOCW::SELECTS_SCK0_FUNCTIO_2)
            }
            #[doc = "Selects SCK0 function for pin PIO0_6/USB_CONNECT/SCK0 (see Table 114)."]
            #[inline]
            pub fn selects_sck0_functio_3(self) -> &'a mut W {
                self.variant(SCKLOCW::SELECTS_SCK0_FUNCTIO_3)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved(self) -> &'a mut W {
                self.variant(SCKLOCW::RESERVED)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Selects pin location for SCK0 pin."]
            #[inline]
            pub fn sckloc(&self) -> SCKLOCR {
                SCKLOCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Selects pin location for SCK0 pin."]
            #[inline]
            pub fn sckloc(&mut self) -> _SCKLOCW {
                _SCKLOCW { w: self }
            }
        }
    }
    #[doc = "DSR pin location select register"]
    pub struct DSR_LOC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DSR pin location select register"]
    pub mod dsr_loc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DSR_LOC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DSRLOC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DSRLOCR {
            #[doc = "Selects DSR function in pin location PIO2_1/DSR/SCK1."]
            SELECTS_DSR_FUNCTION_1,
            #[doc = "Selects DSR function in pin location PIO3_1/DSR."]
            SELECTS_DSR_FUNCTION_2,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl DSRLOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DSRLOCR::SELECTS_DSR_FUNCTION_1 => 0,
                    DSRLOCR::SELECTS_DSR_FUNCTION_2 => 0x01,
                    DSRLOCR::RESERVED_1 => 0x02,
                    DSRLOCR::RESERVED_2 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DSRLOCR {
                match value {
                    0 => DSRLOCR::SELECTS_DSR_FUNCTION_1,
                    1 => DSRLOCR::SELECTS_DSR_FUNCTION_2,
                    2 => DSRLOCR::RESERVED_1,
                    3 => DSRLOCR::RESERVED_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_DSR_FUNCTION_1`"]
            #[inline]
            pub fn is_selects_dsr_function_1(&self) -> bool {
                *self == DSRLOCR::SELECTS_DSR_FUNCTION_1
            }
            #[doc = "Checks if the value of the field is `SELECTS_DSR_FUNCTION_2`"]
            #[inline]
            pub fn is_selects_dsr_function_2(&self) -> bool {
                *self == DSRLOCR::SELECTS_DSR_FUNCTION_2
            }
            #[doc = "Checks if the value of the field is `RESERVED_1`"]
            #[inline]
            pub fn is_reserved_1(&self) -> bool {
                *self == DSRLOCR::RESERVED_1
            }
            #[doc = "Checks if the value of the field is `RESERVED_2`"]
            #[inline]
            pub fn is_reserved_2(&self) -> bool {
                *self == DSRLOCR::RESERVED_2
            }
        }
        #[doc = "Values that can be written to the field `DSRLOC`"]
        pub enum DSRLOCW {
            #[doc = "Selects DSR function in pin location PIO2_1/DSR/SCK1."]
            SELECTS_DSR_FUNCTION_1,
            #[doc = "Selects DSR function in pin location PIO3_1/DSR."]
            SELECTS_DSR_FUNCTION_2,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl DSRLOCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DSRLOCW::SELECTS_DSR_FUNCTION_1 => 0,
                    DSRLOCW::SELECTS_DSR_FUNCTION_2 => 1,
                    DSRLOCW::RESERVED_1 => 2,
                    DSRLOCW::RESERVED_2 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DSRLOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DSRLOCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DSRLOCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Selects DSR function in pin location PIO2_1/DSR/SCK1."]
            #[inline]
            pub fn selects_dsr_function_1(self) -> &'a mut W {
                self.variant(DSRLOCW::SELECTS_DSR_FUNCTION_1)
            }
            #[doc = "Selects DSR function in pin location PIO3_1/DSR."]
            #[inline]
            pub fn selects_dsr_function_2(self) -> &'a mut W {
                self.variant(DSRLOCW::SELECTS_DSR_FUNCTION_2)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_1(self) -> &'a mut W {
                self.variant(DSRLOCW::RESERVED_1)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_2(self) -> &'a mut W {
                self.variant(DSRLOCW::RESERVED_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Selects pin location for DSR0 pin (this register is only used for parts LPC1311/01 and LPC1313/01)."]
            #[inline]
            pub fn dsrloc(&self) -> DSRLOCR {
                DSRLOCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Selects pin location for DSR0 pin (this register is only used for parts LPC1311/01 and LPC1313/01)."]
            #[inline]
            pub fn dsrloc(&mut self) -> _DSRLOCW {
                _DSRLOCW { w: self }
            }
        }
    }
    #[doc = "DCD pin location select register"]
    pub struct DCD_LOC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "DCD pin location select register"]
    pub mod dcd_loc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DCD_LOC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `DCDLOC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DCDLOCR {
            #[doc = "Selects DCD function in pin location PIO2_2/DCD/MISO1."]
            SELECTS_DCD_FUNCTION,
            #[doc = "Selects  DCD function in pin location PIO3_2/DCD."]
            SELECTS_DCD_FUNCTIO,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl DCDLOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    DCDLOCR::SELECTS_DCD_FUNCTION => 0,
                    DCDLOCR::SELECTS_DCD_FUNCTIO => 0x01,
                    DCDLOCR::RESERVED_1 => 0x02,
                    DCDLOCR::RESERVED_2 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> DCDLOCR {
                match value {
                    0 => DCDLOCR::SELECTS_DCD_FUNCTION,
                    1 => DCDLOCR::SELECTS_DCD_FUNCTIO,
                    2 => DCDLOCR::RESERVED_1,
                    3 => DCDLOCR::RESERVED_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_DCD_FUNCTION`"]
            #[inline]
            pub fn is_selects_dcd_function(&self) -> bool {
                *self == DCDLOCR::SELECTS_DCD_FUNCTION
            }
            #[doc = "Checks if the value of the field is `SELECTS_DCD_FUNCTIO`"]
            #[inline]
            pub fn is_selects_dcd_functio(&self) -> bool {
                *self == DCDLOCR::SELECTS_DCD_FUNCTIO
            }
            #[doc = "Checks if the value of the field is `RESERVED_1`"]
            #[inline]
            pub fn is_reserved_1(&self) -> bool {
                *self == DCDLOCR::RESERVED_1
            }
            #[doc = "Checks if the value of the field is `RESERVED_2`"]
            #[inline]
            pub fn is_reserved_2(&self) -> bool {
                *self == DCDLOCR::RESERVED_2
            }
        }
        #[doc = "Values that can be written to the field `DCDLOC`"]
        pub enum DCDLOCW {
            #[doc = "Selects DCD function in pin location PIO2_2/DCD/MISO1."]
            SELECTS_DCD_FUNCTION,
            #[doc = "Selects  DCD function in pin location PIO3_2/DCD."]
            SELECTS_DCD_FUNCTIO,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl DCDLOCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    DCDLOCW::SELECTS_DCD_FUNCTION => 0,
                    DCDLOCW::SELECTS_DCD_FUNCTIO => 1,
                    DCDLOCW::RESERVED_1 => 2,
                    DCDLOCW::RESERVED_2 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _DCDLOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DCDLOCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: DCDLOCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Selects DCD function in pin location PIO2_2/DCD/MISO1."]
            #[inline]
            pub fn selects_dcd_function(self) -> &'a mut W {
                self.variant(DCDLOCW::SELECTS_DCD_FUNCTION)
            }
            #[doc = "Selects DCD function in pin location PIO3_2/DCD."]
            #[inline]
            pub fn selects_dcd_functio(self) -> &'a mut W {
                self.variant(DCDLOCW::SELECTS_DCD_FUNCTIO)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_1(self) -> &'a mut W {
                self.variant(DCDLOCW::RESERVED_1)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_2(self) -> &'a mut W {
                self.variant(DCDLOCW::RESERVED_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Selects pin location for DCD pin (this register is only used for parts LPC1311/01 and LPC1313/01)."]
            #[inline]
            pub fn dcdloc(&self) -> DCDLOCR {
                DCDLOCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Selects pin location for DCD pin (this register is only used for parts LPC1311/01 and LPC1313/01)."]
            #[inline]
            pub fn dcdloc(&mut self) -> _DCDLOCW {
                _DCDLOCW { w: self }
            }
        }
    }
    #[doc = "RI pin location register"]
    pub struct RI_LOC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "RI pin location register"]
    pub mod ri_loc {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::RI_LOC {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `RILOC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RILOCR {
            #[doc = "Selects RI function in pin location PIO2_3/RI/MOSI1."]
            SELECTS_RI_FUNCTION_1,
            #[doc = "Selects RI function in pin location PIO3_3/RI."]
            SELECTS_RI_FUNCTION_2,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl RILOCR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    RILOCR::SELECTS_RI_FUNCTION_1 => 0,
                    RILOCR::SELECTS_RI_FUNCTION_2 => 0x01,
                    RILOCR::RESERVED_1 => 0x02,
                    RILOCR::RESERVED_2 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> RILOCR {
                match value {
                    0 => RILOCR::SELECTS_RI_FUNCTION_1,
                    1 => RILOCR::SELECTS_RI_FUNCTION_2,
                    2 => RILOCR::RESERVED_1,
                    3 => RILOCR::RESERVED_2,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `SELECTS_RI_FUNCTION_1`"]
            #[inline]
            pub fn is_selects_ri_function_1(&self) -> bool {
                *self == RILOCR::SELECTS_RI_FUNCTION_1
            }
            #[doc = "Checks if the value of the field is `SELECTS_RI_FUNCTION_2`"]
            #[inline]
            pub fn is_selects_ri_function_2(&self) -> bool {
                *self == RILOCR::SELECTS_RI_FUNCTION_2
            }
            #[doc = "Checks if the value of the field is `RESERVED_1`"]
            #[inline]
            pub fn is_reserved_1(&self) -> bool {
                *self == RILOCR::RESERVED_1
            }
            #[doc = "Checks if the value of the field is `RESERVED_2`"]
            #[inline]
            pub fn is_reserved_2(&self) -> bool {
                *self == RILOCR::RESERVED_2
            }
        }
        #[doc = "Values that can be written to the field `RILOC`"]
        pub enum RILOCW {
            #[doc = "Selects RI function in pin location PIO2_3/RI/MOSI1."]
            SELECTS_RI_FUNCTION_1,
            #[doc = "Selects RI function in pin location PIO3_3/RI."]
            SELECTS_RI_FUNCTION_2,
            #[doc = "Reserved."]
            RESERVED_1,
            #[doc = "Reserved."]
            RESERVED_2,
        }
        impl RILOCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    RILOCW::SELECTS_RI_FUNCTION_1 => 0,
                    RILOCW::SELECTS_RI_FUNCTION_2 => 1,
                    RILOCW::RESERVED_1 => 2,
                    RILOCW::RESERVED_2 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RILOCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RILOCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RILOCW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "Selects RI function in pin location PIO2_3/RI/MOSI1."]
            #[inline]
            pub fn selects_ri_function_1(self) -> &'a mut W {
                self.variant(RILOCW::SELECTS_RI_FUNCTION_1)
            }
            #[doc = "Selects RI function in pin location PIO3_3/RI."]
            #[inline]
            pub fn selects_ri_function_2(self) -> &'a mut W {
                self.variant(RILOCW::SELECTS_RI_FUNCTION_2)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_1(self) -> &'a mut W {
                self.variant(RILOCW::RESERVED_1)
            }
            #[doc = "Reserved."]
            #[inline]
            pub fn reserved_2(self) -> &'a mut W {
                self.variant(RILOCW::RESERVED_2)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Selects pin location for RI pin (this register is only used for parts LPC1311/01 and LPC1313/01)"]
            #[inline]
            pub fn riloc(&self) -> RILOCR {
                RILOCR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Selects pin location for RI pin (this register is only used for parts LPC1311/01 and LPC1313/01)"]
            #[inline]
            pub fn riloc(&mut self) -> _RILOCW {
                _RILOCW { w: self }
            }
        }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx System configuration Modification date=4/4/2011 Major revision=2 Minor revision=2"]
pub struct SYSCON {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SYSCON {}
impl SYSCON {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const syscon::RegisterBlock {
        0x4004_8000 as *const _
    }
}
impl Deref for SYSCON {
    type Target = syscon::RegisterBlock;
    fn deref(&self) -> &syscon::RegisterBlock {
        unsafe { &*SYSCON::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx System configuration Modification date=4/4/2011 Major revision=2 Minor revision=2"]
pub mod syscon {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        #[doc = "0x00 - System memory remap"]
        pub sysmemremap: SYSMEMREMAP,
        #[doc = "0x04 - Peripheral reset control"]
        pub presetctrl: PRESETCTRL,
        #[doc = "0x08 - System PLL control"]
        pub syspllctrl: SYSPLLCTRL,
        #[doc = "0x0c - System PLL status"]
        pub syspllstat: SYSPLLSTAT,
        #[doc = "0x10 - USB PLL control"]
        pub usbpllctrl: USBPLLCTRL,
        #[doc = "0x14 - USB PLL status"]
        pub usbpllstat: USBPLLSTAT,
        _reserved0: [u8; 8usize],
        #[doc = "0x20 - System oscillator control"]
        pub sysoscctrl: SYSOSCCTRL,
        #[doc = "0x24 - Watchdog oscillator control"]
        pub wdtoscctrl: WDTOSCCTRL,
        #[doc = "0x28 - IRC control"]
        pub ircctrl: IRCCTRL,
        _reserved1: [u8; 4usize],
        #[doc = "0x30 - System reset status register"]
        pub sysresstat: SYSRESSTAT,
        _reserved2: [u8; 12usize],
        #[doc = "0x40 - System PLL clock source select"]
        pub syspllclksel: SYSPLLCLKSEL,
        #[doc = "0x44 - System PLL clock source update enable"]
        pub syspllclkuen: SYSPLLCLKUEN,
        #[doc = "0x48 - USB PLL clock source select"]
        pub usbpllclksel: USBPLLCLKSEL,
        #[doc = "0x4c - USB PLL clock source update enable"]
        pub usbpllclkuen: USBPLLCLKUEN,
        _reserved3: [u8; 32usize],
        #[doc = "0x70 - Main clock source select"]
        pub mainclksel: MAINCLKSEL,
        #[doc = "0x74 - Main clock source update enable"]
        pub mainclkuen: MAINCLKUEN,
        #[doc = "0x78 - System AHB clock divider"]
        pub sysahbclkdiv: SYSAHBCLKDIV,
        _reserved4: [u8; 4usize],
        #[doc = "0x80 - System AHB clock control"]
        pub sysahbclkctrl: SYSAHBCLKCTRL,
        _reserved5: [u8; 16usize],
        #[doc = "0x94 - SSP clock divder"]
        pub ssp0clkdiv: SSP0CLKDIV,
        #[doc = "0x98 - UART clock divder"]
        pub uartclkdiv: UARTCLKDIV,
        #[doc = "0x9c - SPISP1 clock divder"]
        pub ssp1clkdiv: SSP1CLKDIV,
        _reserved6: [u8; 12usize],
        #[doc = "0xac - ARM trace clock divider"]
        pub traceclkdiv: TRACECLKDIV,
        #[doc = "0xb0 - SYSTICK clock divder"]
        pub systickclkdiv: SYSTICKCLKDIV,
        _reserved7: [u8; 12usize],
        #[doc = "0xc0 - USB clock source select"]
        pub usbclksel: USBCLKSEL,
        #[doc = "0xc4 - USB clock source update enable"]
        pub usbclkuen: USBCLKUEN,
        #[doc = "0xc8 - USB clock source divider"]
        pub usbclkdiv: USBCLKDIV,
        _reserved8: [u8; 4usize],
        #[doc = "0xd0 - WDT clock source select"]
        pub wdtclksel: WDTCLKSEL,
        #[doc = "0xd4 - WDT clock source update enable"]
        pub wdtclkuen: WDTCLKUEN,
        #[doc = "0xd8 - WDT clock divider"]
        pub wdtclkdiv: WDTCLKDIV,
        _reserved9: [u8; 4usize],
        #[doc = "0xe0 - CLKOUT clock source select"]
        pub clkoutclksel: CLKOUTCLKSEL,
        #[doc = "0xe4 - CLKOUT clock source update enable"]
        pub clkoutuen: CLKOUTUEN,
        #[doc = "0xe8 - CLKOUT clock divider"]
        pub clkoutdiv: CLKOUTDIV,
        _reserved10: [u8; 20usize],
        #[doc = "0x100 - POR captured PIO status 0"]
        pub pioporcap0: PIOPORCAP0,
        #[doc = "0x104 - POR captured PIO status 1"]
        pub pioporcap1: PIOPORCAP1,
        _reserved11: [u8; 72usize],
        #[doc = "0x150 - BOD control"]
        pub bodctrl: BODCTRL,
        #[doc = "0x154 - System tick counter calibration"]
        pub systckcal: SYSTCKCAL,
        _reserved12: [u8; 168usize],
        #[doc = "0x200 - Start logic edge control register 0; bottom 32 interrupts"]
        pub startaprp0: STARTAPRP0,
        #[doc = "0x204 - Start logic signal enable register 0; bottom 32 interrupts"]
        pub starterp0: STARTERP0,
        #[doc = "0x208 - Start logic reset register 0; bottom 32 interrupts"]
        pub startrsrp0clr: STARTRSRP0CLR,
        #[doc = "0x20c - Start logic status register 0; bottom 32 interrupts"]
        pub startsrp0: STARTSRP0,
        #[doc = "0x210 - Start logic edge control register 1; top 8 interrupts"]
        pub startaprp1: STARTAPRP1,
        #[doc = "0x214 - Start logic signal enable register 1; top 8 interrupts"]
        pub starterp1: STARTERP1,
        #[doc = "0x218 - Start logic reset register 1; top 8 interrupts"]
        pub startrsrp1clr: STARTRSRP1CLR,
        #[doc = "0x21c - Start logic status register 1; top 8 interrupts"]
        pub startsrp1: STARTSRP1,
        _reserved13: [u8; 16usize],
        #[doc = "0x230 - Power-down states in Deep-sleep mode"]
        pub pdsleepcfg: PDSLEEPCFG,
        #[doc = "0x234 - Power-down states after wake-up from Deep-sleep mode"]
        pub pdawakecfg: PDAWAKECFG,
        #[doc = "0x238 - Power-down configuration register"]
        pub pdruncfg: PDRUNCFG,
        _reserved14: [u8; 440usize],
        #[doc = "0x3f4 - Device ID"]
        pub device_id: DEVICE_ID,
    }
    #[doc = "System memory remap"]
    pub struct SYSMEMREMAP {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System memory remap"]
    pub mod sysmemremap {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSMEMREMAP {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `MAP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MAPR {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE_IN,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE_INTER,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE_INT,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl MAPR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    MAPR::BOOT_LOADER_MODE_IN => 0,
                    MAPR::USER_RAM_MODE_INTER => 0x01,
                    MAPR::USER_FLASH_MODE_INT => 0x02,
                    MAPR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> MAPR {
                match value {
                    0 => MAPR::BOOT_LOADER_MODE_IN,
                    1 => MAPR::USER_RAM_MODE_INTER,
                    2 => MAPR::USER_FLASH_MODE_INT,
                    i => MAPR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `BOOT_LOADER_MODE_IN`"]
            #[inline]
            pub fn is_boot_loader_mode_in(&self) -> bool {
                *self == MAPR::BOOT_LOADER_MODE_IN
            }
            #[doc = "Checks if the value of the field is `USER_RAM_MODE_INTER`"]
            #[inline]
            pub fn is_user_ram_mode_inter(&self) -> bool {
                *self == MAPR::USER_RAM_MODE_INTER
            }
            #[doc = "Checks if the value of the field is `USER_FLASH_MODE_INT`"]
            #[inline]
            pub fn is_user_flash_mode_int(&self) -> bool {
                *self == MAPR::USER_FLASH_MODE_INT
            }
        }
        #[doc = "Values that can be written to the field `MAP`"]
        pub enum MAPW {
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            BOOT_LOADER_MODE_IN,
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            USER_RAM_MODE_INTER,
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            USER_FLASH_MODE_INT,
        }
        impl MAPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    MAPW::BOOT_LOADER_MODE_IN => 0,
                    MAPW::USER_RAM_MODE_INTER => 1,
                    MAPW::USER_FLASH_MODE_INT => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _MAPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MAPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: MAPW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "Boot Loader Mode. Interrupt vectors are re-mapped to Boot ROM."]
            #[inline]
            pub fn boot_loader_mode_in(self) -> &'a mut W {
                self.variant(MAPW::BOOT_LOADER_MODE_IN)
            }
            #[doc = "User RAM Mode. Interrupt vectors are re-mapped to Static RAM."]
            #[inline]
            pub fn user_ram_mode_inter(self) -> &'a mut W {
                self.variant(MAPW::USER_RAM_MODE_INTER)
            }
            #[doc = "User Flash Mode. Interrupt vectors are not re-mapped and reside in Flash."]
            #[inline]
            pub fn user_flash_mode_int(self) -> &'a mut W {
                self.variant(MAPW::USER_FLASH_MODE_INT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System memory remap"]
            #[inline]
            pub fn map(&self) -> MAPR {
                MAPR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x02 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System memory remap"]
            #[inline]
            pub fn map(&mut self) -> _MAPW {
                _MAPW { w: self }
            }
        }
    }
    #[doc = "Peripheral reset control"]
    pub struct PRESETCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Peripheral reset control"]
    pub mod presetctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PRESETCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SSP0_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSP0_RST_NR {
            #[doc = "Reset SSP0."]
            RESET_SSP0,
            #[doc = "De-assert SSP0 reset."]
            DE_ASSERT_SSP0_RESET,
        }
        impl SSP0_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSP0_RST_NR::RESET_SSP0 => false,
                    SSP0_RST_NR::DE_ASSERT_SSP0_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSP0_RST_NR {
                match value {
                    false => SSP0_RST_NR::RESET_SSP0,
                    true => SSP0_RST_NR::DE_ASSERT_SSP0_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `RESET_SSP0`"]
            #[inline]
            pub fn is_reset_ssp0(&self) -> bool {
                *self == SSP0_RST_NR::RESET_SSP0
            }
            #[doc = "Checks if the value of the field is `DE_ASSERT_SSP0_RESET`"]
            #[inline]
            pub fn is_de_assert_ssp0_reset(&self) -> bool {
                *self == SSP0_RST_NR::DE_ASSERT_SSP0_RESET
            }
        }
        #[doc = "Possible values of the field `I2C_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2C_RST_NR {
            #[doc = "Reset I2C."]
            RESET_I2C,
            #[doc = "De-asset I2C reset."]
            DE_ASSET_I2C_RESET,
        }
        impl I2C_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2C_RST_NR::RESET_I2C => false,
                    I2C_RST_NR::DE_ASSET_I2C_RESET => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2C_RST_NR {
                match value {
                    false => I2C_RST_NR::RESET_I2C,
                    true => I2C_RST_NR::DE_ASSET_I2C_RESET,
                }
            }
            #[doc = "Checks if the value of the field is `RESET_I2C`"]
            #[inline]
            pub fn is_reset_i2c(&self) -> bool {
                *self == I2C_RST_NR::RESET_I2C
            }
            #[doc = "Checks if the value of the field is `DE_ASSET_I2C_RESET`"]
            #[inline]
            pub fn is_de_asset_i2c_reset(&self) -> bool {
                *self == I2C_RST_NR::DE_ASSET_I2C_RESET
            }
        }
        #[doc = "Possible values of the field `SSP1_RST_N`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSP1_RST_NR {
            #[doc = "Reset the SPISP1."]
            RESET_THE_SPISP1,
            #[doc = "De-assert SPISP1 reset."]
            DE_ASSERT_SPISP1_RES,
        }
        impl SSP1_RST_NR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSP1_RST_NR::RESET_THE_SPISP1 => false,
                    SSP1_RST_NR::DE_ASSERT_SPISP1_RES => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSP1_RST_NR {
                match value {
                    false => SSP1_RST_NR::RESET_THE_SPISP1,
                    true => SSP1_RST_NR::DE_ASSERT_SPISP1_RES,
                }
            }
            #[doc = "Checks if the value of the field is `RESET_THE_SPISP1`"]
            #[inline]
            pub fn is_reset_the_spisp1(&self) -> bool {
                *self == SSP1_RST_NR::RESET_THE_SPISP1
            }
            #[doc = "Checks if the value of the field is `DE_ASSERT_SPISP1_RES`"]
            #[inline]
            pub fn is_de_assert_spisp1_res(&self) -> bool {
                *self == SSP1_RST_NR::DE_ASSERT_SPISP1_RES
            }
        }
        #[doc = "Values that can be written to the field `SSP0_RST_N`"]
        pub enum SSP0_RST_NW {
            #[doc = "Reset SSP0."]
            RESET_SSP0,
            #[doc = "De-assert SSP0 reset."]
            DE_ASSERT_SSP0_RESET,
        }
        impl SSP0_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSP0_RST_NW::RESET_SSP0 => false,
                    SSP0_RST_NW::DE_ASSERT_SSP0_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSP0_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSP0_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSP0_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset SSP0."]
            #[inline]
            pub fn reset_ssp0(self) -> &'a mut W {
                self.variant(SSP0_RST_NW::RESET_SSP0)
            }
            #[doc = "De-assert SSP0 reset."]
            #[inline]
            pub fn de_assert_ssp0_reset(self) -> &'a mut W {
                self.variant(SSP0_RST_NW::DE_ASSERT_SSP0_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C_RST_N`"]
        pub enum I2C_RST_NW {
            #[doc = "Reset I2C."]
            RESET_I2C,
            #[doc = "De-asset I2C reset."]
            DE_ASSET_I2C_RESET,
        }
        impl I2C_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2C_RST_NW::RESET_I2C => false,
                    I2C_RST_NW::DE_ASSET_I2C_RESET => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2C_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2C_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2C_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset I2C."]
            #[inline]
            pub fn reset_i2c(self) -> &'a mut W {
                self.variant(I2C_RST_NW::RESET_I2C)
            }
            #[doc = "De-asset I2C reset."]
            #[inline]
            pub fn de_asset_i2c_reset(self) -> &'a mut W {
                self.variant(I2C_RST_NW::DE_ASSET_I2C_RESET)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSP1_RST_N`"]
        pub enum SSP1_RST_NW {
            #[doc = "Reset the SPISP1."]
            RESET_THE_SPISP1,
            #[doc = "De-assert SPISP1 reset."]
            DE_ASSERT_SPISP1_RES,
        }
        impl SSP1_RST_NW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSP1_RST_NW::RESET_THE_SPISP1 => false,
                    SSP1_RST_NW::DE_ASSERT_SPISP1_RES => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSP1_RST_NW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSP1_RST_NW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSP1_RST_NW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Reset the SPISP1."]
            #[inline]
            pub fn reset_the_spisp1(self) -> &'a mut W {
                self.variant(SSP1_RST_NW::RESET_THE_SPISP1)
            }
            #[doc = "De-assert SPISP1 reset."]
            #[inline]
            pub fn de_assert_spisp1_res(self) -> &'a mut W {
                self.variant(SSP1_RST_NW::DE_ASSERT_SPISP1_RES)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - SSP0 reset control"]
            #[inline]
            pub fn ssp0_rst_n(&self) -> SSP0_RST_NR {
                SSP0_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - I2C reset control"]
            #[inline]
            pub fn i2c_rst_n(&self) -> I2C_RST_NR {
                I2C_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - SPISP1 reset control"]
            #[inline]
            pub fn ssp1_rst_n(&self) -> SSP1_RST_NR {
                SSP1_RST_NR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - SSP0 reset control"]
            #[inline]
            pub fn ssp0_rst_n(&mut self) -> _SSP0_RST_NW {
                _SSP0_RST_NW { w: self }
            }
            #[doc = "Bit 1 - I2C reset control"]
            #[inline]
            pub fn i2c_rst_n(&mut self) -> _I2C_RST_NW {
                _I2C_RST_NW { w: self }
            }
            #[doc = "Bit 2 - SPISP1 reset control"]
            #[inline]
            pub fn ssp1_rst_n(&mut self) -> _SSP1_RST_NW {
                _SSP1_RST_NW { w: self }
            }
        }
    }
    #[doc = "System PLL control"]
    pub struct SYSPLLCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL control"]
    pub mod syspllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSELR {
            bits: u8,
        }
        impl MSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::P_EQ_1 => 0,
                    PSELR::P_EQ_2 => 0x01,
                    PSELR::P_EQ_4 => 0x02,
                    PSELR::P_EQ_8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::P_EQ_1,
                    1 => PSELR::P_EQ_2,
                    2 => PSELR::P_EQ_4,
                    3 => PSELR::P_EQ_8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `P_EQ_1`"]
            #[inline]
            pub fn is_p_eq_1(&self) -> bool {
                *self == PSELR::P_EQ_1
            }
            #[doc = "Checks if the value of the field is `P_EQ_2`"]
            #[inline]
            pub fn is_p_eq_2(&self) -> bool {
                *self == PSELR::P_EQ_2
            }
            #[doc = "Checks if the value of the field is `P_EQ_4`"]
            #[inline]
            pub fn is_p_eq_4(&self) -> bool {
                *self == PSELR::P_EQ_4
            }
            #[doc = "Checks if the value of the field is `P_EQ_8`"]
            #[inline]
            pub fn is_p_eq_8(&self) -> bool {
                *self == PSELR::P_EQ_8
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::P_EQ_1 => 0,
                    PSELW::P_EQ_2 => 1,
                    PSELW::P_EQ_4 => 2,
                    PSELW::P_EQ_8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "P = 1"]
            #[inline]
            pub fn p_eq_1(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_1)
            }
            #[doc = "P = 2"]
            #[inline]
            pub fn p_eq_2(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_2)
            }
            #[doc = "P = 4"]
            #[inline]
            pub fn p_eq_4(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_4)
            }
            #[doc = "P = 8"]
            #[inline]
            pub fn p_eq_8(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32."]
            #[inline]
            pub fn msel(&self) -> MSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MSELR { bits }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32."]
            #[inline]
            pub fn msel(&mut self) -> _MSELW {
                _MSELW { w: self }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
        }
    }
    #[doc = "System PLL status"]
    pub struct SYSPLLSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL status"]
    pub mod syspllstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SYSPLLSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `LOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKR {
            #[doc = "PLL not locked"]
            PLL_NOT_LOCKED,
            #[doc = "PLL locked"]
            PLL_LOCKED,
        }
        impl LOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKR::PLL_NOT_LOCKED => false,
                    LOCKR::PLL_LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOCKR {
                match value {
                    false => LOCKR::PLL_NOT_LOCKED,
                    true => LOCKR::PLL_LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `PLL_NOT_LOCKED`"]
            #[inline]
            pub fn is_pll_not_locked(&self) -> bool {
                *self == LOCKR::PLL_NOT_LOCKED
            }
            #[doc = "Checks if the value of the field is `PLL_LOCKED`"]
            #[inline]
            pub fn is_pll_locked(&self) -> bool {
                *self == LOCKR::PLL_LOCKED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PLL lock status"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                LOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "USB PLL control"]
    pub struct USBPLLCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB PLL control"]
    pub mod usbpllctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBPLLCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MSELR {
            bits: u8,
        }
        impl MSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `PSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PSELR {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    PSELR::P_EQ_1 => 0,
                    PSELR::P_EQ_2 => 0x01,
                    PSELR::P_EQ_4 => 0x02,
                    PSELR::P_EQ_8 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> PSELR {
                match value {
                    0 => PSELR::P_EQ_1,
                    1 => PSELR::P_EQ_2,
                    2 => PSELR::P_EQ_4,
                    3 => PSELR::P_EQ_8,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `P_EQ_1`"]
            #[inline]
            pub fn is_p_eq_1(&self) -> bool {
                *self == PSELR::P_EQ_1
            }
            #[doc = "Checks if the value of the field is `P_EQ_2`"]
            #[inline]
            pub fn is_p_eq_2(&self) -> bool {
                *self == PSELR::P_EQ_2
            }
            #[doc = "Checks if the value of the field is `P_EQ_4`"]
            #[inline]
            pub fn is_p_eq_4(&self) -> bool {
                *self == PSELR::P_EQ_4
            }
            #[doc = "Checks if the value of the field is `P_EQ_8`"]
            #[inline]
            pub fn is_p_eq_8(&self) -> bool {
                *self == PSELR::P_EQ_8
            }
        }
        #[doc = r" Proxy"]
        pub struct _MSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _MSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `PSEL`"]
        pub enum PSELW {
            #[doc = "P = 1"]
            P_EQ_1,
            #[doc = "P = 2"]
            P_EQ_2,
            #[doc = "P = 4"]
            P_EQ_4,
            #[doc = "P = 8"]
            P_EQ_8,
        }
        impl PSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    PSELW::P_EQ_1 => 0,
                    PSELW::P_EQ_2 => 1,
                    PSELW::P_EQ_4 => 2,
                    PSELW::P_EQ_8 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _PSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _PSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: PSELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "P = 1"]
            #[inline]
            pub fn p_eq_1(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_1)
            }
            #[doc = "P = 2"]
            #[inline]
            pub fn p_eq_2(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_2)
            }
            #[doc = "P = 4"]
            #[inline]
            pub fn p_eq_4(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_4)
            }
            #[doc = "P = 8"]
            #[inline]
            pub fn p_eq_8(self) -> &'a mut W {
                self.variant(PSELW::P_EQ_8)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32."]
            #[inline]
            pub fn msel(&self) -> MSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                MSELR { bits }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&self) -> PSELR {
                PSELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Feedback divider value. The division value M is the programmed MSEL value + 1. 00000: Division ratio M = 1 to 11111: Division ratio M = 32."]
            #[inline]
            pub fn msel(&mut self) -> _MSELW {
                _MSELW { w: self }
            }
            #[doc = "Bits 5:6 - Post divider ratio P. The division ratio is 2 x P."]
            #[inline]
            pub fn psel(&mut self) -> _PSELW {
                _PSELW { w: self }
            }
        }
    }
    #[doc = "USB PLL status"]
    pub struct USBPLLSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB PLL status"]
    pub mod usbpllstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::USBPLLSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `LOCK`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LOCKR {
            #[doc = "PLL not locked"]
            PLL_NOT_LOCKED,
            #[doc = "PLL locked"]
            PLL_LOCKED,
        }
        impl LOCKR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    LOCKR::PLL_NOT_LOCKED => false,
                    LOCKR::PLL_LOCKED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> LOCKR {
                match value {
                    false => LOCKR::PLL_NOT_LOCKED,
                    true => LOCKR::PLL_LOCKED,
                }
            }
            #[doc = "Checks if the value of the field is `PLL_NOT_LOCKED`"]
            #[inline]
            pub fn is_pll_not_locked(&self) -> bool {
                *self == LOCKR::PLL_NOT_LOCKED
            }
            #[doc = "Checks if the value of the field is `PLL_LOCKED`"]
            #[inline]
            pub fn is_pll_locked(&self) -> bool {
                *self == LOCKR::PLL_LOCKED
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - PLL lock status"]
            #[inline]
            pub fn lock(&self) -> LOCKR {
                LOCKR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "System oscillator control"]
    pub struct SYSOSCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System oscillator control"]
    pub mod sysoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BYPASS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BYPASSR {
            #[doc = "Oscillator is not bypassed."]
            OSCILLATOR_IS_NOT_BY,
            #[doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN and XTALOUT pins."]
            BYPASS_ENABLED_PLL,
        }
        impl BYPASSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BYPASSR::OSCILLATOR_IS_NOT_BY => false,
                    BYPASSR::BYPASS_ENABLED_PLL => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BYPASSR {
                match value {
                    false => BYPASSR::OSCILLATOR_IS_NOT_BY,
                    true => BYPASSR::BYPASS_ENABLED_PLL,
                }
            }
            #[doc = "Checks if the value of the field is `OSCILLATOR_IS_NOT_BY`"]
            #[inline]
            pub fn is_oscillator_is_not_by(&self) -> bool {
                *self == BYPASSR::OSCILLATOR_IS_NOT_BY
            }
            #[doc = "Checks if the value of the field is `BYPASS_ENABLED_PLL`"]
            #[inline]
            pub fn is_bypass_enabled_pll(&self) -> bool {
                *self == BYPASSR::BYPASS_ENABLED_PLL
            }
        }
        #[doc = "Possible values of the field `FREQRANGE`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQRANGER {
            #[doc = "1 - 20 MHz frequency range."]
            _1_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_25_MHZ_FREQUENC,
        }
        impl FREQRANGER {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FREQRANGER::_1_20_MHZ_FREQUENCY => false,
                    FREQRANGER::_15_25_MHZ_FREQUENC => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FREQRANGER {
                match value {
                    false => FREQRANGER::_1_20_MHZ_FREQUENCY,
                    true => FREQRANGER::_15_25_MHZ_FREQUENC,
                }
            }
            #[doc = "Checks if the value of the field is `_1_20_MHZ_FREQUENCY`"]
            #[inline]
            pub fn is_1_20_mhz_frequency(&self) -> bool {
                *self == FREQRANGER::_1_20_MHZ_FREQUENCY
            }
            #[doc = "Checks if the value of the field is `_15_25_MHZ_FREQUENC`"]
            #[inline]
            pub fn is_15_25_mhz_frequenc(&self) -> bool {
                *self == FREQRANGER::_15_25_MHZ_FREQUENC
            }
        }
        #[doc = "Values that can be written to the field `BYPASS`"]
        pub enum BYPASSW {
            #[doc = "Oscillator is not bypassed."]
            OSCILLATOR_IS_NOT_BY,
            #[doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN and XTALOUT pins."]
            BYPASS_ENABLED_PLL,
        }
        impl BYPASSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BYPASSW::OSCILLATOR_IS_NOT_BY => false,
                    BYPASSW::BYPASS_ENABLED_PLL => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BYPASSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BYPASSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BYPASSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Oscillator is not bypassed."]
            #[inline]
            pub fn oscillator_is_not_by(self) -> &'a mut W {
                self.variant(BYPASSW::OSCILLATOR_IS_NOT_BY)
            }
            #[doc = "Bypass enabled. PLL input (sys_osc_clk) is fed directly from the XTALIN and XTALOUT pins."]
            #[inline]
            pub fn bypass_enabled_pll(self) -> &'a mut W {
                self.variant(BYPASSW::BYPASS_ENABLED_PLL)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQRANGE`"]
        pub enum FREQRANGEW {
            #[doc = "1 - 20 MHz frequency range."]
            _1_20_MHZ_FREQUENCY,
            #[doc = "15 - 25 MHz frequency range"]
            _15_25_MHZ_FREQUENC,
        }
        impl FREQRANGEW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FREQRANGEW::_1_20_MHZ_FREQUENCY => false,
                    FREQRANGEW::_15_25_MHZ_FREQUENC => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQRANGEW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQRANGEW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQRANGEW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "1 - 20 MHz frequency range."]
            #[inline]
            pub fn _1_20_mhz_frequency(self) -> &'a mut W {
                self.variant(FREQRANGEW::_1_20_MHZ_FREQUENCY)
            }
            #[doc = "15 - 25 MHz frequency range"]
            #[inline]
            pub fn _15_25_mhz_frequenc(self) -> &'a mut W {
                self.variant(FREQRANGEW::_15_25_MHZ_FREQUENC)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline]
            pub fn bypass(&self) -> BYPASSR {
                BYPASSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Determines frequency range for Low-power oscillator."]
            #[inline]
            pub fn freqrange(&self) -> FREQRANGER {
                FREQRANGER::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Bypass system oscillator"]
            #[inline]
            pub fn bypass(&mut self) -> _BYPASSW {
                _BYPASSW { w: self }
            }
            #[doc = "Bit 1 - Determines frequency range for Low-power oscillator."]
            #[inline]
            pub fn freqrange(&mut self) -> _FREQRANGEW {
                _FREQRANGEW { w: self }
            }
        }
    }
    #[doc = "Watchdog oscillator control"]
    pub struct WDTOSCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Watchdog oscillator control"]
    pub mod wdtoscctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTOSCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVSELR {
            bits: u8,
        }
        impl DIVSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `FREQSEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FREQSELR {
            #[doc = "0.5 MHz"]
            _0_5_MHZ,
            #[doc = "0.8 MHz"]
            _0_8_MHZ,
            #[doc = "1.1 MHz"]
            _1_1_MHZ,
            #[doc = "1.4 MHz"]
            _1_4_MHZ,
            #[doc = "1.6 MHz"]
            _1_6_MHZ,
            #[doc = "1.8 MHz"]
            _1_8_MHZ,
            #[doc = "2.0 MHz"]
            _2_0_MHZ,
            #[doc = "2.2 MHz"]
            _2_2_MHZ,
            #[doc = "2.4 MHz"]
            _2_4_MHZ,
            #[doc = "2.6 MHz"]
            _2_6_MHZ,
            #[doc = "2.7 MHz"]
            _2_7_MHZ,
            #[doc = "2.9 MHz"]
            _2_9_MHZ,
            #[doc = "3.1 MHz"]
            _3_1_MHZ,
            #[doc = "3.2 MHz"]
            _3_2_MHZ,
            #[doc = "3.4 MHz"]
            _3_4_MHZ,
            #[doc = r" Reserved"]
            _Reserved(u8),
        }
        impl FREQSELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    FREQSELR::_0_5_MHZ => 0x01,
                    FREQSELR::_0_8_MHZ => 0x02,
                    FREQSELR::_1_1_MHZ => 0x03,
                    FREQSELR::_1_4_MHZ => 0x04,
                    FREQSELR::_1_6_MHZ => 0x05,
                    FREQSELR::_1_8_MHZ => 0x06,
                    FREQSELR::_2_0_MHZ => 0x07,
                    FREQSELR::_2_2_MHZ => 0x08,
                    FREQSELR::_2_4_MHZ => 0x09,
                    FREQSELR::_2_6_MHZ => 0x0a,
                    FREQSELR::_2_7_MHZ => 0x0b,
                    FREQSELR::_2_9_MHZ => 0x0c,
                    FREQSELR::_3_1_MHZ => 0x0d,
                    FREQSELR::_3_2_MHZ => 0x0e,
                    FREQSELR::_3_4_MHZ => 0x0f,
                    FREQSELR::_Reserved(bits) => bits,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> FREQSELR {
                match value {
                    1 => FREQSELR::_0_5_MHZ,
                    2 => FREQSELR::_0_8_MHZ,
                    3 => FREQSELR::_1_1_MHZ,
                    4 => FREQSELR::_1_4_MHZ,
                    5 => FREQSELR::_1_6_MHZ,
                    6 => FREQSELR::_1_8_MHZ,
                    7 => FREQSELR::_2_0_MHZ,
                    8 => FREQSELR::_2_2_MHZ,
                    9 => FREQSELR::_2_4_MHZ,
                    10 => FREQSELR::_2_6_MHZ,
                    11 => FREQSELR::_2_7_MHZ,
                    12 => FREQSELR::_2_9_MHZ,
                    13 => FREQSELR::_3_1_MHZ,
                    14 => FREQSELR::_3_2_MHZ,
                    15 => FREQSELR::_3_4_MHZ,
                    i => FREQSELR::_Reserved(i),
                }
            }
            #[doc = "Checks if the value of the field is `_0_5_MHZ`"]
            #[inline]
            pub fn is_0_5_mhz(&self) -> bool {
                *self == FREQSELR::_0_5_MHZ
            }
            #[doc = "Checks if the value of the field is `_0_8_MHZ`"]
            #[inline]
            pub fn is_0_8_mhz(&self) -> bool {
                *self == FREQSELR::_0_8_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_1_MHZ`"]
            #[inline]
            pub fn is_1_1_mhz(&self) -> bool {
                *self == FREQSELR::_1_1_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_4_MHZ`"]
            #[inline]
            pub fn is_1_4_mhz(&self) -> bool {
                *self == FREQSELR::_1_4_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_6_MHZ`"]
            #[inline]
            pub fn is_1_6_mhz(&self) -> bool {
                *self == FREQSELR::_1_6_MHZ
            }
            #[doc = "Checks if the value of the field is `_1_8_MHZ`"]
            #[inline]
            pub fn is_1_8_mhz(&self) -> bool {
                *self == FREQSELR::_1_8_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_0_MHZ`"]
            #[inline]
            pub fn is_2_0_mhz(&self) -> bool {
                *self == FREQSELR::_2_0_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_2_MHZ`"]
            #[inline]
            pub fn is_2_2_mhz(&self) -> bool {
                *self == FREQSELR::_2_2_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_4_MHZ`"]
            #[inline]
            pub fn is_2_4_mhz(&self) -> bool {
                *self == FREQSELR::_2_4_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_6_MHZ`"]
            #[inline]
            pub fn is_2_6_mhz(&self) -> bool {
                *self == FREQSELR::_2_6_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_7_MHZ`"]
            #[inline]
            pub fn is_2_7_mhz(&self) -> bool {
                *self == FREQSELR::_2_7_MHZ
            }
            #[doc = "Checks if the value of the field is `_2_9_MHZ`"]
            #[inline]
            pub fn is_2_9_mhz(&self) -> bool {
                *self == FREQSELR::_2_9_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_1_MHZ`"]
            #[inline]
            pub fn is_3_1_mhz(&self) -> bool {
                *self == FREQSELR::_3_1_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_2_MHZ`"]
            #[inline]
            pub fn is_3_2_mhz(&self) -> bool {
                *self == FREQSELR::_3_2_MHZ
            }
            #[doc = "Checks if the value of the field is `_3_4_MHZ`"]
            #[inline]
            pub fn is_3_4_mhz(&self) -> bool {
                *self == FREQSELR::_3_4_MHZ
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVSELW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FREQSEL`"]
        pub enum FREQSELW {
            #[doc = "0.5 MHz"]
            _0_5_MHZ,
            #[doc = "0.8 MHz"]
            _0_8_MHZ,
            #[doc = "1.1 MHz"]
            _1_1_MHZ,
            #[doc = "1.4 MHz"]
            _1_4_MHZ,
            #[doc = "1.6 MHz"]
            _1_6_MHZ,
            #[doc = "1.8 MHz"]
            _1_8_MHZ,
            #[doc = "2.0 MHz"]
            _2_0_MHZ,
            #[doc = "2.2 MHz"]
            _2_2_MHZ,
            #[doc = "2.4 MHz"]
            _2_4_MHZ,
            #[doc = "2.6 MHz"]
            _2_6_MHZ,
            #[doc = "2.7 MHz"]
            _2_7_MHZ,
            #[doc = "2.9 MHz"]
            _2_9_MHZ,
            #[doc = "3.1 MHz"]
            _3_1_MHZ,
            #[doc = "3.2 MHz"]
            _3_2_MHZ,
            #[doc = "3.4 MHz"]
            _3_4_MHZ,
        }
        impl FREQSELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    FREQSELW::_0_5_MHZ => 1,
                    FREQSELW::_0_8_MHZ => 2,
                    FREQSELW::_1_1_MHZ => 3,
                    FREQSELW::_1_4_MHZ => 4,
                    FREQSELW::_1_6_MHZ => 5,
                    FREQSELW::_1_8_MHZ => 6,
                    FREQSELW::_2_0_MHZ => 7,
                    FREQSELW::_2_2_MHZ => 8,
                    FREQSELW::_2_4_MHZ => 9,
                    FREQSELW::_2_6_MHZ => 10,
                    FREQSELW::_2_7_MHZ => 11,
                    FREQSELW::_2_9_MHZ => 12,
                    FREQSELW::_3_1_MHZ => 13,
                    FREQSELW::_3_2_MHZ => 14,
                    FREQSELW::_3_4_MHZ => 15,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FREQSELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FREQSELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FREQSELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "0.5 MHz"]
            #[inline]
            pub fn _0_5_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_0_5_MHZ)
            }
            #[doc = "0.8 MHz"]
            #[inline]
            pub fn _0_8_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_0_8_MHZ)
            }
            #[doc = "1.1 MHz"]
            #[inline]
            pub fn _1_1_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_1_MHZ)
            }
            #[doc = "1.4 MHz"]
            #[inline]
            pub fn _1_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_4_MHZ)
            }
            #[doc = "1.6 MHz"]
            #[inline]
            pub fn _1_6_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_6_MHZ)
            }
            #[doc = "1.8 MHz"]
            #[inline]
            pub fn _1_8_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_1_8_MHZ)
            }
            #[doc = "2.0 MHz"]
            #[inline]
            pub fn _2_0_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_0_MHZ)
            }
            #[doc = "2.2 MHz"]
            #[inline]
            pub fn _2_2_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_2_MHZ)
            }
            #[doc = "2.4 MHz"]
            #[inline]
            pub fn _2_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_4_MHZ)
            }
            #[doc = "2.6 MHz"]
            #[inline]
            pub fn _2_6_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_6_MHZ)
            }
            #[doc = "2.7 MHz"]
            #[inline]
            pub fn _2_7_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_7_MHZ)
            }
            #[doc = "2.9 MHz"]
            #[inline]
            pub fn _2_9_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_2_9_MHZ)
            }
            #[doc = "3.1 MHz"]
            #[inline]
            pub fn _3_1_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_1_MHZ)
            }
            #[doc = "3.2 MHz"]
            #[inline]
            pub fn _3_2_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_2_MHZ)
            }
            #[doc = "3.4 MHz"]
            #[inline]
            pub fn _3_4_mhz(self) -> &'a mut W {
                self.variant(FREQSELW::_3_4_MHZ)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x0f;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana (2 x (1 + DIVSEL)). 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline]
            pub fn divsel(&self) -> DIVSELR {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVSELR { bits }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline]
            pub fn freqsel(&self) -> FREQSELR {
                FREQSELR::_from({
                    const MASK: u8 = 0x0f;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:4 - Select divider for Fclkana. wdt_osc_clk = Fclkana (2 x (1 + DIVSEL)). 00000: 2 x (1 + DIVSEL) = 2 00001: 2 x (1 + DIVSEL) = 4 to 11111: 2 x (1 + DIVSEL) = 64"]
            #[inline]
            pub fn divsel(&mut self) -> _DIVSELW {
                _DIVSELW { w: self }
            }
            #[doc = "Bits 5:8 - Select watchdog oscillator analog output frequency (Fclkana)."]
            #[inline]
            pub fn freqsel(&mut self) -> _FREQSELW {
                _FREQSELW { w: self }
            }
        }
    }
    #[doc = "IRC control"]
    pub struct IRCCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "IRC control"]
    pub mod ircctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IRCCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct TRIMR {
            bits: u8,
        }
        impl TRIMR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _TRIMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _TRIMW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Trim value"]
            #[inline]
            pub fn trim(&self) -> TRIMR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                TRIMR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x80 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Trim value"]
            #[inline]
            pub fn trim(&mut self) -> _TRIMW {
                _TRIMW { w: self }
            }
        }
    }
    #[doc = "System reset status register"]
    pub struct SYSRESSTAT {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System reset status register"]
    pub mod sysresstat {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::SYSRESSTAT {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = "Possible values of the field `POR`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PORR {
            #[doc = "No POR detected"]
            NO_POR_DETECTED,
            #[doc = "POR detected"]
            POR_DETECTED,
        }
        impl PORR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    PORR::NO_POR_DETECTED => false,
                    PORR::POR_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> PORR {
                match value {
                    false => PORR::NO_POR_DETECTED,
                    true => PORR::POR_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_POR_DETECTED`"]
            #[inline]
            pub fn is_no_por_detected(&self) -> bool {
                *self == PORR::NO_POR_DETECTED
            }
            #[doc = "Checks if the value of the field is `POR_DETECTED`"]
            #[inline]
            pub fn is_por_detected(&self) -> bool {
                *self == PORR::POR_DETECTED
            }
        }
        #[doc = "Possible values of the field `EXTRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTRSTR {
            #[doc = "No RESET event detected"]
            NO_RESET_EVENT_DETEC,
            #[doc = "RESET detected"]
            RESET_DETECTED,
        }
        impl EXTRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    EXTRSTR::NO_RESET_EVENT_DETEC => false,
                    EXTRSTR::RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> EXTRSTR {
                match value {
                    false => EXTRSTR::NO_RESET_EVENT_DETEC,
                    true => EXTRSTR::RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_RESET_EVENT_DETEC`"]
            #[inline]
            pub fn is_no_reset_event_detec(&self) -> bool {
                *self == EXTRSTR::NO_RESET_EVENT_DETEC
            }
            #[doc = "Checks if the value of the field is `RESET_DETECTED`"]
            #[inline]
            pub fn is_reset_detected(&self) -> bool {
                *self == EXTRSTR::RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `WDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTR {
            #[doc = "No WDT reset detected"]
            NO_WDT_RESET_DETECTE,
            #[doc = "WDT reset detected"]
            WDT_RESET_DETECTED,
        }
        impl WDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTR::NO_WDT_RESET_DETECTE => false,
                    WDTR::WDT_RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTR {
                match value {
                    false => WDTR::NO_WDT_RESET_DETECTE,
                    true => WDTR::WDT_RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_WDT_RESET_DETECTE`"]
            #[inline]
            pub fn is_no_wdt_reset_detecte(&self) -> bool {
                *self == WDTR::NO_WDT_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `WDT_RESET_DETECTED`"]
            #[inline]
            pub fn is_wdt_reset_detected(&self) -> bool {
                *self == WDTR::WDT_RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `BOD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODR {
            #[doc = "No BOD reset detected"]
            NO_BOD_RESET_DETECTE,
            #[doc = "BOD reset detected"]
            BOD_RESET_DETECTED,
        }
        impl BODR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BODR::NO_BOD_RESET_DETECTE => false,
                    BODR::BOD_RESET_DETECTED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BODR {
                match value {
                    false => BODR::NO_BOD_RESET_DETECTE,
                    true => BODR::BOD_RESET_DETECTED,
                }
            }
            #[doc = "Checks if the value of the field is `NO_BOD_RESET_DETECTE`"]
            #[inline]
            pub fn is_no_bod_reset_detecte(&self) -> bool {
                *self == BODR::NO_BOD_RESET_DETECTE
            }
            #[doc = "Checks if the value of the field is `BOD_RESET_DETECTED`"]
            #[inline]
            pub fn is_bod_reset_detected(&self) -> bool {
                *self == BODR::BOD_RESET_DETECTED
            }
        }
        #[doc = "Possible values of the field `SYSRST`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSRSTR {
            #[doc = "No System reset detected"]
            NO_SYSTEM_RESET_DETE,
            #[doc = "System reset detected"]
            SYSTEM_RESET_DETECTE,
        }
        impl SYSRSTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSRSTR::NO_SYSTEM_RESET_DETE => false,
                    SYSRSTR::SYSTEM_RESET_DETECTE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSRSTR {
                match value {
                    false => SYSRSTR::NO_SYSTEM_RESET_DETE,
                    true => SYSRSTR::SYSTEM_RESET_DETECTE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_SYSTEM_RESET_DETE`"]
            #[inline]
            pub fn is_no_system_reset_dete(&self) -> bool {
                *self == SYSRSTR::NO_SYSTEM_RESET_DETE
            }
            #[doc = "Checks if the value of the field is `SYSTEM_RESET_DETECTE`"]
            #[inline]
            pub fn is_system_reset_detecte(&self) -> bool {
                *self == SYSRSTR::SYSTEM_RESET_DETECTE
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - POR reset status"]
            #[inline]
            pub fn por(&self) -> PORR {
                PORR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Status of the external RESET pin"]
            #[inline]
            pub fn extrst(&self) -> EXTRSTR {
                EXTRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Status of the Watchdog reset"]
            #[inline]
            pub fn wdt(&self) -> WDTR {
                WDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Status of the Brown-out detect reset"]
            #[inline]
            pub fn bod(&self) -> BODR {
                BODR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Status of the software system reset. The ARM software reset has the same effect as the hardware reset using the RESET pin."]
            #[inline]
            pub fn sysrst(&self) -> SYSRSTR {
                SYSRSTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
    }
    #[doc = "System PLL clock source select"]
    pub struct SYSPLLCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL clock source select"]
    pub mod syspllclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::SYSTEM_OSCILLATOR => 0x01,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::SYSTEM_OSCILLATOR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `SYSTEM_OSCILLATOR`"]
            #[inline]
            pub fn is_system_oscillator(&self) -> bool {
                *self == SELR::SYSTEM_OSCILLATOR
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::SYSTEM_OSCILLATOR => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IRC oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "System oscillator"]
            #[inline]
            pub fn system_oscillator(self) -> &'a mut W {
                self.variant(SELW::SYSTEM_OSCILLATOR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - System PLL clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "System PLL clock source update enable"]
    pub struct SYSPLLCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System PLL clock source update enable"]
    pub mod syspllclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSPLLCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable system PLL clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "USB PLL clock source select"]
    pub struct USBPLLCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB PLL clock source select"]
    pub mod usbpllclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBPLLCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct USB operation."]
            IRC_THE_USB_PLL_CLO,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_THE_USB_PLL_CLO => 0,
                    SELR::SYSTEM_OSCILLATOR => 0x01,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_THE_USB_PLL_CLO,
                    1 => SELR::SYSTEM_OSCILLATOR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_THE_USB_PLL_CLO`"]
            #[inline]
            pub fn is_irc_the_usb_pll_clo(&self) -> bool {
                *self == SELR::IRC_THE_USB_PLL_CLO
            }
            #[doc = "Checks if the value of the field is `SYSTEM_OSCILLATOR`"]
            #[inline]
            pub fn is_system_oscillator(&self) -> bool {
                *self == SELR::SYSTEM_OSCILLATOR
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct USB operation."]
            IRC_THE_USB_PLL_CLO,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_THE_USB_PLL_CLO => 0,
                    SELW::SYSTEM_OSCILLATOR => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IRC. The USB PLL clock source must be switched to system oscillator for correct USB operation."]
            #[inline]
            pub fn irc_the_usb_pll_clo(self) -> &'a mut W {
                self.variant(SELW::IRC_THE_USB_PLL_CLO)
            }
            #[doc = "System oscillator"]
            #[inline]
            pub fn system_oscillator(self) -> &'a mut W {
                self.variant(SELW::SYSTEM_OSCILLATOR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - USB PLL clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - USB PLL clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "USB PLL clock source update enable"]
    pub struct USBPLLCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB PLL clock source update enable"]
    pub mod usbpllclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBPLLCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable USB PLL clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable USB PLL clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "Main clock source select"]
    pub struct MAINCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Main clock source select"]
    pub mod mainclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Input clock to system PLL"]
            INPUT_CLOCK_TO_SYSTE,
            #[doc = "WDT oscillator"]
            WDT_OSCILLATOR,
            #[doc = "System PLL clock out"]
            SYSTEM_PLL_CLOCK_OUT,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::INPUT_CLOCK_TO_SYSTE => 0x01,
                    SELR::WDT_OSCILLATOR => 0x02,
                    SELR::SYSTEM_PLL_CLOCK_OUT => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::INPUT_CLOCK_TO_SYSTE,
                    2 => SELR::WDT_OSCILLATOR,
                    3 => SELR::SYSTEM_PLL_CLOCK_OUT,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `INPUT_CLOCK_TO_SYSTE`"]
            #[inline]
            pub fn is_input_clock_to_syste(&self) -> bool {
                *self == SELR::INPUT_CLOCK_TO_SYSTE
            }
            #[doc = "Checks if the value of the field is `WDT_OSCILLATOR`"]
            #[inline]
            pub fn is_wdt_oscillator(&self) -> bool {
                *self == SELR::WDT_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `SYSTEM_PLL_CLOCK_OUT`"]
            #[inline]
            pub fn is_system_pll_clock_out(&self) -> bool {
                *self == SELR::SYSTEM_PLL_CLOCK_OUT
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Input clock to system PLL"]
            INPUT_CLOCK_TO_SYSTE,
            #[doc = "WDT oscillator"]
            WDT_OSCILLATOR,
            #[doc = "System PLL clock out"]
            SYSTEM_PLL_CLOCK_OUT,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::INPUT_CLOCK_TO_SYSTE => 1,
                    SELW::WDT_OSCILLATOR => 2,
                    SELW::SYSTEM_PLL_CLOCK_OUT => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "Input clock to system PLL"]
            #[inline]
            pub fn input_clock_to_syste(self) -> &'a mut W {
                self.variant(SELW::INPUT_CLOCK_TO_SYSTE)
            }
            #[doc = "WDT oscillator"]
            #[inline]
            pub fn wdt_oscillator(self) -> &'a mut W {
                self.variant(SELW::WDT_OSCILLATOR)
            }
            #[doc = "System PLL clock out"]
            #[inline]
            pub fn system_pll_clock_out(self) -> &'a mut W {
                self.variant(SELW::SYSTEM_PLL_CLOCK_OUT)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - Clock source for main clock"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "Main clock source update enable"]
    pub struct MAINCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Main clock source update enable"]
    pub mod mainclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::MAINCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable main clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "System AHB clock divider"]
    pub struct SYSAHBCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System AHB clock divider"]
    pub mod sysahbclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - System AHB clock divider values 0: System clock disabled. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "System AHB clock control"]
    pub struct SYSAHBCLKCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System AHB clock control"]
    pub mod sysahbclkctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSAHBCLKCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SYS`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSR {
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SYSR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSR {
                match value {
                    true => SYSR::ENABLED,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SYSR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ROM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ROMR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl ROMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ROMR::DISABLED => false,
                    ROMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ROMR {
                match value {
                    false => ROMR::DISABLED,
                    true => ROMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ROMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ROMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `RAM`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RAMR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl RAMR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    RAMR::DISABLED => false,
                    RAMR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> RAMR {
                match value {
                    false => RAMR::DISABLED,
                    true => RAMR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == RAMR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == RAMR::ENABLED
            }
        }
        #[doc = "Possible values of the field `FLASHREG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHREGR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl FLASHREGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHREGR::DISABLED => false,
                    FLASHREGR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASHREGR {
                match value {
                    false => FLASHREGR::DISABLED,
                    true => FLASHREGR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == FLASHREGR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == FLASHREGR::ENABLED
            }
        }
        #[doc = "Possible values of the field `FLASHARRAY`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASHARRAYR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl FLASHARRAYR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASHARRAYR::DISABLED => false,
                    FLASHARRAYR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASHARRAYR {
                match value {
                    false => FLASHARRAYR::DISABLED,
                    true => FLASHARRAYR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == FLASHARRAYR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == FLASHARRAYR::ENABLED
            }
        }
        #[doc = "Possible values of the field `I2C`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum I2CR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2CR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    I2CR::DISABLED => false,
                    I2CR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> I2CR {
                match value {
                    false => I2CR::DISABLED,
                    true => I2CR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == I2CR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == I2CR::ENABLED
            }
        }
        #[doc = "Possible values of the field `GPIO`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GPIOR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl GPIOR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    GPIOR::DISABLED => false,
                    GPIOR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> GPIOR {
                match value {
                    false => GPIOR::DISABLED,
                    true => GPIOR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == GPIOR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == GPIOR::ENABLED
            }
        }
        #[doc = "Possible values of the field `CT16B0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CT16B0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT16B0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CT16B0R::DISABLED => false,
                    CT16B0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CT16B0R {
                match value {
                    false => CT16B0R::DISABLED,
                    true => CT16B0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CT16B0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CT16B0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CT16B1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CT16B1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT16B1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CT16B1R::DISABLED => false,
                    CT16B1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CT16B1R {
                match value {
                    false => CT16B1R::DISABLED,
                    true => CT16B1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CT16B1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CT16B1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CT32B0`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CT32B0R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT32B0R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CT32B0R::DISABLED => false,
                    CT32B0R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CT32B0R {
                match value {
                    false => CT32B0R::DISABLED,
                    true => CT32B0R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CT32B0R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CT32B0R::ENABLED
            }
        }
        #[doc = "Possible values of the field `CT32B1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CT32B1R {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT32B1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    CT32B1R::DISABLED => false,
                    CT32B1R::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> CT32B1R {
                match value {
                    false => CT32B1R::DISABLED,
                    true => CT32B1R::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == CT32B1R::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == CT32B1R::ENABLED
            }
        }
        #[doc = "Possible values of the field `SSP`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSPR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SSPR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSPR::DISABLED => false,
                    SSPR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSPR {
                match value {
                    false => SSPR::DISABLED,
                    true => SSPR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == SSPR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == SSPR::ENABLED
            }
        }
        #[doc = "Possible values of the field `UART`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UARTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl UARTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    UARTR::DISABLED => false,
                    UARTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> UARTR {
                match value {
                    false => UARTR::DISABLED,
                    true => UARTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == UARTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == UARTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `ADC`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADCR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl ADCR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADCR::DISABLED => false,
                    ADCR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADCR {
                match value {
                    false => ADCR::DISABLED,
                    true => ADCR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == ADCR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == ADCR::ENABLED
            }
        }
        #[doc = "Possible values of the field `USB_REG`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USB_REGR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USB_REGR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USB_REGR::DISABLED => false,
                    USB_REGR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USB_REGR {
                match value {
                    false => USB_REGR::DISABLED,
                    true => USB_REGR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == USB_REGR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == USB_REGR::ENABLED
            }
        }
        #[doc = "Possible values of the field `WDT`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WDTR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTR::DISABLED => false,
                    WDTR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTR {
                match value {
                    false => WDTR::DISABLED,
                    true => WDTR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == WDTR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == WDTR::ENABLED
            }
        }
        #[doc = "Possible values of the field `IOCON`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IOCONR {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl IOCONR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IOCONR::DISABLED => false,
                    IOCONR::ENABLED => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IOCONR {
                match value {
                    false => IOCONR::DISABLED,
                    true => IOCONR::ENABLED,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLED`"]
            #[inline]
            pub fn is_disabled(&self) -> bool {
                *self == IOCONR::DISABLED
            }
            #[doc = "Checks if the value of the field is `ENABLED`"]
            #[inline]
            pub fn is_enabled(&self) -> bool {
                *self == IOCONR::ENABLED
            }
        }
        #[doc = "Possible values of the field `SSP1`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSP1R {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SSP1R {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SSP1R::DISABLE => false,
                    SSP1R::ENABLE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SSP1R {
                match value {
                    false => SSP1R::DISABLE,
                    true => SSP1R::ENABLE,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE`"]
            #[inline]
            pub fn is_disable(&self) -> bool {
                *self == SSP1R::DISABLE
            }
            #[doc = "Checks if the value of the field is `ENABLE`"]
            #[inline]
            pub fn is_enable(&self) -> bool {
                *self == SSP1R::ENABLE
            }
        }
        #[doc = "Values that can be written to the field `SYS`"]
        pub enum SYSW {
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SYSW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SYSW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ROM`"]
        pub enum ROMW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl ROMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ROMW::DISABLED => false,
                    ROMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ROMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ROMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ROMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ROMW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ROMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `RAM`"]
        pub enum RAMW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl RAMW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    RAMW::DISABLED => false,
                    RAMW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _RAMW<'a> {
            w: &'a mut W,
        }
        impl<'a> _RAMW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: RAMW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RAMW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RAMW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASHREG`"]
        pub enum FLASHREGW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl FLASHREGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHREGW::DISABLED => false,
                    FLASHREGW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHREGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHREGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHREGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FLASHREGW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FLASHREGW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASHARRAY`"]
        pub enum FLASHARRAYW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl FLASHARRAYW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASHARRAYW::DISABLED => false,
                    FLASHARRAYW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASHARRAYW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASHARRAYW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASHARRAYW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FLASHARRAYW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FLASHARRAYW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `I2C`"]
        pub enum I2CW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl I2CW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    I2CW::DISABLED => false,
                    I2CW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _I2CW<'a> {
            w: &'a mut W,
        }
        impl<'a> _I2CW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: I2CW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2CW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2CW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `GPIO`"]
        pub enum GPIOW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl GPIOW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    GPIOW::DISABLED => false,
                    GPIOW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _GPIOW<'a> {
            w: &'a mut W,
        }
        impl<'a> _GPIOW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: GPIOW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(GPIOW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(GPIOW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CT16B0`"]
        pub enum CT16B0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT16B0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CT16B0W::DISABLED => false,
                    CT16B0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CT16B0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CT16B0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CT16B0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CT16B0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CT16B0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CT16B1`"]
        pub enum CT16B1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT16B1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CT16B1W::DISABLED => false,
                    CT16B1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CT16B1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CT16B1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CT16B1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CT16B1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CT16B1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CT32B0`"]
        pub enum CT32B0W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT32B0W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CT32B0W::DISABLED => false,
                    CT32B0W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CT32B0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CT32B0W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CT32B0W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CT32B0W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CT32B0W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `CT32B1`"]
        pub enum CT32B1W {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl CT32B1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    CT32B1W::DISABLED => false,
                    CT32B1W::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _CT32B1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CT32B1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: CT32B1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CT32B1W::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CT32B1W::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSP`"]
        pub enum SSPW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl SSPW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSPW::DISABLED => false,
                    SSPW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSPW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSPW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSPW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSPW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSPW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `UART`"]
        pub enum UARTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl UARTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    UARTW::DISABLED => false,
                    UARTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _UARTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _UARTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: UARTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UARTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UARTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC`"]
        pub enum ADCW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl ADCW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADCW::DISABLED => false,
                    ADCW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADCW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADCW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADCW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADCW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADCW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USB_REG`"]
        pub enum USB_REGW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl USB_REGW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USB_REGW::DISABLED => false,
                    USB_REGW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USB_REGW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USB_REGW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USB_REGW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USB_REGW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USB_REGW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDT`"]
        pub enum WDTW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl WDTW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTW::DISABLED => false,
                    WDTW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WDTW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WDTW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IOCON`"]
        pub enum IOCONW {
            #[doc = "Disabled"]
            DISABLED,
            #[doc = "Enabled"]
            ENABLED,
        }
        impl IOCONW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IOCONW::DISABLED => false,
                    IOCONW::ENABLED => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IOCONW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IOCONW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IOCONW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disabled"]
            #[inline]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOCONW::DISABLED)
            }
            #[doc = "Enabled"]
            #[inline]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOCONW::ENABLED)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SSP1`"]
        pub enum SSP1W {
            #[doc = "Disable"]
            DISABLE,
            #[doc = "Enable"]
            ENABLE,
        }
        impl SSP1W {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SSP1W::DISABLE => false,
                    SSP1W::ENABLE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SSP1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _SSP1W<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SSP1W) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable"]
            #[inline]
            pub fn disable(self) -> &'a mut W {
                self.variant(SSP1W::DISABLE)
            }
            #[doc = "Enable"]
            #[inline]
            pub fn enable(self) -> &'a mut W {
                self.variant(SSP1W::ENABLE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enables clock for AHB to APB bridge, to the AHB matrix, to the Cortex-M3 FCLK and HCLK, to the SysCon, and to the PMU. This bit is read only."]
            #[inline]
            pub fn sys(&self) -> SYSR {
                SYSR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline]
            pub fn rom(&self) -> ROMR {
                ROMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Enables clock for RAM."]
            #[inline]
            pub fn ram(&self) -> RAMR {
                RAMR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline]
            pub fn flashreg(&self) -> FLASHREGR {
                FLASHREGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - Enables clock for flash array access."]
            #[inline]
            pub fn flasharray(&self) -> FLASHARRAYR {
                FLASHARRAYR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - Enables clock for I2C."]
            #[inline]
            pub fn i2c(&self) -> I2CR {
                I2CR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Enables clock for GPIO."]
            #[inline]
            pub fn gpio(&self) -> GPIOR {
                GPIOR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - Enables clock for 16-bit counter/timer 0."]
            #[inline]
            pub fn ct16b0(&self) -> CT16B0R {
                CT16B0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - Enables clock for 16-bit counter/timer 1."]
            #[inline]
            pub fn ct16b1(&self) -> CT16B1R {
                CT16B1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Enables clock for 32-bit counter/timer 0."]
            #[inline]
            pub fn ct32b0(&self) -> CT32B0R {
                CT32B0R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 10 - Enables clock for 32-bit counter/timer 1."]
            #[inline]
            pub fn ct32b1(&self) -> CT32B1R {
                CT32B1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Enables clock for SSP."]
            #[inline]
            pub fn ssp(&self) -> SSPR {
                SSPR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 12 - Enables clock for UART. Note that the UART pins must be configured in the IOCON block before the UART clock can be enabled."]
            #[inline]
            pub fn uart(&self) -> UARTR {
                UARTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 13 - Enables clock for ADC."]
            #[inline]
            pub fn adc(&self) -> ADCR {
                ADCR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 14 - Enables clock for USB_REG."]
            #[inline]
            pub fn usb_reg(&self) -> USB_REGR {
                USB_REGR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 15 - Enables clock for WDT."]
            #[inline]
            pub fn wdt(&self) -> WDTR {
                WDTR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 16 - Enables clock for IO configuration block."]
            #[inline]
            pub fn iocon(&self) -> IOCONR {
                IOCONR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 18 - Enables clock for SPISP1."]
            #[inline]
            pub fn ssp1(&self) -> SSP1R {
                SSP1R::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x485f }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enables clock for AHB to APB bridge, to the AHB matrix, to the Cortex-M3 FCLK and HCLK, to the SysCon, and to the PMU. This bit is read only."]
            #[inline]
            pub fn sys(&mut self) -> _SYSW {
                _SYSW { w: self }
            }
            #[doc = "Bit 1 - Enables clock for ROM."]
            #[inline]
            pub fn rom(&mut self) -> _ROMW {
                _ROMW { w: self }
            }
            #[doc = "Bit 2 - Enables clock for RAM."]
            #[inline]
            pub fn ram(&mut self) -> _RAMW {
                _RAMW { w: self }
            }
            #[doc = "Bit 3 - Enables clock for flash register interface."]
            #[inline]
            pub fn flashreg(&mut self) -> _FLASHREGW {
                _FLASHREGW { w: self }
            }
            #[doc = "Bit 4 - Enables clock for flash array access."]
            #[inline]
            pub fn flasharray(&mut self) -> _FLASHARRAYW {
                _FLASHARRAYW { w: self }
            }
            #[doc = "Bit 5 - Enables clock for I2C."]
            #[inline]
            pub fn i2c(&mut self) -> _I2CW {
                _I2CW { w: self }
            }
            #[doc = "Bit 6 - Enables clock for GPIO."]
            #[inline]
            pub fn gpio(&mut self) -> _GPIOW {
                _GPIOW { w: self }
            }
            #[doc = "Bit 7 - Enables clock for 16-bit counter/timer 0."]
            #[inline]
            pub fn ct16b0(&mut self) -> _CT16B0W {
                _CT16B0W { w: self }
            }
            #[doc = "Bit 8 - Enables clock for 16-bit counter/timer 1."]
            #[inline]
            pub fn ct16b1(&mut self) -> _CT16B1W {
                _CT16B1W { w: self }
            }
            #[doc = "Bit 9 - Enables clock for 32-bit counter/timer 0."]
            #[inline]
            pub fn ct32b0(&mut self) -> _CT32B0W {
                _CT32B0W { w: self }
            }
            #[doc = "Bit 10 - Enables clock for 32-bit counter/timer 1."]
            #[inline]
            pub fn ct32b1(&mut self) -> _CT32B1W {
                _CT32B1W { w: self }
            }
            #[doc = "Bit 11 - Enables clock for SSP."]
            #[inline]
            pub fn ssp(&mut self) -> _SSPW {
                _SSPW { w: self }
            }
            #[doc = "Bit 12 - Enables clock for UART. Note that the UART pins must be configured in the IOCON block before the UART clock can be enabled."]
            #[inline]
            pub fn uart(&mut self) -> _UARTW {
                _UARTW { w: self }
            }
            #[doc = "Bit 13 - Enables clock for ADC."]
            #[inline]
            pub fn adc(&mut self) -> _ADCW {
                _ADCW { w: self }
            }
            #[doc = "Bit 14 - Enables clock for USB_REG."]
            #[inline]
            pub fn usb_reg(&mut self) -> _USB_REGW {
                _USB_REGW { w: self }
            }
            #[doc = "Bit 15 - Enables clock for WDT."]
            #[inline]
            pub fn wdt(&mut self) -> _WDTW {
                _WDTW { w: self }
            }
            #[doc = "Bit 16 - Enables clock for IO configuration block."]
            #[inline]
            pub fn iocon(&mut self) -> _IOCONW {
                _IOCONW { w: self }
            }
            #[doc = "Bit 18 - Enables clock for SPISP1."]
            #[inline]
            pub fn ssp1(&mut self) -> _SSP1W {
                _SSP1W { w: self }
            }
        }
    }
    #[doc = "SSP clock divder"]
    pub struct SSP0CLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SSP clock divder"]
    pub mod ssp0clkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSP0CLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SSP_PCLK clock divider values. 0: Disable SSP0_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SSP_PCLK clock divider values. 0: Disable SSP0_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "UART clock divder"]
    pub struct UARTCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "UART clock divder"]
    pub mod uartclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::UARTCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - UART_PCLK clock divider values 0: Disable UART_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - UART_PCLK clock divider values 0: Disable UART_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "SPISP1 clock divder"]
    pub struct SSP1CLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SPISP1 clock divder"]
    pub mod ssp1clkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SSP1CLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SSP1_PCLK clock divider values 0: Disable SSP1_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SSP1_PCLK clock divider values 0: Disable SSP1_PCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "ARM trace clock divider"]
    pub struct TRACECLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "ARM trace clock divider"]
    pub mod traceclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::TRACECLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - ARM trace clock divider values. 0: Disable TRACE_CLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - ARM trace clock divider values. 0: Disable TRACE_CLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "SYSTICK clock divder"]
    pub struct SYSTICKCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "SYSTICK clock divder"]
    pub mod systickclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSTICKCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - SYSTICK clock divider values. 0: Disable SYSTICK timer clock. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - SYSTICK clock divider values. 0: Disable SYSTICK timer clock. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "USB clock source select"]
    pub struct USBCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB clock source select"]
    pub mod usbclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "USB PLL out"]
            USB_PLL_OUT,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::USB_PLL_OUT => 0,
                    SELR::MAIN_CLOCK => 0x01,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::USB_PLL_OUT,
                    1 => SELR::MAIN_CLOCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `USB_PLL_OUT`"]
            #[inline]
            pub fn is_usb_pll_out(&self) -> bool {
                *self == SELR::USB_PLL_OUT
            }
            #[doc = "Checks if the value of the field is `MAIN_CLOCK`"]
            #[inline]
            pub fn is_main_clock(&self) -> bool {
                *self == SELR::MAIN_CLOCK
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "USB PLL out"]
            USB_PLL_OUT,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::USB_PLL_OUT => 0,
                    SELW::MAIN_CLOCK => 1,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "USB PLL out"]
            #[inline]
            pub fn usb_pll_out(self) -> &'a mut W {
                self.variant(SELW::USB_PLL_OUT)
            }
            #[doc = "Main clock"]
            #[inline]
            pub fn main_clock(self) -> &'a mut W {
                self.variant(SELW::MAIN_CLOCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - USB clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - USB clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "USB clock source update enable"]
    pub struct USBCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB clock source update enable"]
    pub mod usbclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update\r\nclock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update\r\nclock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable USB clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable USB clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "USB clock source divider"]
    pub struct USBCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "USB clock source divider"]
    pub mod usbclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::USBCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - USB clock divider values. 0: Disable USB clock. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x01 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - USB clock divider values. 0: Disable USB clock. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "WDT clock source select"]
    pub struct WDTCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "WDT clock source select"]
    pub mod wdtclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::MAIN_CLOCK => 0x01,
                    SELR::WATCHDOG_OSCILLATOR => 0x02,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::MAIN_CLOCK,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `MAIN_CLOCK`"]
            #[inline]
            pub fn is_main_clock(&self) -> bool {
                *self == SELR::MAIN_CLOCK
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::MAIN_CLOCK => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                unsafe { self.bits(variant._bits()) }
            }
            #[doc = "IRC oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "Main clock"]
            #[inline]
            pub fn main_clock(self) -> &'a mut W {
                self.variant(SELW::MAIN_CLOCK)
            }
            #[doc = "Watchdog oscillator"]
            #[inline]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - WDT clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - WDT clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "WDT clock source update enable"]
    pub struct WDTCLKUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "WDT clock source update enable"]
    pub mod wdtclkuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTCLKUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable WDT clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable WDT clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "WDT clock divider"]
    pub struct WDTCLKDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "WDT clock divider"]
    pub mod wdtclkdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::WDTCLKDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - WDT clock divider values. 0: Disable WDCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - WDT clock divider values. 0: Disable WDCLK. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source select"]
    pub struct CLKOUTCLKSEL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source select"]
    pub mod clkoutclksel {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTCLKSEL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `SEL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SELR {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    SELR::IRC_OSCILLATOR => 0,
                    SELR::SYSTEM_OSCILLATOR => 0x01,
                    SELR::WATCHDOG_OSCILLATOR => 0x02,
                    SELR::MAIN_CLOCK => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> SELR {
                match value {
                    0 => SELR::IRC_OSCILLATOR,
                    1 => SELR::SYSTEM_OSCILLATOR,
                    2 => SELR::WATCHDOG_OSCILLATOR,
                    3 => SELR::MAIN_CLOCK,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `IRC_OSCILLATOR`"]
            #[inline]
            pub fn is_irc_oscillator(&self) -> bool {
                *self == SELR::IRC_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `SYSTEM_OSCILLATOR`"]
            #[inline]
            pub fn is_system_oscillator(&self) -> bool {
                *self == SELR::SYSTEM_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `WATCHDOG_OSCILLATOR`"]
            #[inline]
            pub fn is_watchdog_oscillator(&self) -> bool {
                *self == SELR::WATCHDOG_OSCILLATOR
            }
            #[doc = "Checks if the value of the field is `MAIN_CLOCK`"]
            #[inline]
            pub fn is_main_clock(&self) -> bool {
                *self == SELR::MAIN_CLOCK
            }
        }
        #[doc = "Values that can be written to the field `SEL`"]
        pub enum SELW {
            #[doc = "IRC oscillator"]
            IRC_OSCILLATOR,
            #[doc = "System oscillator"]
            SYSTEM_OSCILLATOR,
            #[doc = "Watchdog oscillator"]
            WATCHDOG_OSCILLATOR,
            #[doc = "Main clock"]
            MAIN_CLOCK,
        }
        impl SELW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    SELW::IRC_OSCILLATOR => 0,
                    SELW::SYSTEM_OSCILLATOR => 1,
                    SELW::WATCHDOG_OSCILLATOR => 2,
                    SELW::MAIN_CLOCK => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SELW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SELW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SELW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "IRC oscillator"]
            #[inline]
            pub fn irc_oscillator(self) -> &'a mut W {
                self.variant(SELW::IRC_OSCILLATOR)
            }
            #[doc = "System oscillator"]
            #[inline]
            pub fn system_oscillator(self) -> &'a mut W {
                self.variant(SELW::SYSTEM_OSCILLATOR)
            }
            #[doc = "Watchdog oscillator"]
            #[inline]
            pub fn watchdog_oscillator(self) -> &'a mut W {
                self.variant(SELW::WATCHDOG_OSCILLATOR)
            }
            #[doc = "Main clock"]
            #[inline]
            pub fn main_clock(self) -> &'a mut W {
                self.variant(SELW::MAIN_CLOCK)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline]
            pub fn sel(&self) -> SELR {
                SELR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - CLKOUT clock source"]
            #[inline]
            pub fn sel(&mut self) -> _SELW {
                _SELW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock source update enable"]
    pub struct CLKOUTUEN {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock source update enable"]
    pub mod clkoutuen {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTUEN {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `ENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENAR {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ENAR::NO_CHANGE => false,
                    ENAR::UPDATE_CLOCK_SOURCE => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ENAR {
                match value {
                    false => ENAR::NO_CHANGE,
                    true => ENAR::UPDATE_CLOCK_SOURCE,
                }
            }
            #[doc = "Checks if the value of the field is `NO_CHANGE`"]
            #[inline]
            pub fn is_no_change(&self) -> bool {
                *self == ENAR::NO_CHANGE
            }
            #[doc = "Checks if the value of the field is `UPDATE_CLOCK_SOURCE`"]
            #[inline]
            pub fn is_update_clock_source(&self) -> bool {
                *self == ENAR::UPDATE_CLOCK_SOURCE
            }
        }
        #[doc = "Values that can be written to the field `ENA`"]
        pub enum ENAW {
            #[doc = "No change"]
            NO_CHANGE,
            #[doc = "Update clock source"]
            UPDATE_CLOCK_SOURCE,
        }
        impl ENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ENAW::NO_CHANGE => false,
                    ENAW::UPDATE_CLOCK_SOURCE => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "No change"]
            #[inline]
            pub fn no_change(self) -> &'a mut W {
                self.variant(ENAW::NO_CHANGE)
            }
            #[doc = "Update clock source"]
            #[inline]
            pub fn update_clock_source(self) -> &'a mut W {
                self.variant(ENAW::UPDATE_CLOCK_SOURCE)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline]
            pub fn ena(&self) -> ENAR {
                ENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable CLKOUT clock source update"]
            #[inline]
            pub fn ena(&mut self) -> _ENAW {
                _ENAW { w: self }
            }
        }
    }
    #[doc = "CLKOUT clock divider"]
    pub struct CLKOUTDIV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "CLKOUT clock divider"]
    pub mod clkoutdiv {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::CLKOUTDIV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DIVR {
            bits: u8,
        }
        impl DIVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _DIVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _DIVW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0xff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:7 - Clock divider values. 0: Disable CLKOUT. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&self) -> DIVR {
                let bits = {
                    const MASK: u8 = 0xff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                DIVR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:7 - Clock divider values. 0: Disable CLKOUT. 1: Divide by 1. to 255: Divide by 255."]
            #[inline]
            pub fn div(&mut self) -> _DIVW {
                _DIVW { w: self }
            }
        }
    }
    #[doc = "POR captured PIO status 0"]
    pub struct PIOPORCAP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "POR captured PIO status 0"]
    pub mod pioporcap0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PIOPORCAP0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_0R {
            bits: bool,
        }
        impl CAPPIO0_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_1R {
            bits: bool,
        }
        impl CAPPIO0_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_2R {
            bits: bool,
        }
        impl CAPPIO0_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_3R {
            bits: bool,
        }
        impl CAPPIO0_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_4R {
            bits: bool,
        }
        impl CAPPIO0_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_5R {
            bits: bool,
        }
        impl CAPPIO0_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_6R {
            bits: bool,
        }
        impl CAPPIO0_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_7R {
            bits: bool,
        }
        impl CAPPIO0_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_8R {
            bits: bool,
        }
        impl CAPPIO0_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_9R {
            bits: bool,
        }
        impl CAPPIO0_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_10R {
            bits: bool,
        }
        impl CAPPIO0_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO0_11R {
            bits: bool,
        }
        impl CAPPIO0_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_0R {
            bits: bool,
        }
        impl CAPPIO1_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_1R {
            bits: bool,
        }
        impl CAPPIO1_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_2R {
            bits: bool,
        }
        impl CAPPIO1_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_3R {
            bits: bool,
        }
        impl CAPPIO1_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_4R {
            bits: bool,
        }
        impl CAPPIO1_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_5R {
            bits: bool,
        }
        impl CAPPIO1_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_6R {
            bits: bool,
        }
        impl CAPPIO1_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_7R {
            bits: bool,
        }
        impl CAPPIO1_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_8R {
            bits: bool,
        }
        impl CAPPIO1_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_9R {
            bits: bool,
        }
        impl CAPPIO1_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_10R {
            bits: bool,
        }
        impl CAPPIO1_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO1_11R {
            bits: bool,
        }
        impl CAPPIO1_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_0R {
            bits: bool,
        }
        impl CAPPIO2_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_1R {
            bits: bool,
        }
        impl CAPPIO2_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_2R {
            bits: bool,
        }
        impl CAPPIO2_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_3R {
            bits: bool,
        }
        impl CAPPIO2_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_4R {
            bits: bool,
        }
        impl CAPPIO2_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_5R {
            bits: bool,
        }
        impl CAPPIO2_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_6R {
            bits: bool,
        }
        impl CAPPIO2_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_7R {
            bits: bool,
        }
        impl CAPPIO2_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_0(&self) -> CAPPIO0_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_0R { bits }
            }
            #[doc = "Bit 1 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_1(&self) -> CAPPIO0_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_1R { bits }
            }
            #[doc = "Bit 2 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_2(&self) -> CAPPIO0_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_2R { bits }
            }
            #[doc = "Bit 3 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_3(&self) -> CAPPIO0_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_3R { bits }
            }
            #[doc = "Bit 4 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_4(&self) -> CAPPIO0_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_4R { bits }
            }
            #[doc = "Bit 5 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_5(&self) -> CAPPIO0_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_5R { bits }
            }
            #[doc = "Bit 6 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_6(&self) -> CAPPIO0_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_6R { bits }
            }
            #[doc = "Bit 7 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_7(&self) -> CAPPIO0_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_7R { bits }
            }
            #[doc = "Bit 8 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_8(&self) -> CAPPIO0_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_8R { bits }
            }
            #[doc = "Bit 9 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_9(&self) -> CAPPIO0_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_9R { bits }
            }
            #[doc = "Bit 10 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_10(&self) -> CAPPIO0_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_10R { bits }
            }
            #[doc = "Bit 11 - Raw reset status input PIO0_11 to PIO0_0"]
            #[inline]
            pub fn cappio0_11(&self) -> CAPPIO0_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO0_11R { bits }
            }
            #[doc = "Bit 12 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_0(&self) -> CAPPIO1_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_0R { bits }
            }
            #[doc = "Bit 13 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_1(&self) -> CAPPIO1_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_1R { bits }
            }
            #[doc = "Bit 14 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_2(&self) -> CAPPIO1_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_2R { bits }
            }
            #[doc = "Bit 15 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_3(&self) -> CAPPIO1_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_3R { bits }
            }
            #[doc = "Bit 16 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_4(&self) -> CAPPIO1_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_4R { bits }
            }
            #[doc = "Bit 17 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_5(&self) -> CAPPIO1_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_5R { bits }
            }
            #[doc = "Bit 18 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_6(&self) -> CAPPIO1_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_6R { bits }
            }
            #[doc = "Bit 19 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_7(&self) -> CAPPIO1_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_7R { bits }
            }
            #[doc = "Bit 20 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_8(&self) -> CAPPIO1_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_8R { bits }
            }
            #[doc = "Bit 21 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_9(&self) -> CAPPIO1_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_9R { bits }
            }
            #[doc = "Bit 22 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_10(&self) -> CAPPIO1_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_10R { bits }
            }
            #[doc = "Bit 23 - Raw reset status input PIO1_11 to PIO1_0"]
            #[inline]
            pub fn cappio1_11(&self) -> CAPPIO1_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO1_11R { bits }
            }
            #[doc = "Bit 24 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_0(&self) -> CAPPIO2_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_0R { bits }
            }
            #[doc = "Bit 25 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_1(&self) -> CAPPIO2_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_1R { bits }
            }
            #[doc = "Bit 26 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_2(&self) -> CAPPIO2_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_2R { bits }
            }
            #[doc = "Bit 27 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_3(&self) -> CAPPIO2_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_3R { bits }
            }
            #[doc = "Bit 28 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_4(&self) -> CAPPIO2_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_4R { bits }
            }
            #[doc = "Bit 29 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_5(&self) -> CAPPIO2_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_5R { bits }
            }
            #[doc = "Bit 30 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_6(&self) -> CAPPIO2_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_6R { bits }
            }
            #[doc = "Bit 31 - Raw reset status input PIO2_7 to PIO2_0"]
            #[inline]
            pub fn cappio2_7(&self) -> CAPPIO2_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_7R { bits }
            }
        }
    }
    #[doc = "POR captured PIO status 1"]
    pub struct PIOPORCAP1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "POR captured PIO status 1"]
    pub mod pioporcap1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::PIOPORCAP1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_8R {
            bits: bool,
        }
        impl CAPPIO2_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_9R {
            bits: bool,
        }
        impl CAPPIO2_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_10R {
            bits: bool,
        }
        impl CAPPIO2_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO2_11R {
            bits: bool,
        }
        impl CAPPIO2_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_0R {
            bits: bool,
        }
        impl CAPPIO3_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_1R {
            bits: bool,
        }
        impl CAPPIO3_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_2R {
            bits: bool,
        }
        impl CAPPIO3_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_3R {
            bits: bool,
        }
        impl CAPPIO3_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_4R {
            bits: bool,
        }
        impl CAPPIO3_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct CAPPIO3_5R {
            bits: bool,
        }
        impl CAPPIO3_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Raw reset status input PIO2_8"]
            #[inline]
            pub fn cappio2_8(&self) -> CAPPIO2_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_8R { bits }
            }
            #[doc = "Bit 1 - Raw reset status input PIO2_9"]
            #[inline]
            pub fn cappio2_9(&self) -> CAPPIO2_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_9R { bits }
            }
            #[doc = "Bit 2 - Raw reset status input PIO2_10"]
            #[inline]
            pub fn cappio2_10(&self) -> CAPPIO2_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_10R { bits }
            }
            #[doc = "Bit 3 - Raw reset status input PIO2_11"]
            #[inline]
            pub fn cappio2_11(&self) -> CAPPIO2_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO2_11R { bits }
            }
            #[doc = "Bit 4 - Raw reset status input PIO3_0"]
            #[inline]
            pub fn cappio3_0(&self) -> CAPPIO3_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_0R { bits }
            }
            #[doc = "Bit 5 - Raw reset status input PIO3_1"]
            #[inline]
            pub fn cappio3_1(&self) -> CAPPIO3_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_1R { bits }
            }
            #[doc = "Bit 6 - Raw reset status input PIO3_2"]
            #[inline]
            pub fn cappio3_2(&self) -> CAPPIO3_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_2R { bits }
            }
            #[doc = "Bit 7 - Raw reset status input PIO3_3"]
            #[inline]
            pub fn cappio3_3(&self) -> CAPPIO3_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_3R { bits }
            }
            #[doc = "Bit 8 - Raw reset status input PIO3_4"]
            #[inline]
            pub fn cappio3_4(&self) -> CAPPIO3_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_4R { bits }
            }
            #[doc = "Bit 9 - Raw reset status input PIO3_5"]
            #[inline]
            pub fn cappio3_5(&self) -> CAPPIO3_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                CAPPIO3_5R { bits }
            }
        }
    }
    #[doc = "BOD control"]
    pub struct BODCTRL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "BOD control"]
    pub mod bodctrl {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::BODCTRL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `BODRSTLEV`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTLEVR {
            #[doc = "The reset assertion threshold voltage is 1.49 V/1.46 V; the reset de-assertion threshold voltage is 1.64 V/1.63 V."]
            THE_RESET_ASSERTION_1,
            #[doc = "The reset assertion threshold voltage is -/2.06 V; the reset de-assertion threshold voltage is -/2.15 V."]
            THE_RESET_ASSERTION_2,
            #[doc = "The reset assertion threshold voltage is -/2.35 V; the reset de-assertion threshold voltage is -/2.43 V."]
            THE_RESET_ASSERTION_3,
            #[doc = "The reset assertion threshold voltage is -/2.63 V; the reset de-assertion threshold voltage is -/2.71 V."]
            THE_RESET_ASSERTION_4,
        }
        impl BODRSTLEVR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODRSTLEVR::THE_RESET_ASSERTION_1 => 0,
                    BODRSTLEVR::THE_RESET_ASSERTION_2 => 0x01,
                    BODRSTLEVR::THE_RESET_ASSERTION_3 => 0x02,
                    BODRSTLEVR::THE_RESET_ASSERTION_4 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BODRSTLEVR {
                match value {
                    0 => BODRSTLEVR::THE_RESET_ASSERTION_1,
                    1 => BODRSTLEVR::THE_RESET_ASSERTION_2,
                    2 => BODRSTLEVR::THE_RESET_ASSERTION_3,
                    3 => BODRSTLEVR::THE_RESET_ASSERTION_4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `THE_RESET_ASSERTION_1`"]
            #[inline]
            pub fn is_the_reset_assertion_1(&self) -> bool {
                *self == BODRSTLEVR::THE_RESET_ASSERTION_1
            }
            #[doc = "Checks if the value of the field is `THE_RESET_ASSERTION_2`"]
            #[inline]
            pub fn is_the_reset_assertion_2(&self) -> bool {
                *self == BODRSTLEVR::THE_RESET_ASSERTION_2
            }
            #[doc = "Checks if the value of the field is `THE_RESET_ASSERTION_3`"]
            #[inline]
            pub fn is_the_reset_assertion_3(&self) -> bool {
                *self == BODRSTLEVR::THE_RESET_ASSERTION_3
            }
            #[doc = "Checks if the value of the field is `THE_RESET_ASSERTION_4`"]
            #[inline]
            pub fn is_the_reset_assertion_4(&self) -> bool {
                *self == BODRSTLEVR::THE_RESET_ASSERTION_4
            }
        }
        #[doc = "Possible values of the field `BODINTVAL`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODINTVALR {
            #[doc = "The interrupt assertion threshold voltage is 1.69 V/1.65 V; the interrupt de-assertion threshold voltage is 1.84 V/1.8 V."]
            THE_INTERRUPT_ASSERT_1,
            #[doc = "The interrupt assertion threshold voltage is 2.29 V/2.22 V; the interrupt de-assertion threshold voltage is 2.44 V/2.35 V."]
            THE_INTERRUPT_ASSERT_2,
            #[doc = "The interrupt assertion threshold voltage is 2.59 V/ 2.52 V; the interrupt de-assertion threshold voltage is 2.74 V/2.66 V."]
            THE_INTERRUPT_ASSERT_3,
            #[doc = "The interrupt assertion threshold voltage is 2.87 V/2.80 V; the interrupt de-assertion threshold voltage is 2.98 V/2.90 V."]
            THE_INTERRUPT_ASSERT_4,
        }
        impl BODINTVALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                match *self {
                    BODINTVALR::THE_INTERRUPT_ASSERT_1 => 0,
                    BODINTVALR::THE_INTERRUPT_ASSERT_2 => 0x01,
                    BODINTVALR::THE_INTERRUPT_ASSERT_3 => 0x02,
                    BODINTVALR::THE_INTERRUPT_ASSERT_4 => 0x03,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: u8) -> BODINTVALR {
                match value {
                    0 => BODINTVALR::THE_INTERRUPT_ASSERT_1,
                    1 => BODINTVALR::THE_INTERRUPT_ASSERT_2,
                    2 => BODINTVALR::THE_INTERRUPT_ASSERT_3,
                    3 => BODINTVALR::THE_INTERRUPT_ASSERT_4,
                    _ => unreachable!(),
                }
            }
            #[doc = "Checks if the value of the field is `THE_INTERRUPT_ASSERT_1`"]
            #[inline]
            pub fn is_the_interrupt_assert_1(&self) -> bool {
                *self == BODINTVALR::THE_INTERRUPT_ASSERT_1
            }
            #[doc = "Checks if the value of the field is `THE_INTERRUPT_ASSERT_2`"]
            #[inline]
            pub fn is_the_interrupt_assert_2(&self) -> bool {
                *self == BODINTVALR::THE_INTERRUPT_ASSERT_2
            }
            #[doc = "Checks if the value of the field is `THE_INTERRUPT_ASSERT_3`"]
            #[inline]
            pub fn is_the_interrupt_assert_3(&self) -> bool {
                *self == BODINTVALR::THE_INTERRUPT_ASSERT_3
            }
            #[doc = "Checks if the value of the field is `THE_INTERRUPT_ASSERT_4`"]
            #[inline]
            pub fn is_the_interrupt_assert_4(&self) -> bool {
                *self == BODINTVALR::THE_INTERRUPT_ASSERT_4
            }
        }
        #[doc = "Possible values of the field `BODRSTENA`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BODRSTENAR {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BODRSTENAR::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAR::ENABLE_RESET_FUNCTIO => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BODRSTENAR {
                match value {
                    false => BODRSTENAR::DISABLE_RESET_FUNCTI,
                    true => BODRSTENAR::ENABLE_RESET_FUNCTIO,
                }
            }
            #[doc = "Checks if the value of the field is `DISABLE_RESET_FUNCTI`"]
            #[inline]
            pub fn is_disable_reset_functi(&self) -> bool {
                *self == BODRSTENAR::DISABLE_RESET_FUNCTI
            }
            #[doc = "Checks if the value of the field is `ENABLE_RESET_FUNCTIO`"]
            #[inline]
            pub fn is_enable_reset_functio(&self) -> bool {
                *self == BODRSTENAR::ENABLE_RESET_FUNCTIO
            }
        }
        #[doc = "Values that can be written to the field `BODRSTLEV`"]
        pub enum BODRSTLEVW {
            #[doc = "The reset assertion threshold voltage is 1.49 V/1.46 V; the reset de-assertion threshold voltage is 1.64 V/1.63 V."]
            THE_RESET_ASSERTION_1,
            #[doc = "The reset assertion threshold voltage is -/2.06 V; the reset de-assertion threshold voltage is -/2.15 V."]
            THE_RESET_ASSERTION_2,
            #[doc = "The reset assertion threshold voltage is -/2.35 V; the reset de-assertion threshold voltage is -/2.43 V."]
            THE_RESET_ASSERTION_3,
            #[doc = "The reset assertion threshold voltage is -/2.63 V; the reset de-assertion threshold voltage is -/2.71 V."]
            THE_RESET_ASSERTION_4,
        }
        impl BODRSTLEVW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODRSTLEVW::THE_RESET_ASSERTION_1 => 0,
                    BODRSTLEVW::THE_RESET_ASSERTION_2 => 1,
                    BODRSTLEVW::THE_RESET_ASSERTION_3 => 2,
                    BODRSTLEVW::THE_RESET_ASSERTION_4 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTLEVW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTLEVW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODRSTLEVW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "The reset assertion threshold voltage is 1.49 V/1.46 V; the reset de-assertion threshold voltage is 1.64 V/1.63 V."]
            #[inline]
            pub fn the_reset_assertion_1(self) -> &'a mut W {
                self.variant(BODRSTLEVW::THE_RESET_ASSERTION_1)
            }
            #[doc = "The reset assertion threshold voltage is -/2.06 V; the reset de-assertion threshold voltage is -/2.15 V."]
            #[inline]
            pub fn the_reset_assertion_2(self) -> &'a mut W {
                self.variant(BODRSTLEVW::THE_RESET_ASSERTION_2)
            }
            #[doc = "The reset assertion threshold voltage is -/2.35 V; the reset de-assertion threshold voltage is -/2.43 V."]
            #[inline]
            pub fn the_reset_assertion_3(self) -> &'a mut W {
                self.variant(BODRSTLEVW::THE_RESET_ASSERTION_3)
            }
            #[doc = "The reset assertion threshold voltage is -/2.63 V; the reset de-assertion threshold voltage is -/2.71 V."]
            #[inline]
            pub fn the_reset_assertion_4(self) -> &'a mut W {
                self.variant(BODRSTLEVW::THE_RESET_ASSERTION_4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODINTVAL`"]
        pub enum BODINTVALW {
            #[doc = "The interrupt assertion threshold voltage is 1.69 V/1.65 V; the interrupt de-assertion threshold voltage is 1.84 V/1.8 V."]
            THE_INTERRUPT_ASSERT_1,
            #[doc = "The interrupt assertion threshold voltage is 2.29 V/2.22 V; the interrupt de-assertion threshold voltage is 2.44 V/2.35 V."]
            THE_INTERRUPT_ASSERT_2,
            #[doc = "The interrupt assertion threshold voltage is 2.59 V/ 2.52 V; the interrupt de-assertion threshold voltage is 2.74 V/2.66 V."]
            THE_INTERRUPT_ASSERT_3,
            #[doc = "The interrupt assertion threshold voltage is 2.87 V/2.80 V; the interrupt de-assertion threshold voltage is 2.98 V/2.90 V."]
            THE_INTERRUPT_ASSERT_4,
        }
        impl BODINTVALW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> u8 {
                match *self {
                    BODINTVALW::THE_INTERRUPT_ASSERT_1 => 0,
                    BODINTVALW::THE_INTERRUPT_ASSERT_2 => 1,
                    BODINTVALW::THE_INTERRUPT_ASSERT_3 => 2,
                    BODINTVALW::THE_INTERRUPT_ASSERT_4 => 3,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODINTVALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODINTVALW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODINTVALW) -> &'a mut W {
                {
                    self.bits(variant._bits())
                }
            }
            #[doc = "The interrupt assertion threshold voltage is 1.69 V/1.65 V; the interrupt de-assertion threshold voltage is 1.84 V/1.8 V."]
            #[inline]
            pub fn the_interrupt_assert_1(self) -> &'a mut W {
                self.variant(BODINTVALW::THE_INTERRUPT_ASSERT_1)
            }
            #[doc = "The interrupt assertion threshold voltage is 2.29 V/2.22 V; the interrupt de-assertion threshold voltage is 2.44 V/2.35 V."]
            #[inline]
            pub fn the_interrupt_assert_2(self) -> &'a mut W {
                self.variant(BODINTVALW::THE_INTERRUPT_ASSERT_2)
            }
            #[doc = "The interrupt assertion threshold voltage is 2.59 V/ 2.52 V; the interrupt de-assertion threshold voltage is 2.74 V/2.66 V."]
            #[inline]
            pub fn the_interrupt_assert_3(self) -> &'a mut W {
                self.variant(BODINTVALW::THE_INTERRUPT_ASSERT_3)
            }
            #[doc = "The interrupt assertion threshold voltage is 2.87 V/2.80 V; the interrupt de-assertion threshold voltage is 2.98 V/2.90 V."]
            #[inline]
            pub fn the_interrupt_assert_4(self) -> &'a mut W {
                self.variant(BODINTVALW::THE_INTERRUPT_ASSERT_4)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BODRSTENA`"]
        pub enum BODRSTENAW {
            #[doc = "Disable reset function."]
            DISABLE_RESET_FUNCTI,
            #[doc = "Enable reset function."]
            ENABLE_RESET_FUNCTIO,
        }
        impl BODRSTENAW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BODRSTENAW::DISABLE_RESET_FUNCTI => false,
                    BODRSTENAW::ENABLE_RESET_FUNCTIO => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BODRSTENAW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BODRSTENAW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BODRSTENAW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Disable reset function."]
            #[inline]
            pub fn disable_reset_functi(self) -> &'a mut W {
                self.variant(BODRSTENAW::DISABLE_RESET_FUNCTI)
            }
            #[doc = "Enable reset function."]
            #[inline]
            pub fn enable_reset_functio(self) -> &'a mut W {
                self.variant(BODRSTENAW::ENABLE_RESET_FUNCTIO)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:1 - BOD reset level. Trip values x/y refer to the LPC1300/LPC1300L series."]
            #[inline]
            pub fn bodrstlev(&self) -> BODRSTLEVR {
                BODRSTLEVR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bits 2:3 - BOD interrupt level. Trip values x/y refer to the LPC1300/LPC1300L series."]
            #[inline]
            pub fn bodintval(&self) -> BODINTVALR {
                BODINTVALR::_from({
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                })
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline]
            pub fn bodrstena(&self) -> BODRSTENAR {
                BODRSTENAR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:1 - BOD reset level. Trip values x/y refer to the LPC1300/LPC1300L series."]
            #[inline]
            pub fn bodrstlev(&mut self) -> _BODRSTLEVW {
                _BODRSTLEVW { w: self }
            }
            #[doc = "Bits 2:3 - BOD interrupt level. Trip values x/y refer to the LPC1300/LPC1300L series."]
            #[inline]
            pub fn bodintval(&mut self) -> _BODINTVALW {
                _BODINTVALW { w: self }
            }
            #[doc = "Bit 4 - BOD reset enable"]
            #[inline]
            pub fn bodrstena(&mut self) -> _BODRSTENAW {
                _BODRSTENAW { w: self }
            }
        }
    }
    #[doc = "System tick counter calibration"]
    pub struct SYSTCKCAL {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "System tick counter calibration"]
    pub mod systckcal {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::SYSTCKCAL {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct CALR {
            bits: u32,
        }
        impl CALR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _CALW<'a> {
            w: &'a mut W,
        }
        impl<'a> _CALW<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                const MASK: u32 = 0x03ff_ffff;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline]
            pub fn cal(&self) -> CALR {
                let bits = {
                    const MASK: u32 = 0x03ff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                CALR { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0x04 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:25 - System tick timer calibration value"]
            #[inline]
            pub fn cal(&mut self) -> _CALW {
                _CALW { w: self }
            }
        }
    }
    #[doc = "Start logic edge control register 0; bottom 32 interrupts"]
    pub struct STARTAPRP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic edge control register 0; bottom 32 interrupts"]
    pub mod startaprp0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTAPRP0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_0R {
            bits: bool,
        }
        impl APRPIO0_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_1R {
            bits: bool,
        }
        impl APRPIO0_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_2R {
            bits: bool,
        }
        impl APRPIO0_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_3R {
            bits: bool,
        }
        impl APRPIO0_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_4R {
            bits: bool,
        }
        impl APRPIO0_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_5R {
            bits: bool,
        }
        impl APRPIO0_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_6R {
            bits: bool,
        }
        impl APRPIO0_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_7R {
            bits: bool,
        }
        impl APRPIO0_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_8R {
            bits: bool,
        }
        impl APRPIO0_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_9R {
            bits: bool,
        }
        impl APRPIO0_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_10R {
            bits: bool,
        }
        impl APRPIO0_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO0_11R {
            bits: bool,
        }
        impl APRPIO0_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_0R {
            bits: bool,
        }
        impl APRPIO1_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_1R {
            bits: bool,
        }
        impl APRPIO1_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_2R {
            bits: bool,
        }
        impl APRPIO1_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_3R {
            bits: bool,
        }
        impl APRPIO1_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_4R {
            bits: bool,
        }
        impl APRPIO1_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_5R {
            bits: bool,
        }
        impl APRPIO1_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_6R {
            bits: bool,
        }
        impl APRPIO1_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_7R {
            bits: bool,
        }
        impl APRPIO1_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_8R {
            bits: bool,
        }
        impl APRPIO1_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_9R {
            bits: bool,
        }
        impl APRPIO1_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_10R {
            bits: bool,
        }
        impl APRPIO1_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO1_11R {
            bits: bool,
        }
        impl APRPIO1_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_0R {
            bits: bool,
        }
        impl APRPIO2_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_1R {
            bits: bool,
        }
        impl APRPIO2_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_2R {
            bits: bool,
        }
        impl APRPIO2_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_3R {
            bits: bool,
        }
        impl APRPIO2_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_4R {
            bits: bool,
        }
        impl APRPIO2_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_5R {
            bits: bool,
        }
        impl APRPIO2_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_6R {
            bits: bool,
        }
        impl APRPIO2_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_7R {
            bits: bool,
        }
        impl APRPIO2_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO0_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO0_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO1_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO1_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_0(&self) -> APRPIO0_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_0R { bits }
            }
            #[doc = "Bit 1 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_1(&self) -> APRPIO0_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_1R { bits }
            }
            #[doc = "Bit 2 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_2(&self) -> APRPIO0_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_2R { bits }
            }
            #[doc = "Bit 3 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_3(&self) -> APRPIO0_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_3R { bits }
            }
            #[doc = "Bit 4 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_4(&self) -> APRPIO0_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_4R { bits }
            }
            #[doc = "Bit 5 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_5(&self) -> APRPIO0_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_5R { bits }
            }
            #[doc = "Bit 6 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_6(&self) -> APRPIO0_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_6R { bits }
            }
            #[doc = "Bit 7 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_7(&self) -> APRPIO0_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_7R { bits }
            }
            #[doc = "Bit 8 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_8(&self) -> APRPIO0_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_8R { bits }
            }
            #[doc = "Bit 9 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_9(&self) -> APRPIO0_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_9R { bits }
            }
            #[doc = "Bit 10 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_10(&self) -> APRPIO0_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_10R { bits }
            }
            #[doc = "Bit 11 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_11(&self) -> APRPIO0_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO0_11R { bits }
            }
            #[doc = "Bit 12 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_0(&self) -> APRPIO1_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_0R { bits }
            }
            #[doc = "Bit 13 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_1(&self) -> APRPIO1_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_1R { bits }
            }
            #[doc = "Bit 14 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_2(&self) -> APRPIO1_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_2R { bits }
            }
            #[doc = "Bit 15 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_3(&self) -> APRPIO1_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_3R { bits }
            }
            #[doc = "Bit 16 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_4(&self) -> APRPIO1_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_4R { bits }
            }
            #[doc = "Bit 17 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_5(&self) -> APRPIO1_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_5R { bits }
            }
            #[doc = "Bit 18 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_6(&self) -> APRPIO1_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_6R { bits }
            }
            #[doc = "Bit 19 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_7(&self) -> APRPIO1_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_7R { bits }
            }
            #[doc = "Bit 20 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_8(&self) -> APRPIO1_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_8R { bits }
            }
            #[doc = "Bit 21 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_9(&self) -> APRPIO1_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_9R { bits }
            }
            #[doc = "Bit 22 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_10(&self) -> APRPIO1_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_10R { bits }
            }
            #[doc = "Bit 23 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_11(&self) -> APRPIO1_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO1_11R { bits }
            }
            #[doc = "Bit 24 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_0(&self) -> APRPIO2_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_0R { bits }
            }
            #[doc = "Bit 25 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_1(&self) -> APRPIO2_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_1R { bits }
            }
            #[doc = "Bit 26 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_2(&self) -> APRPIO2_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_2R { bits }
            }
            #[doc = "Bit 27 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_3(&self) -> APRPIO2_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_3R { bits }
            }
            #[doc = "Bit 28 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_4(&self) -> APRPIO2_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_4R { bits }
            }
            #[doc = "Bit 29 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_5(&self) -> APRPIO2_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_5R { bits }
            }
            #[doc = "Bit 30 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_6(&self) -> APRPIO2_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_6R { bits }
            }
            #[doc = "Bit 31 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_7(&self) -> APRPIO2_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_0(&mut self) -> _APRPIO0_0W {
                _APRPIO0_0W { w: self }
            }
            #[doc = "Bit 1 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_1(&mut self) -> _APRPIO0_1W {
                _APRPIO0_1W { w: self }
            }
            #[doc = "Bit 2 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_2(&mut self) -> _APRPIO0_2W {
                _APRPIO0_2W { w: self }
            }
            #[doc = "Bit 3 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_3(&mut self) -> _APRPIO0_3W {
                _APRPIO0_3W { w: self }
            }
            #[doc = "Bit 4 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_4(&mut self) -> _APRPIO0_4W {
                _APRPIO0_4W { w: self }
            }
            #[doc = "Bit 5 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_5(&mut self) -> _APRPIO0_5W {
                _APRPIO0_5W { w: self }
            }
            #[doc = "Bit 6 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_6(&mut self) -> _APRPIO0_6W {
                _APRPIO0_6W { w: self }
            }
            #[doc = "Bit 7 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_7(&mut self) -> _APRPIO0_7W {
                _APRPIO0_7W { w: self }
            }
            #[doc = "Bit 8 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_8(&mut self) -> _APRPIO0_8W {
                _APRPIO0_8W { w: self }
            }
            #[doc = "Bit 9 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_9(&mut self) -> _APRPIO0_9W {
                _APRPIO0_9W { w: self }
            }
            #[doc = "Bit 10 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_10(&mut self) -> _APRPIO0_10W {
                _APRPIO0_10W { w: self }
            }
            #[doc = "Bit 11 - Edge select for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio0_11(&mut self) -> _APRPIO0_11W {
                _APRPIO0_11W { w: self }
            }
            #[doc = "Bit 12 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_0(&mut self) -> _APRPIO1_0W {
                _APRPIO1_0W { w: self }
            }
            #[doc = "Bit 13 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_1(&mut self) -> _APRPIO1_1W {
                _APRPIO1_1W { w: self }
            }
            #[doc = "Bit 14 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_2(&mut self) -> _APRPIO1_2W {
                _APRPIO1_2W { w: self }
            }
            #[doc = "Bit 15 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_3(&mut self) -> _APRPIO1_3W {
                _APRPIO1_3W { w: self }
            }
            #[doc = "Bit 16 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_4(&mut self) -> _APRPIO1_4W {
                _APRPIO1_4W { w: self }
            }
            #[doc = "Bit 17 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_5(&mut self) -> _APRPIO1_5W {
                _APRPIO1_5W { w: self }
            }
            #[doc = "Bit 18 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_6(&mut self) -> _APRPIO1_6W {
                _APRPIO1_6W { w: self }
            }
            #[doc = "Bit 19 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_7(&mut self) -> _APRPIO1_7W {
                _APRPIO1_7W { w: self }
            }
            #[doc = "Bit 20 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_8(&mut self) -> _APRPIO1_8W {
                _APRPIO1_8W { w: self }
            }
            #[doc = "Bit 21 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_9(&mut self) -> _APRPIO1_9W {
                _APRPIO1_9W { w: self }
            }
            #[doc = "Bit 22 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_10(&mut self) -> _APRPIO1_10W {
                _APRPIO1_10W { w: self }
            }
            #[doc = "Bit 23 - Edge select for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio1_11(&mut self) -> _APRPIO1_11W {
                _APRPIO1_11W { w: self }
            }
            #[doc = "Bit 24 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_0(&mut self) -> _APRPIO2_0W {
                _APRPIO2_0W { w: self }
            }
            #[doc = "Bit 25 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_1(&mut self) -> _APRPIO2_1W {
                _APRPIO2_1W { w: self }
            }
            #[doc = "Bit 26 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_2(&mut self) -> _APRPIO2_2W {
                _APRPIO2_2W { w: self }
            }
            #[doc = "Bit 27 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_3(&mut self) -> _APRPIO2_3W {
                _APRPIO2_3W { w: self }
            }
            #[doc = "Bit 28 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_4(&mut self) -> _APRPIO2_4W {
                _APRPIO2_4W { w: self }
            }
            #[doc = "Bit 29 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_5(&mut self) -> _APRPIO2_5W {
                _APRPIO2_5W { w: self }
            }
            #[doc = "Bit 30 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_6(&mut self) -> _APRPIO2_6W {
                _APRPIO2_6W { w: self }
            }
            #[doc = "Bit 31 - Edge select for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_7(&mut self) -> _APRPIO2_7W {
                _APRPIO2_7W { w: self }
            }
        }
    }
    #[doc = "Start logic signal enable register 0; bottom 32 interrupts"]
    pub struct STARTERP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic signal enable register 0; bottom 32 interrupts"]
    pub mod starterp0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP0 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_0R {
            bits: bool,
        }
        impl ERPIO0_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_1R {
            bits: bool,
        }
        impl ERPIO0_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_2R {
            bits: bool,
        }
        impl ERPIO0_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_3R {
            bits: bool,
        }
        impl ERPIO0_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_4R {
            bits: bool,
        }
        impl ERPIO0_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_5R {
            bits: bool,
        }
        impl ERPIO0_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_6R {
            bits: bool,
        }
        impl ERPIO0_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_7R {
            bits: bool,
        }
        impl ERPIO0_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_8R {
            bits: bool,
        }
        impl ERPIO0_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_9R {
            bits: bool,
        }
        impl ERPIO0_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_10R {
            bits: bool,
        }
        impl ERPIO0_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO0_11R {
            bits: bool,
        }
        impl ERPIO0_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_0R {
            bits: bool,
        }
        impl ERPIO1_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_1R {
            bits: bool,
        }
        impl ERPIO1_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_2R {
            bits: bool,
        }
        impl ERPIO1_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_3R {
            bits: bool,
        }
        impl ERPIO1_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_4R {
            bits: bool,
        }
        impl ERPIO1_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_5R {
            bits: bool,
        }
        impl ERPIO1_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_6R {
            bits: bool,
        }
        impl ERPIO1_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_7R {
            bits: bool,
        }
        impl ERPIO1_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_8R {
            bits: bool,
        }
        impl ERPIO1_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_9R {
            bits: bool,
        }
        impl ERPIO1_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_10R {
            bits: bool,
        }
        impl ERPIO1_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO1_11R {
            bits: bool,
        }
        impl ERPIO1_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_0R {
            bits: bool,
        }
        impl ERPIO2_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_1R {
            bits: bool,
        }
        impl ERPIO2_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_2R {
            bits: bool,
        }
        impl ERPIO2_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_3R {
            bits: bool,
        }
        impl ERPIO2_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_4R {
            bits: bool,
        }
        impl ERPIO2_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_5R {
            bits: bool,
        }
        impl ERPIO2_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_6R {
            bits: bool,
        }
        impl ERPIO2_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_7R {
            bits: bool,
        }
        impl ERPIO2_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO0_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO0_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO1_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO1_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_0(&self) -> ERPIO0_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_0R { bits }
            }
            #[doc = "Bit 1 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_1(&self) -> ERPIO0_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_1R { bits }
            }
            #[doc = "Bit 2 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_2(&self) -> ERPIO0_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_2R { bits }
            }
            #[doc = "Bit 3 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_3(&self) -> ERPIO0_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_3R { bits }
            }
            #[doc = "Bit 4 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_4(&self) -> ERPIO0_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_4R { bits }
            }
            #[doc = "Bit 5 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_5(&self) -> ERPIO0_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_5R { bits }
            }
            #[doc = "Bit 6 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_6(&self) -> ERPIO0_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_6R { bits }
            }
            #[doc = "Bit 7 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_7(&self) -> ERPIO0_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_7R { bits }
            }
            #[doc = "Bit 8 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_8(&self) -> ERPIO0_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_8R { bits }
            }
            #[doc = "Bit 9 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_9(&self) -> ERPIO0_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_9R { bits }
            }
            #[doc = "Bit 10 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_10(&self) -> ERPIO0_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_10R { bits }
            }
            #[doc = "Bit 11 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_11(&self) -> ERPIO0_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO0_11R { bits }
            }
            #[doc = "Bit 12 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_0(&self) -> ERPIO1_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_0R { bits }
            }
            #[doc = "Bit 13 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_1(&self) -> ERPIO1_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_1R { bits }
            }
            #[doc = "Bit 14 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_2(&self) -> ERPIO1_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_2R { bits }
            }
            #[doc = "Bit 15 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_3(&self) -> ERPIO1_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_3R { bits }
            }
            #[doc = "Bit 16 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_4(&self) -> ERPIO1_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_4R { bits }
            }
            #[doc = "Bit 17 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_5(&self) -> ERPIO1_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_5R { bits }
            }
            #[doc = "Bit 18 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_6(&self) -> ERPIO1_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_6R { bits }
            }
            #[doc = "Bit 19 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_7(&self) -> ERPIO1_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_7R { bits }
            }
            #[doc = "Bit 20 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_8(&self) -> ERPIO1_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_8R { bits }
            }
            #[doc = "Bit 21 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_9(&self) -> ERPIO1_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_9R { bits }
            }
            #[doc = "Bit 22 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_10(&self) -> ERPIO1_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_10R { bits }
            }
            #[doc = "Bit 23 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_11(&self) -> ERPIO1_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO1_11R { bits }
            }
            #[doc = "Bit 24 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_0(&self) -> ERPIO2_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_0R { bits }
            }
            #[doc = "Bit 25 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_1(&self) -> ERPIO2_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_1R { bits }
            }
            #[doc = "Bit 26 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_2(&self) -> ERPIO2_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_2R { bits }
            }
            #[doc = "Bit 27 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_3(&self) -> ERPIO2_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_3R { bits }
            }
            #[doc = "Bit 28 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_4(&self) -> ERPIO2_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_4R { bits }
            }
            #[doc = "Bit 29 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_5(&self) -> ERPIO2_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_5R { bits }
            }
            #[doc = "Bit 30 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_6(&self) -> ERPIO2_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_6R { bits }
            }
            #[doc = "Bit 31 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_7(&self) -> ERPIO2_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_7R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_0(&mut self) -> _ERPIO0_0W {
                _ERPIO0_0W { w: self }
            }
            #[doc = "Bit 1 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_1(&mut self) -> _ERPIO0_1W {
                _ERPIO0_1W { w: self }
            }
            #[doc = "Bit 2 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_2(&mut self) -> _ERPIO0_2W {
                _ERPIO0_2W { w: self }
            }
            #[doc = "Bit 3 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_3(&mut self) -> _ERPIO0_3W {
                _ERPIO0_3W { w: self }
            }
            #[doc = "Bit 4 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_4(&mut self) -> _ERPIO0_4W {
                _ERPIO0_4W { w: self }
            }
            #[doc = "Bit 5 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_5(&mut self) -> _ERPIO0_5W {
                _ERPIO0_5W { w: self }
            }
            #[doc = "Bit 6 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_6(&mut self) -> _ERPIO0_6W {
                _ERPIO0_6W { w: self }
            }
            #[doc = "Bit 7 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_7(&mut self) -> _ERPIO0_7W {
                _ERPIO0_7W { w: self }
            }
            #[doc = "Bit 8 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_8(&mut self) -> _ERPIO0_8W {
                _ERPIO0_8W { w: self }
            }
            #[doc = "Bit 9 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_9(&mut self) -> _ERPIO0_9W {
                _ERPIO0_9W { w: self }
            }
            #[doc = "Bit 10 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_10(&mut self) -> _ERPIO0_10W {
                _ERPIO0_10W { w: self }
            }
            #[doc = "Bit 11 - Enable start signal for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio0_11(&mut self) -> _ERPIO0_11W {
                _ERPIO0_11W { w: self }
            }
            #[doc = "Bit 12 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_0(&mut self) -> _ERPIO1_0W {
                _ERPIO1_0W { w: self }
            }
            #[doc = "Bit 13 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_1(&mut self) -> _ERPIO1_1W {
                _ERPIO1_1W { w: self }
            }
            #[doc = "Bit 14 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_2(&mut self) -> _ERPIO1_2W {
                _ERPIO1_2W { w: self }
            }
            #[doc = "Bit 15 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_3(&mut self) -> _ERPIO1_3W {
                _ERPIO1_3W { w: self }
            }
            #[doc = "Bit 16 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_4(&mut self) -> _ERPIO1_4W {
                _ERPIO1_4W { w: self }
            }
            #[doc = "Bit 17 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_5(&mut self) -> _ERPIO1_5W {
                _ERPIO1_5W { w: self }
            }
            #[doc = "Bit 18 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_6(&mut self) -> _ERPIO1_6W {
                _ERPIO1_6W { w: self }
            }
            #[doc = "Bit 19 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_7(&mut self) -> _ERPIO1_7W {
                _ERPIO1_7W { w: self }
            }
            #[doc = "Bit 20 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_8(&mut self) -> _ERPIO1_8W {
                _ERPIO1_8W { w: self }
            }
            #[doc = "Bit 21 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_9(&mut self) -> _ERPIO1_9W {
                _ERPIO1_9W { w: self }
            }
            #[doc = "Bit 22 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_10(&mut self) -> _ERPIO1_10W {
                _ERPIO1_10W { w: self }
            }
            #[doc = "Bit 23 - Enable start signal for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio1_11(&mut self) -> _ERPIO1_11W {
                _ERPIO1_11W { w: self }
            }
            #[doc = "Bit 24 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_0(&mut self) -> _ERPIO2_0W {
                _ERPIO2_0W { w: self }
            }
            #[doc = "Bit 25 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_1(&mut self) -> _ERPIO2_1W {
                _ERPIO2_1W { w: self }
            }
            #[doc = "Bit 26 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_2(&mut self) -> _ERPIO2_2W {
                _ERPIO2_2W { w: self }
            }
            #[doc = "Bit 27 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_3(&mut self) -> _ERPIO2_3W {
                _ERPIO2_3W { w: self }
            }
            #[doc = "Bit 28 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_4(&mut self) -> _ERPIO2_4W {
                _ERPIO2_4W { w: self }
            }
            #[doc = "Bit 29 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_5(&mut self) -> _ERPIO2_5W {
                _ERPIO2_5W { w: self }
            }
            #[doc = "Bit 30 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_6(&mut self) -> _ERPIO2_6W {
                _ERPIO2_6W { w: self }
            }
            #[doc = "Bit 31 - Enable start signal for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_7(&mut self) -> _ERPIO2_7W {
                _ERPIO2_7W { w: self }
            }
        }
    }
    #[doc = "Start logic reset register 0; bottom 32 interrupts"]
    pub struct STARTRSRP0CLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic reset register 0; bottom 32 interrupts"]
    pub mod startrsrp0clr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTRSRP0CLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO0_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO0_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 14;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 15;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 16;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 17;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 18;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 19;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 20;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 21;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 22;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO1_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO1_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 23;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 24;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 25;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 26;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 27;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 28;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 29;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 30;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 31;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_0(&mut self) -> _RSRPIO0_0W {
                _RSRPIO0_0W { w: self }
            }
            #[doc = "Bit 1 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_1(&mut self) -> _RSRPIO0_1W {
                _RSRPIO0_1W { w: self }
            }
            #[doc = "Bit 2 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_2(&mut self) -> _RSRPIO0_2W {
                _RSRPIO0_2W { w: self }
            }
            #[doc = "Bit 3 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_3(&mut self) -> _RSRPIO0_3W {
                _RSRPIO0_3W { w: self }
            }
            #[doc = "Bit 4 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_4(&mut self) -> _RSRPIO0_4W {
                _RSRPIO0_4W { w: self }
            }
            #[doc = "Bit 5 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_5(&mut self) -> _RSRPIO0_5W {
                _RSRPIO0_5W { w: self }
            }
            #[doc = "Bit 6 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_6(&mut self) -> _RSRPIO0_6W {
                _RSRPIO0_6W { w: self }
            }
            #[doc = "Bit 7 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_7(&mut self) -> _RSRPIO0_7W {
                _RSRPIO0_7W { w: self }
            }
            #[doc = "Bit 8 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_8(&mut self) -> _RSRPIO0_8W {
                _RSRPIO0_8W { w: self }
            }
            #[doc = "Bit 9 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_9(&mut self) -> _RSRPIO0_9W {
                _RSRPIO0_9W { w: self }
            }
            #[doc = "Bit 10 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_10(&mut self) -> _RSRPIO0_10W {
                _RSRPIO0_10W { w: self }
            }
            #[doc = "Bit 11 - Start signal reset for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio0_11(&mut self) -> _RSRPIO0_11W {
                _RSRPIO0_11W { w: self }
            }
            #[doc = "Bit 12 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_0(&mut self) -> _RSRPIO1_0W {
                _RSRPIO1_0W { w: self }
            }
            #[doc = "Bit 13 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_1(&mut self) -> _RSRPIO1_1W {
                _RSRPIO1_1W { w: self }
            }
            #[doc = "Bit 14 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_2(&mut self) -> _RSRPIO1_2W {
                _RSRPIO1_2W { w: self }
            }
            #[doc = "Bit 15 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_3(&mut self) -> _RSRPIO1_3W {
                _RSRPIO1_3W { w: self }
            }
            #[doc = "Bit 16 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_4(&mut self) -> _RSRPIO1_4W {
                _RSRPIO1_4W { w: self }
            }
            #[doc = "Bit 17 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_5(&mut self) -> _RSRPIO1_5W {
                _RSRPIO1_5W { w: self }
            }
            #[doc = "Bit 18 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_6(&mut self) -> _RSRPIO1_6W {
                _RSRPIO1_6W { w: self }
            }
            #[doc = "Bit 19 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_7(&mut self) -> _RSRPIO1_7W {
                _RSRPIO1_7W { w: self }
            }
            #[doc = "Bit 20 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_8(&mut self) -> _RSRPIO1_8W {
                _RSRPIO1_8W { w: self }
            }
            #[doc = "Bit 21 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_9(&mut self) -> _RSRPIO1_9W {
                _RSRPIO1_9W { w: self }
            }
            #[doc = "Bit 22 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_10(&mut self) -> _RSRPIO1_10W {
                _RSRPIO1_10W { w: self }
            }
            #[doc = "Bit 23 - Start signal reset for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio1_11(&mut self) -> _RSRPIO1_11W {
                _RSRPIO1_11W { w: self }
            }
            #[doc = "Bit 24 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_0(&mut self) -> _RSRPIO2_0W {
                _RSRPIO2_0W { w: self }
            }
            #[doc = "Bit 25 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_1(&mut self) -> _RSRPIO2_1W {
                _RSRPIO2_1W { w: self }
            }
            #[doc = "Bit 26 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_2(&mut self) -> _RSRPIO2_2W {
                _RSRPIO2_2W { w: self }
            }
            #[doc = "Bit 27 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_3(&mut self) -> _RSRPIO2_3W {
                _RSRPIO2_3W { w: self }
            }
            #[doc = "Bit 28 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_4(&mut self) -> _RSRPIO2_4W {
                _RSRPIO2_4W { w: self }
            }
            #[doc = "Bit 29 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_5(&mut self) -> _RSRPIO2_5W {
                _RSRPIO2_5W { w: self }
            }
            #[doc = "Bit 30 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_6(&mut self) -> _RSRPIO2_6W {
                _RSRPIO2_6W { w: self }
            }
            #[doc = "Bit 31 - Start signal reset for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = Do nothing. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_7(&mut self) -> _RSRPIO2_7W {
                _RSRPIO2_7W { w: self }
            }
        }
    }
    #[doc = "Start logic status register 0; bottom 32 interrupts"]
    pub struct STARTSRP0 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic status register 0; bottom 32 interrupts"]
    pub mod startsrp0 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STARTSRP0 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_0R {
            bits: bool,
        }
        impl SRPIO0_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_1R {
            bits: bool,
        }
        impl SRPIO0_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_2R {
            bits: bool,
        }
        impl SRPIO0_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_3R {
            bits: bool,
        }
        impl SRPIO0_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_4R {
            bits: bool,
        }
        impl SRPIO0_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_5R {
            bits: bool,
        }
        impl SRPIO0_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_6R {
            bits: bool,
        }
        impl SRPIO0_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_7R {
            bits: bool,
        }
        impl SRPIO0_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_8R {
            bits: bool,
        }
        impl SRPIO0_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_9R {
            bits: bool,
        }
        impl SRPIO0_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_10R {
            bits: bool,
        }
        impl SRPIO0_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO0_11R {
            bits: bool,
        }
        impl SRPIO0_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_0R {
            bits: bool,
        }
        impl SRPIO1_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_1R {
            bits: bool,
        }
        impl SRPIO1_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_2R {
            bits: bool,
        }
        impl SRPIO1_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_3R {
            bits: bool,
        }
        impl SRPIO1_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_4R {
            bits: bool,
        }
        impl SRPIO1_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_5R {
            bits: bool,
        }
        impl SRPIO1_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_6R {
            bits: bool,
        }
        impl SRPIO1_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_7R {
            bits: bool,
        }
        impl SRPIO1_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_8R {
            bits: bool,
        }
        impl SRPIO1_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_9R {
            bits: bool,
        }
        impl SRPIO1_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_10R {
            bits: bool,
        }
        impl SRPIO1_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO1_11R {
            bits: bool,
        }
        impl SRPIO1_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_0R {
            bits: bool,
        }
        impl SRPIO2_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_1R {
            bits: bool,
        }
        impl SRPIO2_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_2R {
            bits: bool,
        }
        impl SRPIO2_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_3R {
            bits: bool,
        }
        impl SRPIO2_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_4R {
            bits: bool,
        }
        impl SRPIO2_4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_5R {
            bits: bool,
        }
        impl SRPIO2_5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_6R {
            bits: bool,
        }
        impl SRPIO2_6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_7R {
            bits: bool,
        }
        impl SRPIO2_7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_0(&self) -> SRPIO0_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_0R { bits }
            }
            #[doc = "Bit 1 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_1(&self) -> SRPIO0_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_1R { bits }
            }
            #[doc = "Bit 2 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_2(&self) -> SRPIO0_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_2R { bits }
            }
            #[doc = "Bit 3 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_3(&self) -> SRPIO0_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_3R { bits }
            }
            #[doc = "Bit 4 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_4(&self) -> SRPIO0_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_4R { bits }
            }
            #[doc = "Bit 5 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_5(&self) -> SRPIO0_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_5R { bits }
            }
            #[doc = "Bit 6 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_6(&self) -> SRPIO0_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_6R { bits }
            }
            #[doc = "Bit 7 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_7(&self) -> SRPIO0_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_7R { bits }
            }
            #[doc = "Bit 8 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_8(&self) -> SRPIO0_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_8R { bits }
            }
            #[doc = "Bit 9 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_9(&self) -> SRPIO0_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_9R { bits }
            }
            #[doc = "Bit 10 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_10(&self) -> SRPIO0_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_10R { bits }
            }
            #[doc = "Bit 11 - Start signal status for start logic input PIO0_n (bit 0 = PIO0_1, ..., bit 11 = PIO0_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio0_11(&self) -> SRPIO0_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO0_11R { bits }
            }
            #[doc = "Bit 12 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_0(&self) -> SRPIO1_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_0R { bits }
            }
            #[doc = "Bit 13 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_1(&self) -> SRPIO1_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_1R { bits }
            }
            #[doc = "Bit 14 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_2(&self) -> SRPIO1_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 14;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_2R { bits }
            }
            #[doc = "Bit 15 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_3(&self) -> SRPIO1_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 15;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_3R { bits }
            }
            #[doc = "Bit 16 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_4(&self) -> SRPIO1_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 16;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_4R { bits }
            }
            #[doc = "Bit 17 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_5(&self) -> SRPIO1_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 17;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_5R { bits }
            }
            #[doc = "Bit 18 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_6(&self) -> SRPIO1_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 18;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_6R { bits }
            }
            #[doc = "Bit 19 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_7(&self) -> SRPIO1_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 19;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_7R { bits }
            }
            #[doc = "Bit 20 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_8(&self) -> SRPIO1_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 20;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_8R { bits }
            }
            #[doc = "Bit 21 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_9(&self) -> SRPIO1_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 21;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_9R { bits }
            }
            #[doc = "Bit 22 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_10(&self) -> SRPIO1_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 22;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_10R { bits }
            }
            #[doc = "Bit 23 - Start signal status for start logic input PIO1_n (bit 12 = PIO1_0, ..., bit 23 = PIO1_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio1_11(&self) -> SRPIO1_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 23;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO1_11R { bits }
            }
            #[doc = "Bit 24 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_0(&self) -> SRPIO2_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 24;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_0R { bits }
            }
            #[doc = "Bit 25 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_1(&self) -> SRPIO2_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 25;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_1R { bits }
            }
            #[doc = "Bit 26 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_2(&self) -> SRPIO2_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 26;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_2R { bits }
            }
            #[doc = "Bit 27 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_3(&self) -> SRPIO2_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 27;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_3R { bits }
            }
            #[doc = "Bit 28 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_4(&self) -> SRPIO2_4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 28;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_4R { bits }
            }
            #[doc = "Bit 29 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_5(&self) -> SRPIO2_5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 29;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_5R { bits }
            }
            #[doc = "Bit 30 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_6(&self) -> SRPIO2_6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 30;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_6R { bits }
            }
            #[doc = "Bit 31 - Start signal status for start logic input PIO2_n (bit 24 = PIO2_0, ..., bit 31 = PIO2_7). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_7(&self) -> SRPIO2_7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 31;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_7R { bits }
            }
        }
    }
    #[doc = "Start logic edge control register 1; top 8 interrupts"]
    pub struct STARTAPRP1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic edge control register 1; top 8 interrupts"]
    pub mod startaprp1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTAPRP1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_8R {
            bits: bool,
        }
        impl APRPIO2_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_9R {
            bits: bool,
        }
        impl APRPIO2_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_10R {
            bits: bool,
        }
        impl APRPIO2_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO2_11R {
            bits: bool,
        }
        impl APRPIO2_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO3_0R {
            bits: bool,
        }
        impl APRPIO3_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO3_1R {
            bits: bool,
        }
        impl APRPIO3_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO3_2R {
            bits: bool,
        }
        impl APRPIO3_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct APRPIO3_3R {
            bits: bool,
        }
        impl APRPIO3_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO2_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO2_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO3_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO3_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO3_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO3_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO3_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO3_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _APRPIO3_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _APRPIO3_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_8(&self) -> APRPIO2_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_8R { bits }
            }
            #[doc = "Bit 1 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_9(&self) -> APRPIO2_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_9R { bits }
            }
            #[doc = "Bit 2 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_10(&self) -> APRPIO2_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_10R { bits }
            }
            #[doc = "Bit 3 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_11(&self) -> APRPIO2_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO2_11R { bits }
            }
            #[doc = "Bit 4 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_0(&self) -> APRPIO3_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO3_0R { bits }
            }
            #[doc = "Bit 5 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_1(&self) -> APRPIO3_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO3_1R { bits }
            }
            #[doc = "Bit 6 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_2(&self) -> APRPIO3_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO3_2R { bits }
            }
            #[doc = "Bit 7 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_3(&self) -> APRPIO3_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                APRPIO3_3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_8(&mut self) -> _APRPIO2_8W {
                _APRPIO2_8W { w: self }
            }
            #[doc = "Bit 1 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_9(&mut self) -> _APRPIO2_9W {
                _APRPIO2_9W { w: self }
            }
            #[doc = "Bit 2 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_10(&mut self) -> _APRPIO2_10W {
                _APRPIO2_10W { w: self }
            }
            #[doc = "Bit 3 - Edge select for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio2_11(&mut self) -> _APRPIO2_11W {
                _APRPIO2_11W { w: self }
            }
            #[doc = "Bit 4 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_0(&mut self) -> _APRPIO3_0W {
                _APRPIO3_0W { w: self }
            }
            #[doc = "Bit 5 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_1(&mut self) -> _APRPIO3_1W {
                _APRPIO3_1W { w: self }
            }
            #[doc = "Bit 6 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_2(&mut self) -> _APRPIO3_2W {
                _APRPIO3_2W { w: self }
            }
            #[doc = "Bit 7 - Edge select for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Falling edge. 1 = Rising edge."]
            #[inline]
            pub fn aprpio3_3(&mut self) -> _APRPIO3_3W {
                _APRPIO3_3W { w: self }
            }
        }
    }
    #[doc = "Start logic signal enable register 1; top 8 interrupts"]
    pub struct STARTERP1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic signal enable register 1; top 8 interrupts"]
    pub mod starterp1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTERP1 {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_8R {
            bits: bool,
        }
        impl ERPIO2_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_9R {
            bits: bool,
        }
        impl ERPIO2_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_10R {
            bits: bool,
        }
        impl ERPIO2_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO2_11R {
            bits: bool,
        }
        impl ERPIO2_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO3_0R {
            bits: bool,
        }
        impl ERPIO3_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO3_1R {
            bits: bool,
        }
        impl ERPIO3_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO3_2R {
            bits: bool,
        }
        impl ERPIO3_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ERPIO3_3R {
            bits: bool,
        }
        impl ERPIO3_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO2_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO2_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO3_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO3_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO3_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO3_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO3_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO3_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ERPIO3_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ERPIO3_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_8(&self) -> ERPIO2_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_8R { bits }
            }
            #[doc = "Bit 1 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_9(&self) -> ERPIO2_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_9R { bits }
            }
            #[doc = "Bit 2 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_10(&self) -> ERPIO2_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_10R { bits }
            }
            #[doc = "Bit 3 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_11(&self) -> ERPIO2_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO2_11R { bits }
            }
            #[doc = "Bit 4 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_0(&self) -> ERPIO3_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO3_0R { bits }
            }
            #[doc = "Bit 5 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_1(&self) -> ERPIO3_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO3_1R { bits }
            }
            #[doc = "Bit 6 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_2(&self) -> ERPIO3_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO3_2R { bits }
            }
            #[doc = "Bit 7 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_3(&self) -> ERPIO3_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ERPIO3_3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_8(&mut self) -> _ERPIO2_8W {
                _ERPIO2_8W { w: self }
            }
            #[doc = "Bit 1 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_9(&mut self) -> _ERPIO2_9W {
                _ERPIO2_9W { w: self }
            }
            #[doc = "Bit 2 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_10(&mut self) -> _ERPIO2_10W {
                _ERPIO2_10W { w: self }
            }
            #[doc = "Bit 3 - Enable start signal for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio2_11(&mut self) -> _ERPIO2_11W {
                _ERPIO2_11W { w: self }
            }
            #[doc = "Bit 4 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_0(&mut self) -> _ERPIO3_0W {
                _ERPIO3_0W { w: self }
            }
            #[doc = "Bit 5 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_1(&mut self) -> _ERPIO3_1W {
                _ERPIO3_1W { w: self }
            }
            #[doc = "Bit 6 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_2(&mut self) -> _ERPIO3_2W {
                _ERPIO3_2W { w: self }
            }
            #[doc = "Bit 7 - Enable start signal for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Disabled. 1 = Enabled."]
            #[inline]
            pub fn erpio3_3(&mut self) -> _ERPIO3_3W {
                _ERPIO3_3W { w: self }
            }
        }
    }
    #[doc = "Start logic reset register 1; top 8 interrupts"]
    pub struct STARTRSRP1CLR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic reset register 1; top 8 interrupts"]
    pub mod startrsrp1clr {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::STARTRSRP1CLR {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO2_11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO2_11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO3_0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO3_0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO3_1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO3_1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO3_2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO3_2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _RSRPIO3_3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _RSRPIO3_3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Start signal reset for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_8(&mut self) -> _RSRPIO2_8W {
                _RSRPIO2_8W { w: self }
            }
            #[doc = "Bit 1 - Start signal reset for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_9(&mut self) -> _RSRPIO2_9W {
                _RSRPIO2_9W { w: self }
            }
            #[doc = "Bit 2 - Start signal reset for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_10(&mut self) -> _RSRPIO2_10W {
                _RSRPIO2_10W { w: self }
            }
            #[doc = "Bit 3 - Start signal reset for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio2_11(&mut self) -> _RSRPIO2_11W {
                _RSRPIO2_11W { w: self }
            }
            #[doc = "Bit 4 - Start signal reset for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio3_0(&mut self) -> _RSRPIO3_0W {
                _RSRPIO3_0W { w: self }
            }
            #[doc = "Bit 5 - Start signal reset for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio3_1(&mut self) -> _RSRPIO3_1W {
                _RSRPIO3_1W { w: self }
            }
            #[doc = "Bit 6 - Start signal reset for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio3_2(&mut self) -> _RSRPIO3_2W {
                _RSRPIO3_2W { w: self }
            }
            #[doc = "Bit 7 - Start signal reset for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = Do nothing.. 1 = Write: reset start signal."]
            #[inline]
            pub fn rsrpio3_3(&mut self) -> _RSRPIO3_3W {
                _RSRPIO3_3W { w: self }
            }
        }
    }
    #[doc = "Start logic status register 1; top 8 interrupts"]
    pub struct STARTSRP1 {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Start logic status register 1; top 8 interrupts"]
    pub mod startsrp1 {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::STARTSRP1 {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_8R {
            bits: bool,
        }
        impl SRPIO2_8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_9R {
            bits: bool,
        }
        impl SRPIO2_9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_10R {
            bits: bool,
        }
        impl SRPIO2_10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO2_11R {
            bits: bool,
        }
        impl SRPIO2_11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO3_0R {
            bits: bool,
        }
        impl SRPIO3_0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO3_1R {
            bits: bool,
        }
        impl SRPIO3_1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO3_2R {
            bits: bool,
        }
        impl SRPIO3_2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct SRPIO3_3R {
            bits: bool,
        }
        impl SRPIO3_3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Start signal status for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_8(&self) -> SRPIO2_8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_8R { bits }
            }
            #[doc = "Bit 1 - Start signal status for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_9(&self) -> SRPIO2_9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_9R { bits }
            }
            #[doc = "Bit 2 - Start signal status for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_10(&self) -> SRPIO2_10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_10R { bits }
            }
            #[doc = "Bit 3 - Start signal status for start logic input PIO2_n (bit 0 = PIO2_8, ..., bit 3 = PIO2_11). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio2_11(&self) -> SRPIO2_11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO2_11R { bits }
            }
            #[doc = "Bit 4 - Start signal status for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio3_0(&self) -> SRPIO3_0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO3_0R { bits }
            }
            #[doc = "Bit 5 - Start signal status for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio3_1(&self) -> SRPIO3_1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO3_1R { bits }
            }
            #[doc = "Bit 6 - Start signal status for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio3_2(&self) -> SRPIO3_2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO3_2R { bits }
            }
            #[doc = "Bit 7 - Start signal status for start logic input PIO3_n (bit 4 = PIO3_0, ..., bit 7 = PIO3_3). 0 = No start signal received. 1 = Start signal pending."]
            #[inline]
            pub fn srpio3_3(&self) -> SRPIO3_3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                SRPIO3_3R { bits }
            }
        }
    }
    #[doc = "Power-down states in Deep-sleep mode"]
    pub struct PDSLEEPCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power-down states in Deep-sleep mode"]
    pub mod pdsleepcfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDSLEEPCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL0R {
            bits: u8,
        }
        impl FIXEDVAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL1R {
            bits: u8,
        }
        impl FIXEDVAL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL2R {
            bits: u8,
        }
        impl FIXEDVAL2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL0W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL1W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x03;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL2W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x1f;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:2 - Reserved. Always write these bits as 111."]
            #[inline]
            pub fn fixedval0(&self) -> FIXEDVAL0R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FIXEDVAL0R { bits }
            }
            #[doc = "Bit 3 - BOD power-down control in Deep-sleep mode, see Table 49."]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 4:5 - Reserved. Always write these bits as 11."]
            #[inline]
            pub fn fixedval1(&self) -> FIXEDVAL1R {
                let bits = {
                    const MASK: u8 = 0x03;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FIXEDVAL1R { bits }
            }
            #[doc = "Bit 6 - Watchdog oscillator power control in Deep-sleep mode, see Table 49."]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bits 7:11 - Reserved. Always write these bits as 11111."]
            #[inline]
            pub fn fixedval2(&self) -> FIXEDVAL2R {
                let bits = {
                    const MASK: u8 = 0x1f;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FIXEDVAL2R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bits 0:2 - Reserved. Always write these bits as 111."]
            #[inline]
            pub fn fixedval0(&mut self) -> _FIXEDVAL0W {
                _FIXEDVAL0W { w: self }
            }
            #[doc = "Bit 3 - BOD power-down control in Deep-sleep mode, see Table 49."]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bits 4:5 - Reserved. Always write these bits as 11."]
            #[inline]
            pub fn fixedval1(&mut self) -> _FIXEDVAL1W {
                _FIXEDVAL1W { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power control in Deep-sleep mode, see Table 49."]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bits 7:11 - Reserved. Always write these bits as 11111."]
            #[inline]
            pub fn fixedval2(&mut self) -> _FIXEDVAL2W {
                _FIXEDVAL2W { w: self }
            }
        }
    }
    #[doc = "Power-down states after wake-up from Deep-sleep mode"]
    pub struct PDAWAKECFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power-down states after wake-up from Deep-sleep mode"]
    pub mod pdawakecfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDAWAKECFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ADC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_PDR::POWERED => false,
                    ADC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_PDR {
                match value {
                    false => ADC_PDR::POWERED,
                    true => ADC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ADC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ADC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `USBPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USBPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl USBPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USBPLL_PDR::POWERED => false,
                    USBPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USBPLL_PDR {
                match value {
                    false => USBPLL_PDR::POWERED,
                    true => USBPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == USBPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == USBPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL0R {
            bits: bool,
        }
        impl FIXEDVAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `USBPAD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USBPAD_PDR {
            #[doc = "USB PHY powered"]
            USB_PHY_POWERED,
            #[doc = "USB PHY powered down"]
            USB_PHY_POWERED_DOWN,
        }
        impl USBPAD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USBPAD_PDR::USB_PHY_POWERED => false,
                    USBPAD_PDR::USB_PHY_POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USBPAD_PDR {
                match value {
                    false => USBPAD_PDR::USB_PHY_POWERED,
                    true => USBPAD_PDR::USB_PHY_POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `USB_PHY_POWERED`"]
            #[inline]
            pub fn is_usb_phy_powered(&self) -> bool {
                *self == USBPAD_PDR::USB_PHY_POWERED
            }
            #[doc = "Checks if the value of the field is `USB_PHY_POWERED_DOWN`"]
            #[inline]
            pub fn is_usb_phy_powered_down(&self) -> bool {
                *self == USBPAD_PDR::USB_PHY_POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL1R {
            bits: bool,
        }
        impl FIXEDVAL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL2R {
            bits: bool,
        }
        impl FIXEDVAL2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL3R {
            bits: u8,
        }
        impl FIXEDVAL3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u8 {
                self.bits
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_PD`"]
        pub enum ADC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_PDW::POWERED => false,
                    ADC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USBPLL_PD`"]
        pub enum USBPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl USBPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USBPLL_PDW::POWERED => false,
                    USBPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USBPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(USBPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(USBPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USBPAD_PD`"]
        pub enum USBPAD_PDW {
            #[doc = "USB PHY powered"]
            USB_PHY_POWERED,
            #[doc = "USB PHY powered down"]
            USB_PHY_POWERED_DOWN,
        }
        impl USBPAD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USBPAD_PDW::USB_PHY_POWERED => false,
                    USBPAD_PDW::USB_PHY_POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBPAD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBPAD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USBPAD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "USB PHY powered"]
            #[inline]
            pub fn usb_phy_powered(self) -> &'a mut W {
                self.variant(USBPAD_PDW::USB_PHY_POWERED)
            }
            #[doc = "USB PHY powered down"]
            #[inline]
            pub fn usb_phy_powered_down(self) -> &'a mut W {
                self.variant(USBPAD_PDW::USB_PHY_POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 12;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL3W<'a> {
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                const MASK: u8 = 0x07;
                const OFFSET: u8 = 13;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&self) -> ADC_PDR {
                ADC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - System oscillator wake-up configuration"]
            #[inline]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration"]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - USB PLL wake-up configuration"]
            #[inline]
            pub fn usbpll_pd(&self) -> USBPLL_PDR {
                USBPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval0(&self) -> FIXEDVAL0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIXEDVAL0R { bits }
            }
            #[doc = "Bit 10 - USB pad wake-up configuration"]
            #[inline]
            pub fn usbpad_pd(&self) -> USBPAD_PDR {
                USBPAD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Reserved. Always write this bit as 1."]
            #[inline]
            pub fn fixedval1(&self) -> FIXEDVAL1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIXEDVAL1R { bits }
            }
            #[doc = "Bit 12 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval2(&self) -> FIXEDVAL2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 12;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIXEDVAL2R { bits }
            }
            #[doc = "Bits 13:15 - Reserved. Always write these bits as 111."]
            #[inline]
            pub fn fixedval3(&self) -> FIXEDVAL3R {
                let bits = {
                    const MASK: u8 = 0x07;
                    const OFFSET: u8 = 13;
                    ((self.bits >> OFFSET) & MASK as u32) as u8
                };
                FIXEDVAL3R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xfdf0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output wake-up configuration"]
            #[inline]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power-down wake-up configuration"]
            #[inline]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash wake-up configuration"]
            #[inline]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD wake-up configuration"]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 4 - ADC wake-up configuration"]
            #[inline]
            pub fn adc_pd(&mut self) -> _ADC_PDW {
                _ADC_PDW { w: self }
            }
            #[doc = "Bit 5 - System oscillator wake-up configuration"]
            #[inline]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator wake-up configuration"]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL wake-up configuration"]
            #[inline]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 8 - USB PLL wake-up configuration"]
            #[inline]
            pub fn usbpll_pd(&mut self) -> _USBPLL_PDW {
                _USBPLL_PDW { w: self }
            }
            #[doc = "Bit 9 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval0(&mut self) -> _FIXEDVAL0W {
                _FIXEDVAL0W { w: self }
            }
            #[doc = "Bit 10 - USB pad wake-up configuration"]
            #[inline]
            pub fn usbpad_pd(&mut self) -> _USBPAD_PDW {
                _USBPAD_PDW { w: self }
            }
            #[doc = "Bit 11 - Reserved. Always write this bit as 1."]
            #[inline]
            pub fn fixedval1(&mut self) -> _FIXEDVAL1W {
                _FIXEDVAL1W { w: self }
            }
            #[doc = "Bit 12 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval2(&mut self) -> _FIXEDVAL2W {
                _FIXEDVAL2W { w: self }
            }
            #[doc = "Bits 13:15 - Reserved. Always write these bits as 111."]
            #[inline]
            pub fn fixedval3(&mut self) -> _FIXEDVAL3W {
                _FIXEDVAL3W { w: self }
            }
        }
    }
    #[doc = "Power-down configuration register"]
    pub struct PDRUNCFG {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Power-down configuration register"]
    pub mod pdruncfg {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::PDRUNCFG {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = "Possible values of the field `IRCOUT_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRCOUT_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRCOUT_PDR::POWERED => false,
                    IRCOUT_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRCOUT_PDR {
                match value {
                    false => IRCOUT_PDR::POWERED,
                    true => IRCOUT_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRCOUT_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRCOUT_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `IRC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    IRC_PDR::POWERED => false,
                    IRC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> IRC_PDR {
                match value {
                    false => IRC_PDR::POWERED,
                    true => IRC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == IRC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == IRC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `FLASH_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FLASH_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    FLASH_PDR::POWERED => false,
                    FLASH_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> FLASH_PDR {
                match value {
                    false => FLASH_PDR::POWERED,
                    true => FLASH_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == FLASH_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == FLASH_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `BOD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOD_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    BOD_PDR::POWERED => false,
                    BOD_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> BOD_PDR {
                match value {
                    false => BOD_PDR::POWERED,
                    true => BOD_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == BOD_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == BOD_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `ADC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    ADC_PDR::POWERED => false,
                    ADC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> ADC_PDR {
                match value {
                    false => ADC_PDR::POWERED,
                    true => ADC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == ADC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == ADC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSOSC_PDR::POWERED => false,
                    SYSOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSOSC_PDR {
                match value {
                    false => SYSOSC_PDR::POWERED,
                    true => SYSOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `WDTOSC_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDTOSC_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    WDTOSC_PDR::POWERED => false,
                    WDTOSC_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> WDTOSC_PDR {
                match value {
                    false => WDTOSC_PDR::POWERED,
                    true => WDTOSC_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == WDTOSC_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == WDTOSC_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `SYSPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SYSPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    SYSPLL_PDR::POWERED => false,
                    SYSPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> SYSPLL_PDR {
                match value {
                    false => SYSPLL_PDR::POWERED,
                    true => SYSPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == SYSPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == SYSPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = "Possible values of the field `USBPLL_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USBPLL_PDR {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl USBPLL_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USBPLL_PDR::POWERED => false,
                    USBPLL_PDR::POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USBPLL_PDR {
                match value {
                    false => USBPLL_PDR::POWERED,
                    true => USBPLL_PDR::POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `POWERED`"]
            #[inline]
            pub fn is_powered(&self) -> bool {
                *self == USBPLL_PDR::POWERED
            }
            #[doc = "Checks if the value of the field is `POWERED_DOWN`"]
            #[inline]
            pub fn is_powered_down(&self) -> bool {
                *self == USBPLL_PDR::POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL0R {
            bits: bool,
        }
        impl FIXEDVAL0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Possible values of the field `USBPAD_PD`"]
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum USBPAD_PDR {
            #[doc = "USB PHY powered"]
            USB_PHY_POWERED,
            #[doc = "USB PHY powered down (suspend mode)"]
            USB_PHY_POWERED_DOWN,
        }
        impl USBPAD_PDR {
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                match *self {
                    USBPAD_PDR::USB_PHY_POWERED => false,
                    USBPAD_PDR::USB_PHY_POWERED_DOWN => true,
                }
            }
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _from(value: bool) -> USBPAD_PDR {
                match value {
                    false => USBPAD_PDR::USB_PHY_POWERED,
                    true => USBPAD_PDR::USB_PHY_POWERED_DOWN,
                }
            }
            #[doc = "Checks if the value of the field is `USB_PHY_POWERED`"]
            #[inline]
            pub fn is_usb_phy_powered(&self) -> bool {
                *self == USBPAD_PDR::USB_PHY_POWERED
            }
            #[doc = "Checks if the value of the field is `USB_PHY_POWERED_DOWN`"]
            #[inline]
            pub fn is_usb_phy_powered_down(&self) -> bool {
                *self == USBPAD_PDR::USB_PHY_POWERED_DOWN
            }
        }
        #[doc = r" Value of the field"]
        pub struct FIXEDVAL1R {
            bits: bool,
        }
        impl FIXEDVAL1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = "Values that can be written to the field `IRCOUT_PD`"]
        pub enum IRCOUT_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRCOUT_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRCOUT_PDW::POWERED => false,
                    IRCOUT_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRCOUT_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRCOUT_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRCOUT_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRCOUT_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `IRC_PD`"]
        pub enum IRC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl IRC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    IRC_PDW::POWERED => false,
                    IRC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _IRC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _IRC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: IRC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(IRC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `FLASH_PD`"]
        pub enum FLASH_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl FLASH_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    FLASH_PDW::POWERED => false,
                    FLASH_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _FLASH_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _FLASH_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: FLASH_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(FLASH_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `BOD_PD`"]
        pub enum BOD_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl BOD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    BOD_PDW::POWERED => false,
                    BOD_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _BOD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _BOD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: BOD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(BOD_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `ADC_PD`"]
        pub enum ADC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl ADC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    ADC_PDW::POWERED => false,
                    ADC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _ADC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _ADC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: ADC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(ADC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSOSC_PD`"]
        pub enum SYSOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSOSC_PDW::POWERED => false,
                    SYSOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `WDTOSC_PD`"]
        pub enum WDTOSC_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl WDTOSC_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    WDTOSC_PDW::POWERED => false,
                    WDTOSC_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _WDTOSC_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _WDTOSC_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: WDTOSC_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(WDTOSC_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `SYSPLL_PD`"]
        pub enum SYSPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl SYSPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    SYSPLL_PDW::POWERED => false,
                    SYSPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _SYSPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _SYSPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: SYSPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(SYSPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USBPLL_PD`"]
        pub enum USBPLL_PDW {
            #[doc = "Powered"]
            POWERED,
            #[doc = "Powered down"]
            POWERED_DOWN,
        }
        impl USBPLL_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USBPLL_PDW::POWERED => false,
                    USBPLL_PDW::POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBPLL_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBPLL_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USBPLL_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "Powered"]
            #[inline]
            pub fn powered(self) -> &'a mut W {
                self.variant(USBPLL_PDW::POWERED)
            }
            #[doc = "Powered down"]
            #[inline]
            pub fn powered_down(self) -> &'a mut W {
                self.variant(USBPLL_PDW::POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = "Values that can be written to the field `USBPAD_PD`"]
        pub enum USBPAD_PDW {
            #[doc = "USB PHY powered"]
            USB_PHY_POWERED,
            #[doc = "USB PHY powered down (suspend mode)"]
            USB_PHY_POWERED_DOWN,
        }
        impl USBPAD_PDW {
            #[allow(missing_docs)]
            #[doc(hidden)]
            #[inline]
            pub fn _bits(&self) -> bool {
                match *self {
                    USBPAD_PDW::USB_PHY_POWERED => false,
                    USBPAD_PDW::USB_PHY_POWERED_DOWN => true,
                }
            }
        }
        #[doc = r" Proxy"]
        pub struct _USBPAD_PDW<'a> {
            w: &'a mut W,
        }
        impl<'a> _USBPAD_PDW<'a> {
            #[doc = r" Writes `variant` to the field"]
            #[inline]
            pub fn variant(self, variant: USBPAD_PDW) -> &'a mut W {
                {
                    self.bit(variant._bits())
                }
            }
            #[doc = "USB PHY powered"]
            #[inline]
            pub fn usb_phy_powered(self) -> &'a mut W {
                self.variant(USBPAD_PDW::USB_PHY_POWERED)
            }
            #[doc = "USB PHY powered down (suspend mode)"]
            #[inline]
            pub fn usb_phy_powered_down(self) -> &'a mut W {
                self.variant(USBPAD_PDW::USB_PHY_POWERED_DOWN)
            }
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _FIXEDVAL1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _FIXEDVAL1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - IRC oscillator output power-down"]
            #[inline]
            pub fn ircout_pd(&self) -> IRCOUT_PDR {
                IRCOUT_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 1 - IRC oscillator power-down"]
            #[inline]
            pub fn irc_pd(&self) -> IRC_PDR {
                IRC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 2 - Flash power-down"]
            #[inline]
            pub fn flash_pd(&self) -> FLASH_PDR {
                FLASH_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 3 - BOD power-down"]
            #[inline]
            pub fn bod_pd(&self) -> BOD_PDR {
                BOD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 4 - ADC power-down"]
            #[inline]
            pub fn adc_pd(&self) -> ADC_PDR {
                ADC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 5 - System oscillator power-down[1]"]
            #[inline]
            pub fn sysosc_pd(&self) -> SYSOSC_PDR {
                SYSOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down"]
            #[inline]
            pub fn wdtosc_pd(&self) -> WDTOSC_PDR {
                WDTOSC_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 7 - System PLL power-down"]
            #[inline]
            pub fn syspll_pd(&self) -> SYSPLL_PDR {
                SYSPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 8 - USB PLL power-down"]
            #[inline]
            pub fn usbpll_pd(&self) -> USBPLL_PDR {
                USBPLL_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 9 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval0(&self) -> FIXEDVAL0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIXEDVAL0R { bits }
            }
            #[doc = "Bit 10 - USB pad power-down configuration"]
            #[inline]
            pub fn usbpad_pd(&self) -> USBPAD_PDR {
                USBPAD_PDR::_from({
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                })
            }
            #[doc = "Bit 11 - Reserved. Always write this bit as 1."]
            #[inline]
            pub fn fixedval1(&self) -> FIXEDVAL1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                FIXEDVAL1R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0xfdf0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - IRC oscillator output power-down"]
            #[inline]
            pub fn ircout_pd(&mut self) -> _IRCOUT_PDW {
                _IRCOUT_PDW { w: self }
            }
            #[doc = "Bit 1 - IRC oscillator power-down"]
            #[inline]
            pub fn irc_pd(&mut self) -> _IRC_PDW {
                _IRC_PDW { w: self }
            }
            #[doc = "Bit 2 - Flash power-down"]
            #[inline]
            pub fn flash_pd(&mut self) -> _FLASH_PDW {
                _FLASH_PDW { w: self }
            }
            #[doc = "Bit 3 - BOD power-down"]
            #[inline]
            pub fn bod_pd(&mut self) -> _BOD_PDW {
                _BOD_PDW { w: self }
            }
            #[doc = "Bit 4 - ADC power-down"]
            #[inline]
            pub fn adc_pd(&mut self) -> _ADC_PDW {
                _ADC_PDW { w: self }
            }
            #[doc = "Bit 5 - System oscillator power-down[1]"]
            #[inline]
            pub fn sysosc_pd(&mut self) -> _SYSOSC_PDW {
                _SYSOSC_PDW { w: self }
            }
            #[doc = "Bit 6 - Watchdog oscillator power-down"]
            #[inline]
            pub fn wdtosc_pd(&mut self) -> _WDTOSC_PDW {
                _WDTOSC_PDW { w: self }
            }
            #[doc = "Bit 7 - System PLL power-down"]
            #[inline]
            pub fn syspll_pd(&mut self) -> _SYSPLL_PDW {
                _SYSPLL_PDW { w: self }
            }
            #[doc = "Bit 8 - USB PLL power-down"]
            #[inline]
            pub fn usbpll_pd(&mut self) -> _USBPLL_PDW {
                _USBPLL_PDW { w: self }
            }
            #[doc = "Bit 9 - Reserved. Always write this bit as 0."]
            #[inline]
            pub fn fixedval0(&mut self) -> _FIXEDVAL0W {
                _FIXEDVAL0W { w: self }
            }
            #[doc = "Bit 10 - USB pad power-down configuration"]
            #[inline]
            pub fn usbpad_pd(&mut self) -> _USBPAD_PDW {
                _USBPAD_PDW { w: self }
            }
            #[doc = "Bit 11 - Reserved. Always write this bit as 1."]
            #[inline]
            pub fn fixedval1(&mut self) -> _FIXEDVAL1W {
                _FIXEDVAL1W { w: self }
            }
        }
    }
    #[doc = "Device ID"]
    pub struct DEVICE_ID {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Device ID"]
    pub mod device_id {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::DEVICE_ID {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct DEVICEIDR {
            bits: u32,
        }
        impl DEVICEIDR {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bits 0:31 - Device ID for LPC13xx parts: 0x2C42 502B = LPC1311FHN33 0x2C40 102B = LPC1313FHN33 0x2C40 102B = LPC1313FBD48 0x3D01 402B = LPC1342FHN33 0x3D00 002B = LPC1343FHN33 0x3D00 002B = LPC1343FBD48 0x1816 902B = LPC1311FHN33/01 0x1830 102B = LPC1313FHN33/01 0x1830 102B = LPC1313FBD48/01"]
            #[inline]
            pub fn deviceid(&self) -> DEVICEIDR {
                let bits = {
                    const MASK: u32 = 0xffff_ffff;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) as u32
                };
                DEVICEIDR { bits }
            }
        }
    }
}
#[doc = "SSP1"]
pub struct SSP1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SSP1 {}
impl SSP1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const ssp0::RegisterBlock {
        0x4005_8000 as *const _
    }
}
impl Deref for SSP1 {
    type Target = ssp0::RegisterBlock;
    fn deref(&self) -> &ssp0::RegisterBlock {
        unsafe { &*SSP1::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx General Purpose I/O (GPIO) Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub struct GPIO0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO0 {}
impl GPIO0 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio0::RegisterBlock {
        0x5000_0000 as *const _
    }
}
impl Deref for GPIO0 {
    type Target = gpio0::RegisterBlock;
    fn deref(&self) -> &gpio0::RegisterBlock {
        unsafe { &*GPIO0::ptr() }
    }
}
#[doc = "Product name title=UM10375 Chapter title=LPC13xx General Purpose I/O (GPIO) Modification date=4/20/2011 Major revision=2 Minor revision=1"]
pub mod gpio0 {
    #[doc = r" Register block"]
    #[repr(C)]
    pub struct RegisterBlock {
        _reserved0: [u8; 16380usize],
        #[doc = "0x3ffc - Port n data register for pins PIOn_0 to PIOn_11"]
        pub data: DATA,
        _reserved1: [u8; 16384usize],
        #[doc = "0x8000 - Data direction register for port n"]
        pub dir: DIR,
        #[doc = "0x8004 - Interrupt sense register for port n"]
        pub is: IS,
        #[doc = "0x8008 - Interrupt both edges register for port n"]
        pub ibe: IBE,
        #[doc = "0x800c - Interrupt event register for port n"]
        pub iev: IEV,
        #[doc = "0x8010 - Interrupt mask register for port n"]
        pub ie: IE,
        #[doc = "0x8014 - Raw interrupt status register for port n"]
        pub ris: RIS,
        #[doc = "0x8018 - Masked interrupt status register for port n"]
        pub mis: MIS,
        #[doc = "0x801c - Interrupt clear register for port n"]
        pub ic: IC,
    }
    #[doc = "Port n data register for pins PIOn_0 to PIOn_11"]
    pub struct DATA {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Port n data register for pins PIOn_0 to PIOn_11"]
    pub mod data {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DATA {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA0R {
            bits: bool,
        }
        impl DATA0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA1R {
            bits: bool,
        }
        impl DATA1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA2R {
            bits: bool,
        }
        impl DATA2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA3R {
            bits: bool,
        }
        impl DATA3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA4R {
            bits: bool,
        }
        impl DATA4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA5R {
            bits: bool,
        }
        impl DATA5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA6R {
            bits: bool,
        }
        impl DATA6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA7R {
            bits: bool,
        }
        impl DATA7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA8R {
            bits: bool,
        }
        impl DATA8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA9R {
            bits: bool,
        }
        impl DATA9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA10R {
            bits: bool,
        }
        impl DATA10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct DATA11R {
            bits: bool,
        }
        impl DATA11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _DATA11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _DATA11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data0(&self) -> DATA0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA0R { bits }
            }
            #[doc = "Bit 1 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data1(&self) -> DATA1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA1R { bits }
            }
            #[doc = "Bit 2 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data2(&self) -> DATA2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA2R { bits }
            }
            #[doc = "Bit 3 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data3(&self) -> DATA3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA3R { bits }
            }
            #[doc = "Bit 4 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data4(&self) -> DATA4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA4R { bits }
            }
            #[doc = "Bit 5 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data5(&self) -> DATA5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA5R { bits }
            }
            #[doc = "Bit 6 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data6(&self) -> DATA6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA6R { bits }
            }
            #[doc = "Bit 7 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data7(&self) -> DATA7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA7R { bits }
            }
            #[doc = "Bit 8 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data8(&self) -> DATA8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA8R { bits }
            }
            #[doc = "Bit 9 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data9(&self) -> DATA9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA9R { bits }
            }
            #[doc = "Bit 10 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data10(&self) -> DATA10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA10R { bits }
            }
            #[doc = "Bit 11 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data11(&self) -> DATA11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                DATA11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data0(&mut self) -> _DATA0W {
                _DATA0W { w: self }
            }
            #[doc = "Bit 1 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data1(&mut self) -> _DATA1W {
                _DATA1W { w: self }
            }
            #[doc = "Bit 2 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data2(&mut self) -> _DATA2W {
                _DATA2W { w: self }
            }
            #[doc = "Bit 3 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data3(&mut self) -> _DATA3W {
                _DATA3W { w: self }
            }
            #[doc = "Bit 4 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data4(&mut self) -> _DATA4W {
                _DATA4W { w: self }
            }
            #[doc = "Bit 5 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data5(&mut self) -> _DATA5W {
                _DATA5W { w: self }
            }
            #[doc = "Bit 6 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data6(&mut self) -> _DATA6W {
                _DATA6W { w: self }
            }
            #[doc = "Bit 7 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data7(&mut self) -> _DATA7W {
                _DATA7W { w: self }
            }
            #[doc = "Bit 8 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data8(&mut self) -> _DATA8W {
                _DATA8W { w: self }
            }
            #[doc = "Bit 9 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data9(&mut self) -> _DATA9W {
                _DATA9W { w: self }
            }
            #[doc = "Bit 10 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data10(&mut self) -> _DATA10W {
                _DATA10W { w: self }
            }
            #[doc = "Bit 11 - Logic levels for pins PIOn_0 to PIOn_11. HIGH = 1, LOW = 0."]
            #[inline]
            pub fn data11(&mut self) -> _DATA11W {
                _DATA11W { w: self }
            }
        }
    }
    #[doc = "Data direction register for port n"]
    pub struct DIR {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Data direction register for port n"]
    pub mod dir {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::DIR {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO0R {
            bits: bool,
        }
        impl IO0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO1R {
            bits: bool,
        }
        impl IO1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO2R {
            bits: bool,
        }
        impl IO2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO3R {
            bits: bool,
        }
        impl IO3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO4R {
            bits: bool,
        }
        impl IO4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO5R {
            bits: bool,
        }
        impl IO5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO6R {
            bits: bool,
        }
        impl IO6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO7R {
            bits: bool,
        }
        impl IO7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO8R {
            bits: bool,
        }
        impl IO8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO9R {
            bits: bool,
        }
        impl IO9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO10R {
            bits: bool,
        }
        impl IO10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IO11R {
            bits: bool,
        }
        impl IO11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IO11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IO11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io0(&self) -> IO0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO0R { bits }
            }
            #[doc = "Bit 1 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io1(&self) -> IO1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO1R { bits }
            }
            #[doc = "Bit 2 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io2(&self) -> IO2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO2R { bits }
            }
            #[doc = "Bit 3 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io3(&self) -> IO3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO3R { bits }
            }
            #[doc = "Bit 4 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io4(&self) -> IO4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO4R { bits }
            }
            #[doc = "Bit 5 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io5(&self) -> IO5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO5R { bits }
            }
            #[doc = "Bit 6 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io6(&self) -> IO6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO6R { bits }
            }
            #[doc = "Bit 7 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io7(&self) -> IO7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO7R { bits }
            }
            #[doc = "Bit 8 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io8(&self) -> IO8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO8R { bits }
            }
            #[doc = "Bit 9 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io9(&self) -> IO9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO9R { bits }
            }
            #[doc = "Bit 10 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io10(&self) -> IO10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO10R { bits }
            }
            #[doc = "Bit 11 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io11(&self) -> IO11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IO11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io0(&mut self) -> _IO0W {
                _IO0W { w: self }
            }
            #[doc = "Bit 1 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io1(&mut self) -> _IO1W {
                _IO1W { w: self }
            }
            #[doc = "Bit 2 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io2(&mut self) -> _IO2W {
                _IO2W { w: self }
            }
            #[doc = "Bit 3 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io3(&mut self) -> _IO3W {
                _IO3W { w: self }
            }
            #[doc = "Bit 4 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io4(&mut self) -> _IO4W {
                _IO4W { w: self }
            }
            #[doc = "Bit 5 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io5(&mut self) -> _IO5W {
                _IO5W { w: self }
            }
            #[doc = "Bit 6 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io6(&mut self) -> _IO6W {
                _IO6W { w: self }
            }
            #[doc = "Bit 7 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io7(&mut self) -> _IO7W {
                _IO7W { w: self }
            }
            #[doc = "Bit 8 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io8(&mut self) -> _IO8W {
                _IO8W { w: self }
            }
            #[doc = "Bit 9 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io9(&mut self) -> _IO9W {
                _IO9W { w: self }
            }
            #[doc = "Bit 10 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io10(&mut self) -> _IO10W {
                _IO10W { w: self }
            }
            #[doc = "Bit 11 - Selects pin x as input or output (x = 0 to 11). 0 = Pin PIOn_x is configured as input. 1 = Pin PIOn_x is configured as output."]
            #[inline]
            pub fn io11(&mut self) -> _IO11W {
                _IO11W { w: self }
            }
        }
    }
    #[doc = "Interrupt sense register for port n"]
    pub struct IS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt sense register for port n"]
    pub mod is {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IS {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE0R {
            bits: bool,
        }
        impl ISENSE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE1R {
            bits: bool,
        }
        impl ISENSE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE2R {
            bits: bool,
        }
        impl ISENSE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE3R {
            bits: bool,
        }
        impl ISENSE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE4R {
            bits: bool,
        }
        impl ISENSE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE5R {
            bits: bool,
        }
        impl ISENSE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE6R {
            bits: bool,
        }
        impl ISENSE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE7R {
            bits: bool,
        }
        impl ISENSE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE8R {
            bits: bool,
        }
        impl ISENSE8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE9R {
            bits: bool,
        }
        impl ISENSE9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE10R {
            bits: bool,
        }
        impl ISENSE10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct ISENSE11R {
            bits: bool,
        }
        impl ISENSE11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _ISENSE11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _ISENSE11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense0(&self) -> ISENSE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE0R { bits }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense1(&self) -> ISENSE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE1R { bits }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense2(&self) -> ISENSE2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE2R { bits }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense3(&self) -> ISENSE3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE3R { bits }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense4(&self) -> ISENSE4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE4R { bits }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense5(&self) -> ISENSE5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE5R { bits }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense6(&self) -> ISENSE6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE6R { bits }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense7(&self) -> ISENSE7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE7R { bits }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense8(&self) -> ISENSE8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE8R { bits }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense9(&self) -> ISENSE9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE9R { bits }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense10(&self) -> ISENSE10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE10R { bits }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense11(&self) -> ISENSE11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                ISENSE11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense0(&mut self) -> _ISENSE0W {
                _ISENSE0W { w: self }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense1(&mut self) -> _ISENSE1W {
                _ISENSE1W { w: self }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense2(&mut self) -> _ISENSE2W {
                _ISENSE2W { w: self }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense3(&mut self) -> _ISENSE3W {
                _ISENSE3W { w: self }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense4(&mut self) -> _ISENSE4W {
                _ISENSE4W { w: self }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense5(&mut self) -> _ISENSE5W {
                _ISENSE5W { w: self }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense6(&mut self) -> _ISENSE6W {
                _ISENSE6W { w: self }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense7(&mut self) -> _ISENSE7W {
                _ISENSE7W { w: self }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense8(&mut self) -> _ISENSE8W {
                _ISENSE8W { w: self }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense9(&mut self) -> _ISENSE9W {
                _ISENSE9W { w: self }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense10(&mut self) -> _ISENSE10W {
                _ISENSE10W { w: self }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x as level or edge sensitive (x = 0 to 11). 0 = Interrupt on pin PIOn_x is configured as edge sensitive. 1 = Interrupt on pin PIOn_x is configured as level sensitive."]
            #[inline]
            pub fn isense11(&mut self) -> _ISENSE11W {
                _ISENSE11W { w: self }
            }
        }
    }
    #[doc = "Interrupt both edges register for port n"]
    pub struct IBE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt both edges register for port n"]
    pub mod ibe {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IBE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE0R {
            bits: bool,
        }
        impl IBE0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE1R {
            bits: bool,
        }
        impl IBE1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE2R {
            bits: bool,
        }
        impl IBE2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE3R {
            bits: bool,
        }
        impl IBE3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE4R {
            bits: bool,
        }
        impl IBE4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE5R {
            bits: bool,
        }
        impl IBE5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE6R {
            bits: bool,
        }
        impl IBE6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE7R {
            bits: bool,
        }
        impl IBE7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE8R {
            bits: bool,
        }
        impl IBE8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE9R {
            bits: bool,
        }
        impl IBE9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE10R {
            bits: bool,
        }
        impl IBE10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IBE11R {
            bits: bool,
        }
        impl IBE11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IBE11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IBE11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe0(&self) -> IBE0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE0R { bits }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe1(&self) -> IBE1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE1R { bits }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe2(&self) -> IBE2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE2R { bits }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe3(&self) -> IBE3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE3R { bits }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe4(&self) -> IBE4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE4R { bits }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe5(&self) -> IBE5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE5R { bits }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe6(&self) -> IBE6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE6R { bits }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe7(&self) -> IBE7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE7R { bits }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe8(&self) -> IBE8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE8R { bits }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe9(&self) -> IBE9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE9R { bits }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe10(&self) -> IBE10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE10R { bits }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe11(&self) -> IBE11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IBE11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe0(&mut self) -> _IBE0W {
                _IBE0W { w: self }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe1(&mut self) -> _IBE1W {
                _IBE1W { w: self }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe2(&mut self) -> _IBE2W {
                _IBE2W { w: self }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe3(&mut self) -> _IBE3W {
                _IBE3W { w: self }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe4(&mut self) -> _IBE4W {
                _IBE4W { w: self }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe5(&mut self) -> _IBE5W {
                _IBE5W { w: self }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe6(&mut self) -> _IBE6W {
                _IBE6W { w: self }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe7(&mut self) -> _IBE7W {
                _IBE7W { w: self }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe8(&mut self) -> _IBE8W {
                _IBE8W { w: self }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe9(&mut self) -> _IBE9W {
                _IBE9W { w: self }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe10(&mut self) -> _IBE10W {
                _IBE10W { w: self }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be triggered on both edges (x = 0 to 11). 0 = Interrupt on pin PIOn_x is controlled through register GPIOIEV. 1 = Both edges on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn ibe11(&mut self) -> _IBE11W {
                _IBE11W { w: self }
            }
        }
    }
    #[doc = "Interrupt event register for port n"]
    pub struct IEV {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt event register for port n"]
    pub mod iev {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IEV {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV0R {
            bits: bool,
        }
        impl IEV0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV1R {
            bits: bool,
        }
        impl IEV1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV2R {
            bits: bool,
        }
        impl IEV2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV3R {
            bits: bool,
        }
        impl IEV3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV4R {
            bits: bool,
        }
        impl IEV4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV5R {
            bits: bool,
        }
        impl IEV5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV6R {
            bits: bool,
        }
        impl IEV6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV7R {
            bits: bool,
        }
        impl IEV7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV8R {
            bits: bool,
        }
        impl IEV8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV9R {
            bits: bool,
        }
        impl IEV9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV10R {
            bits: bool,
        }
        impl IEV10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct IEV11R {
            bits: bool,
        }
        impl IEV11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _IEV11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _IEV11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev0(&self) -> IEV0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV0R { bits }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev1(&self) -> IEV1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV1R { bits }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev2(&self) -> IEV2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV2R { bits }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev3(&self) -> IEV3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV3R { bits }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev4(&self) -> IEV4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV4R { bits }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev5(&self) -> IEV5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV5R { bits }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev6(&self) -> IEV6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV6R { bits }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev7(&self) -> IEV7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV7R { bits }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev8(&self) -> IEV8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV8R { bits }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev9(&self) -> IEV9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV9R { bits }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev10(&self) -> IEV10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV10R { bits }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev11(&self) -> IEV11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                IEV11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev0(&mut self) -> _IEV0W {
                _IEV0W { w: self }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev1(&mut self) -> _IEV1W {
                _IEV1W { w: self }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev2(&mut self) -> _IEV2W {
                _IEV2W { w: self }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev3(&mut self) -> _IEV3W {
                _IEV3W { w: self }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev4(&mut self) -> _IEV4W {
                _IEV4W { w: self }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev5(&mut self) -> _IEV5W {
                _IEV5W { w: self }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev6(&mut self) -> _IEV6W {
                _IEV6W { w: self }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev7(&mut self) -> _IEV7W {
                _IEV7W { w: self }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev8(&mut self) -> _IEV8W {
                _IEV8W { w: self }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev9(&mut self) -> _IEV9W {
                _IEV9W { w: self }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev10(&mut self) -> _IEV10W {
                _IEV10W { w: self }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be triggered rising or falling edges (x = 0 to 11). 0 = Depending on setting in register GPIOIS (see Table 151), falling edges or LOW level on pin PIOn_x trigger an interrupt. 1 = Depending on setting in register GPIOIS (see Table 151), rising edges or HIGH level on pin PIOn_x trigger an interrupt."]
            #[inline]
            pub fn iev11(&mut self) -> _IEV11W {
                _IEV11W { w: self }
            }
        }
    }
    #[doc = "Interrupt mask register for port n"]
    pub struct IE {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt mask register for port n"]
    pub mod ie {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IE {
            #[doc = r" Modifies the contents of the register"]
            #[inline]
            pub fn modify<F>(&self, f: F)
            where
                for<'w> F: FnOnce(&R, &'w mut W) -> &'w mut W,
            {
                let bits = self.register.get();
                let r = R { bits: bits };
                let mut w = W { bits: bits };
                f(&r, &mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
            #[doc = r" Writes the reset value to the register"]
            #[inline]
            pub fn reset(&self) {
                self.write(|w| w)
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK0R {
            bits: bool,
        }
        impl MASK0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK1R {
            bits: bool,
        }
        impl MASK1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK2R {
            bits: bool,
        }
        impl MASK2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK3R {
            bits: bool,
        }
        impl MASK3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK4R {
            bits: bool,
        }
        impl MASK4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK5R {
            bits: bool,
        }
        impl MASK5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK6R {
            bits: bool,
        }
        impl MASK6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK7R {
            bits: bool,
        }
        impl MASK7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK8R {
            bits: bool,
        }
        impl MASK8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK9R {
            bits: bool,
        }
        impl MASK9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK10R {
            bits: bool,
        }
        impl MASK10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK11R {
            bits: bool,
        }
        impl MASK11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _MASK11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _MASK11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask0(&self) -> MASK0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK0R { bits }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask1(&self) -> MASK1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK1R { bits }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask2(&self) -> MASK2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK2R { bits }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask3(&self) -> MASK3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK3R { bits }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask4(&self) -> MASK4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK4R { bits }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask5(&self) -> MASK5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK5R { bits }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask6(&self) -> MASK6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK6R { bits }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask7(&self) -> MASK7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK7R { bits }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask8(&self) -> MASK8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK8R { bits }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask9(&self) -> MASK9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK9R { bits }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask10(&self) -> MASK10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK10R { bits }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask11(&self) -> MASK11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK11R { bits }
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask0(&mut self) -> _MASK0W {
                _MASK0W { w: self }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask1(&mut self) -> _MASK1W {
                _MASK1W { w: self }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask2(&mut self) -> _MASK2W {
                _MASK2W { w: self }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask3(&mut self) -> _MASK3W {
                _MASK3W { w: self }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask4(&mut self) -> _MASK4W {
                _MASK4W { w: self }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask5(&mut self) -> _MASK5W {
                _MASK5W { w: self }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask6(&mut self) -> _MASK6W {
                _MASK6W { w: self }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask7(&mut self) -> _MASK7W {
                _MASK7W { w: self }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask8(&mut self) -> _MASK8W {
                _MASK8W { w: self }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask9(&mut self) -> _MASK9W {
                _MASK9W { w: self }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask10(&mut self) -> _MASK10W {
                _MASK10W { w: self }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = Interrupt on pin PIOn_x is masked. 1 = Interrupt on pin PIOn_x is not masked."]
            #[inline]
            pub fn mask11(&mut self) -> _MASK11W {
                _MASK11W { w: self }
            }
        }
    }
    #[doc = "Raw interrupt status register for port n"]
    pub struct RIS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Raw interrupt status register for port n"]
    pub mod ris {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::RIS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST0R {
            bits: bool,
        }
        impl RAWST0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST1R {
            bits: bool,
        }
        impl RAWST1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST2R {
            bits: bool,
        }
        impl RAWST2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST3R {
            bits: bool,
        }
        impl RAWST3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST4R {
            bits: bool,
        }
        impl RAWST4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST5R {
            bits: bool,
        }
        impl RAWST5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST6R {
            bits: bool,
        }
        impl RAWST6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST7R {
            bits: bool,
        }
        impl RAWST7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST8R {
            bits: bool,
        }
        impl RAWST8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST9R {
            bits: bool,
        }
        impl RAWST9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST10R {
            bits: bool,
        }
        impl RAWST10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct RAWST11R {
            bits: bool,
        }
        impl RAWST11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst0(&self) -> RAWST0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST0R { bits }
            }
            #[doc = "Bit 1 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst1(&self) -> RAWST1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST1R { bits }
            }
            #[doc = "Bit 2 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst2(&self) -> RAWST2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST2R { bits }
            }
            #[doc = "Bit 3 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst3(&self) -> RAWST3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST3R { bits }
            }
            #[doc = "Bit 4 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst4(&self) -> RAWST4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST4R { bits }
            }
            #[doc = "Bit 5 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst5(&self) -> RAWST5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST5R { bits }
            }
            #[doc = "Bit 6 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst6(&self) -> RAWST6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST6R { bits }
            }
            #[doc = "Bit 7 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst7(&self) -> RAWST7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST7R { bits }
            }
            #[doc = "Bit 8 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst8(&self) -> RAWST8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST8R { bits }
            }
            #[doc = "Bit 9 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst9(&self) -> RAWST9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST9R { bits }
            }
            #[doc = "Bit 10 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst10(&self) -> RAWST10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST10R { bits }
            }
            #[doc = "Bit 11 - Raw interrupt status (x = 0 to 11). 0 = No interrupt on pin PIOn_x. 1 = Interrupt requirements met on PIOn_x."]
            #[inline]
            pub fn rawst11(&self) -> RAWST11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                RAWST11R { bits }
            }
        }
    }
    #[doc = "Masked interrupt status register for port n"]
    pub struct MIS {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Masked interrupt status register for port n"]
    pub mod mis {
        #[doc = r" Value read from the register"]
        pub struct R {
            bits: u32,
        }
        impl super::MIS {
            #[doc = r" Reads the contents of the register"]
            #[inline]
            pub fn read(&self) -> R {
                R {
                    bits: self.register.get(),
                }
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK0R {
            bits: bool,
        }
        impl MASK0R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK1R {
            bits: bool,
        }
        impl MASK1R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK2R {
            bits: bool,
        }
        impl MASK2R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK3R {
            bits: bool,
        }
        impl MASK3R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK4R {
            bits: bool,
        }
        impl MASK4R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK5R {
            bits: bool,
        }
        impl MASK5R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK6R {
            bits: bool,
        }
        impl MASK6R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK7R {
            bits: bool,
        }
        impl MASK7R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK8R {
            bits: bool,
        }
        impl MASK8R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK9R {
            bits: bool,
        }
        impl MASK9R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK10R {
            bits: bool,
        }
        impl MASK10R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        #[doc = r" Value of the field"]
        pub struct MASK11R {
            bits: bool,
        }
        impl MASK11R {
            #[doc = r" Value of the field as raw bits"]
            #[inline]
            pub fn bit(&self) -> bool {
                self.bits
            }
            #[doc = r" Returns `true` if the bit is clear (0)"]
            #[inline]
            pub fn bit_is_clear(&self) -> bool {
                !self.bit()
            }
            #[doc = r" Returns `true` if the bit is set (1)"]
            #[inline]
            pub fn bit_is_set(&self) -> bool {
                self.bit()
            }
        }
        impl R {
            #[doc = r" Value of the register as raw bits"]
            #[inline]
            pub fn bits(&self) -> u32 {
                self.bits
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask0(&self) -> MASK0R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 0;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK0R { bits }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask1(&self) -> MASK1R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 1;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK1R { bits }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask2(&self) -> MASK2R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 2;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK2R { bits }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask3(&self) -> MASK3R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 3;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK3R { bits }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask4(&self) -> MASK4R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 4;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK4R { bits }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask5(&self) -> MASK5R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 5;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK5R { bits }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask6(&self) -> MASK6R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 6;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK6R { bits }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask7(&self) -> MASK7R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 7;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK7R { bits }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask8(&self) -> MASK8R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 8;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK8R { bits }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask9(&self) -> MASK9R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 9;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK9R { bits }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask10(&self) -> MASK10R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 10;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK10R { bits }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be masked (x = 0 to 11). 0 = No interrupt or interrupt masked on pin PIOn_x. 1 = Interrupt on PIOn_x."]
            #[inline]
            pub fn mask11(&self) -> MASK11R {
                let bits = {
                    const MASK: bool = true;
                    const OFFSET: u8 = 11;
                    ((self.bits >> OFFSET) & MASK as u32) != 0
                };
                MASK11R { bits }
            }
        }
    }
    #[doc = "Interrupt clear register for port n"]
    pub struct IC {
        register: ::vcell::VolatileCell<u32>,
    }
    #[doc = "Interrupt clear register for port n"]
    pub mod ic {
        #[doc = r" Value to write to the register"]
        pub struct W {
            bits: u32,
        }
        impl super::IC {
            #[doc = r" Writes to the register"]
            #[inline]
            pub fn write<F>(&self, f: F)
            where
                F: FnOnce(&mut W) -> &mut W,
            {
                let mut w = W::reset_value();
                f(&mut w);
                self.register.set(w.bits);
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR0W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR0W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 0;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR1W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR1W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 1;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR2W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR2W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 2;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR3W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR3W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 3;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR4W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR4W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 4;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR5W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR5W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 5;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR6W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR6W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 6;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR7W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR7W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 7;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR8W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR8W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 8;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR9W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR9W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 9;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR10W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR10W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 10;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        #[doc = r" Proxy"]
        pub struct _CLR11W<'a> {
            w: &'a mut W,
        }
        impl<'a> _CLR11W<'a> {
            #[doc = r" Sets the field bit"]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            #[doc = r" Clears the field bit"]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            #[doc = r" Writes raw bits to the field"]
            #[inline]
            pub fn bit(self, value: bool) -> &'a mut W {
                const MASK: bool = true;
                const OFFSET: u8 = 11;
                self.w.bits &= !((MASK as u32) << OFFSET);
                self.w.bits |= ((value & MASK) as u32) << OFFSET;
                self.w
            }
        }
        impl W {
            #[doc = r" Reset value of the register"]
            #[inline]
            pub fn reset_value() -> W {
                W { bits: 0 }
            }
            #[doc = r" Writes raw bits to the register"]
            #[inline]
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.bits = bits;
                self
            }
            #[doc = "Bit 0 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr0(&mut self) -> _CLR0W {
                _CLR0W { w: self }
            }
            #[doc = "Bit 1 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr1(&mut self) -> _CLR1W {
                _CLR1W { w: self }
            }
            #[doc = "Bit 2 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr2(&mut self) -> _CLR2W {
                _CLR2W { w: self }
            }
            #[doc = "Bit 3 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr3(&mut self) -> _CLR3W {
                _CLR3W { w: self }
            }
            #[doc = "Bit 4 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr4(&mut self) -> _CLR4W {
                _CLR4W { w: self }
            }
            #[doc = "Bit 5 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr5(&mut self) -> _CLR5W {
                _CLR5W { w: self }
            }
            #[doc = "Bit 6 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr6(&mut self) -> _CLR6W {
                _CLR6W { w: self }
            }
            #[doc = "Bit 7 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr7(&mut self) -> _CLR7W {
                _CLR7W { w: self }
            }
            #[doc = "Bit 8 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr8(&mut self) -> _CLR8W {
                _CLR8W { w: self }
            }
            #[doc = "Bit 9 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr9(&mut self) -> _CLR9W {
                _CLR9W { w: self }
            }
            #[doc = "Bit 10 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr10(&mut self) -> _CLR10W {
                _CLR10W { w: self }
            }
            #[doc = "Bit 11 - Selects interrupt on pin x to be cleared (x = 0 to 11). Clears the interrupt edge detection logic. This register is write-only. The synchronizer between the GPIO and the NVIC blocks causes a delay of 2 clocks. It is recommended to add two NOPs after the clear of the interrupt edge detection logic before the exit of the interrupt service routine. 0 = No effect. 1 = Clears edge detection logic for pin PIOn_x."]
            #[inline]
            pub fn clr11(&mut self) -> _CLR11W {
                _CLR11W { w: self }
            }
        }
    }
}
#[doc = "GPIO1"]
pub struct GPIO1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO1 {}
impl GPIO1 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio0::RegisterBlock {
        0x5001_0000 as *const _
    }
}
impl Deref for GPIO1 {
    type Target = gpio0::RegisterBlock;
    fn deref(&self) -> &gpio0::RegisterBlock {
        unsafe { &*GPIO1::ptr() }
    }
}
#[doc = "GPIO2"]
pub struct GPIO2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO2 {}
impl GPIO2 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio0::RegisterBlock {
        0x5002_0000 as *const _
    }
}
impl Deref for GPIO2 {
    type Target = gpio0::RegisterBlock;
    fn deref(&self) -> &gpio0::RegisterBlock {
        unsafe { &*GPIO2::ptr() }
    }
}
#[doc = "GPIO3"]
pub struct GPIO3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIO3 {}
impl GPIO3 {
    #[doc = r" Returns a pointer to the register block"]
    pub fn ptr() -> *const gpio0::RegisterBlock {
        0x5003_0000 as *const _
    }
}
impl Deref for GPIO3 {
    type Target = gpio0::RegisterBlock;
    fn deref(&self) -> &gpio0::RegisterBlock {
        unsafe { &*GPIO3::ptr() }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals"]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "I2C"]
    pub I2C: I2C,
    #[doc = "WWDT"]
    pub WWDT: WWDT,
    #[doc = "UART"]
    pub UART: UART,
    #[doc = "CT16B0"]
    pub CT16B0: CT16B0,
    #[doc = "CT16B1"]
    pub CT16B1: CT16B1,
    #[doc = "CT32B0"]
    pub CT32B0: CT32B0,
    #[doc = "CT32B1"]
    pub CT32B1: CT32B1,
    #[doc = "ADC"]
    pub ADC: ADC,
    #[doc = "USB"]
    pub USB: USB,
    #[doc = "PMU"]
    pub PMU: PMU,
    #[doc = "FMC"]
    pub FMC: FMC,
    #[doc = "SSP0"]
    pub SSP0: SSP0,
    #[doc = "IOCON"]
    pub IOCON: IOCON,
    #[doc = "SYSCON"]
    pub SYSCON: SYSCON,
    #[doc = "SSP1"]
    pub SSP1: SSP1,
    #[doc = "GPIO0"]
    pub GPIO0: GPIO0,
    #[doc = "GPIO1"]
    pub GPIO1: GPIO1,
    #[doc = "GPIO2"]
    pub GPIO2: GPIO2,
    #[doc = "GPIO3"]
    pub GPIO3: GPIO3,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*"]
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`"]
    pub unsafe fn steal() -> Self {
        debug_assert!(!DEVICE_PERIPHERALS);
        DEVICE_PERIPHERALS = true;
        Peripherals {
            I2C: I2C {
                _marker: PhantomData,
            },
            WWDT: WWDT {
                _marker: PhantomData,
            },
            UART: UART {
                _marker: PhantomData,
            },
            CT16B0: CT16B0 {
                _marker: PhantomData,
            },
            CT16B1: CT16B1 {
                _marker: PhantomData,
            },
            CT32B0: CT32B0 {
                _marker: PhantomData,
            },
            CT32B1: CT32B1 {
                _marker: PhantomData,
            },
            ADC: ADC {
                _marker: PhantomData,
            },
            USB: USB {
                _marker: PhantomData,
            },
            PMU: PMU {
                _marker: PhantomData,
            },
            FMC: FMC {
                _marker: PhantomData,
            },
            SSP0: SSP0 {
                _marker: PhantomData,
            },
            IOCON: IOCON {
                _marker: PhantomData,
            },
            SYSCON: SYSCON {
                _marker: PhantomData,
            },
            SSP1: SSP1 {
                _marker: PhantomData,
            },
            GPIO0: GPIO0 {
                _marker: PhantomData,
            },
            GPIO1: GPIO1 {
                _marker: PhantomData,
            },
            GPIO2: GPIO2 {
                _marker: PhantomData,
            },
            GPIO3: GPIO3 {
                _marker: PhantomData,
            },
        }
    }
}
